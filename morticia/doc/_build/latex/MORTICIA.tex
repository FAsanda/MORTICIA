% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{MORTICIA Documentation}
\date{Mar 08, 2017}
\release{1.0}
\author{D Griffith, A Ramkilowan}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}
{\hspace*{\fill}\includegraphics{{MORTICIAlogo6}.PNG}}



\code{MORTICIA} is Monte carlo Optical Rendering for Theatre Investigations of Capability under the Influence of the
Atmosphere. It is intended to model optical spectrum imaging sensors observing targets through the atmosphere and
to provide a statistical picture of the effectiveness of such sensors deployed in particular environments or
geographical theatres.

Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro::doc}\label{intro:welcome-to-the-documentation-for-project-morticia}
\code{MORTICIA} is Monte carlo Optical Rendering for Theatre Investigations of Capability under the Influence of the
Atmosphere.

It is intended to model optical spectrum imaging sensors observing targets through the atmosphere and
to provide a statistical picture of the effectiveness of such sensors deployed in particular environments or
geographical theatres.

\code{MORTICIA} can be used to:
\begin{itemize}
\item {} 
Model a digital image recorded by a camera (imaging optical sensor) of a particular target under specific atmospheric conditions at a given time of day.

\item {} 
Model imagery from ground-based, airborne or space optical sensors.

\item {} 
Estimate the range of Detection, Recognition and Identification (DRI) for imaging optical sensors operating in the wavelength bands from the
ultraviolet (\textasciitilde{} 300 nm wavelength) to the thermal infrared (\textasciitilde{} 14 microns wavelength).

\end{itemize}


\chapter{How to use MORTICIA}
\label{how_to_use:how-to-use-morticia}\label{how_to_use::doc}
In order to use MORTICIA you will require a python installation (version 2.7 onwards). A Python 3.x distribution is still under development.
A step-by-step guide will be provided on how to correctly use MORTICIA. From prerequisites, to installation instructions to running a simulation,
providing links to nbMORTICIA examples etc


\section{MORTICIA Dependencies}
\label{how_to_use:morticia-dependencies}
\code{MORTICIA} has been developed using the \href{https://www.continuum.io/downloads}{Anaconda} distribution from
\href{https://www.continuum.io/}{Continuum Analytics} and this is the recommended distribution for \code{MORTICIA} users.
In principle, any Python 2.7 installation that can meet the dependencies should also work.

\code{MORTICIA} makes use of a variety of other Python packages. The most important of these are:
\begin{itemize}
\item {} 
\href{http://www.numpy.org/}{numpy} and \href{http://www.scipy.org/}{scipy} : The mainstay of technical computing in Python.

\item {} 
\href{http://www.matplotlib.org/}{matplotlib} : Plotting.

\item {} 
\href{http://xray.readthedocs.org/en/stable/}{xray} : A package for handling N-dimensional data arrays and datasets with named axes. Also for reading and writing
data from netCDF format files.

\item {} 
\href{http://pandas.pydata.org/}{pandas} : For handling time-series and data in a tabular/relational view.

\item {} 
\href{https://pint.readthedocs.org/en/0.6/}{pint} : for handling unit checking and conversion. Note that using \code{pint} for all numerical operations is not
recommended and not done in \code{MORTICIA}. Rather, a \code{pint} Quantity object can be carried as metadata to an
\code{xray.DataArray} object and checked (for example using Python \code{assert}) at object construction time or judiciously
so that there is no significant performance impact of any unit checking.

\item {} 
\href{http://www.astropy.org/}{astropy} and \href{http://rhodesmill.org/pyephem/}{pyephem} : for various astronomy-related calculations (sun, moon position).

\item {} 
\href{http://easygui.sourceforge.net/}{easygui} is used for simple file/open and save dialogs.

\item {} 
\href{https://ipyparallel.readthedocs.org/en/latest/}{ipyparallel} is used for parallel computation in IPython/Jupyter notebooks as well as other Python launch modes.

\item {} 
\href{https://pypi.python.org/pypi/dill}{dill} will be required if running libRadtran on remote machines using \code{ipyparallel}

\item {} 
\href{https://pypi.python.org/pypi/paramiko/}{paramiko} will be required for authentication when using \code{ipyparallel} across machine boundaries

\end{itemize}


\section{Installation and Requirements}
\label{how_to_use:installation-and-requirements}\begin{quote}

\code{MORTICIA} has been developed largely in Python 2.7 and has not yet been tested in Python 3.X.
A working installation of \href{http://www.libradtran.org}{libRadtran} is required to compute radiant environment
maps and atmospheric transmittance. In the Monte carlo/statistical mode of operation, a compute cluster
is generally required to achieve adequate sampling in a reasonable time. Parallel computation is performed
using the \href{https://ipyparallel.readthedocs.org/en/latest/}{ipyparallel} package, which works in
IPython/Jupyter notebooks as well as other Python launch modes. In principle, with \code{ipyparallel} it is possible
to run the Python worker engines on any network-accessible compute resource. This means that it is possible to
utilise a Linux-based compute cluster with a libRadtran installation in the background, while all foreground
work is performed on a Windows machine, for example. However, this setup may require
significant setup to implement. All the required information to do this is provided in the \code{ipyparallel}
documentation. Examples are provided in the \titleref{MORTICIA} notebooks in the \href{https://github.com/derekjgriffith/nbMORTICIA}{nbMORITICIA}  repository on GitHub.
\end{quote}

The most important top-level classes in \code{MORTICIA} are Sensor, Scene and Snap.

A Sensor comprises an imaging camera on a platform. A Scene comprises at least 2 scene elements (a target and a
background). A Snap comprises a single integration period of the camera (snapshot), viewing the scene in a specific geometry
(including range) under a specific set of atmospheric and illumination conditions. Illumination can be natural
(sun, moon, stars) or artificial such as using a laser illuminator.


\chapter{The MORTICIA Style Guide}
\label{styleguide:the-morticia-style-guide}\label{styleguide::doc}\begin{quote}

The \code{MORTICIA} style guide is a comprehensive source of all things related to \code{MORTICIA} nomenclature. This guide is developed to be compatible with python 2.7, no
immediate consideration is given to python 3.x at this stage. \code{MORTICIA} developers suspect that any changes for python 3.x will be subtle, unobtrusive and non-detrimental
to \code{MORTICIA} development.

The style guide will be segmented into the following sections:
\begin{itemize}
\item {} 
Code formatting, in particular the use of PEP-8

\item {} 
Code documenting, with a focus on docstring formatting

\item {} 
Conventions indigenous to MORTICIA framework

\end{itemize}
\end{quote}


\section{To PEP-8 or not to PEP-8}
\label{styleguide:pep8}\label{styleguide:to-pep-8-or-not-to-pep-8}
While PEP-8, a high-level set of conventions has become the \emph{de facto} standard for pythonic coding, it was deemed necessary by the \code{MORTICIA} developers
to make certain exceptions. Similarly the PEP-257 is a set of guidelines for python docstrings.

A comprehensive PEP-8 guide can be found \href{http://legacy.python.org/dev/peps/pep-0008/\#a-foolish-consistency-is-the-hobgoblin-of-little-minds}{here}, while a pdf
PEP-8 cheat sheet can be found \href{https://www.google.co.za/url?sa=t\&rct=j\&q=\&esrc=s\&source=web\&cd=1\&cad=rja\&uact=8\&ved=0ahUKEwjZr-egubPKAhVH1RQKHaZKDF8QFggaMAA\&url=https\%3A\%2F\%2Fwww.pkimber.net\%2Fopen\%2F\_downloads\%2Fpep8\_cheat.pdf\&usg=AFQjCNGGoQ7DSCwaprDjuc356SwegyEkWA\&sig2=Z-aVuunhXiWS-byXk3TGCQ}{here}.

The PEP-8 guides referenced above provides a thorough encapsulation of the do's and dont's of efficient and consistent python programming, it is however not all inclusive.
There are topics which the guide does not address. This is in no way detrimental to any python development and attempting to fill these gaps are probably not an essential topic for the PEP-8 authors to address.
Importantly, the PEP-8 is just a guide and one should not become indoctrinated with it's contents. To paraphrase \href{https://en.wikipedia.org/wiki/Guido\_van\_Rossum}{Guido Van Rossum} (Python's creator), it is important for ones python code
to be consistent with PEP-8, it is more important to be consistent within a project, but it is most important to be consistent within one function or module.

The Python programming language is designed to be an \emph{easy-to-read, easy-to-write} language. The PEP-8 style guide aims to accentuate this strong point of python by providing a means of consistency and optimal readability.

For sake of completeness the more commonly used cases of PEP-8 will be shown herein. It will be split into sub sections, after which a short section on \code{MORTICIA's} deviations will be noted. Where feasible
a short discussion/ motivation together with an example will be provided


\section{Code Layout}
\label{styleguide:code-layout}\begin{itemize}
\item {} \begin{description}
\item[{\emph{Indentation}}] \leavevmode{[}Use four space indentations. Most editors enforce this rule automatically. Spaces are preferred over tabs for indentation, tabs should be used however when adding to{]}
code that already implements tabs for indentation (\textbf{consistency is key}).

\end{description}

\item {} \begin{description}
\item[{\emph{Blank lines}}] \leavevmode{[}Two blank lines on either side of a top level function or class definition. Method definitions inside a class are surrounded by a single blank line. Use blank lines{]}\begin{quote}

sparingly inside function definitions to indicate logical sections.
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}docstrings enclosed by triple quotes go here.}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{statements\PYGZus{}go\PYGZus{}here}


\PYG{k}{def} \PYG{n+nf}{top\PYGZus{}level\PYGZus{}func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{does} \PYG{n}{stuff}
        \PYG{k}{return} \PYG{n}{things}


\PYG{k}{class} \PYG{n+nc}{FooBar}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Class docstrings supplied for all public classes, functions and methods}

\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}


        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{foo}\PYG{p}{,} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{:}

                \PYG{n}{initialise} \PYG{n}{things} \PYG{o+ow}{in} \PYG{n}{here}
                \PYG{k}{return}

        \PYG{k}{def} \PYG{n+nf}{internal\PYGZus{}func}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{bar}\PYG{p}{,} \PYG{n}{foo}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}note that method this local function is surrounded by a single blank line}
\PYG{l+s+sd}{                \PYGZdq{}\PYGZdq{}\PYGZdq{}}
                \PYG{n}{perform} \PYG{n}{some} \PYG{n}{calculation}\PYG{o}{/} \PYG{n}{data} \PYG{n}{manipulation}

                \PYG{k}{return} \PYG{n}{something}


\PYG{c+c1}{\PYGZsh{} do stuff outside the class}
\end{Verbatim}

\end{description}

\item {} 
\emph{Line length} :       The PEP-8 style guide suggests a 79 column limit to all lines. The following is captured verbatim from the python PEP-8 style guide referenced earlier{}`
\begin{quote}

``The limits are chosen to avoid wrapping in editors with the window width set to 80, even if the tool places
a marker glyph in the final column when wrapping lines. Some web based tools may not offer dynamic line
wrapping at all.

Some teams strongly prefer a longer line length. For code maintained exclusively or primarily by a
team that can reach agreement on this issue, it is okay to increase the nominal line length from 80 to 100
characters (effectively increasing the maximum length to 99 characters), provided that comments
and docstrings are still wrapped at 72 characters....''

The \titleref{MORTICIA} team have decided to conservatively follow the 99 character limit. Where possible and proves
efficient line splitting is used.
\end{quote}

\end{itemize}


\section{Import Statements}
\label{styleguide:import-statements}
This is a simple example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}
\end{Verbatim}


\section{Whitespace}
\label{styleguide:whitespace}

\section{Comments}
\label{styleguide:comments}

\section{Documentation Strings (docstrings)}
\label{styleguide:documentation-strings-docstrings}

\section{Naming Conventions}
\label{styleguide:naming-conventions}
This is an important one, the style of naming different python objects should make identifying the type of object intuitive


\section{PEP-257}
\label{styleguide:pep-257}

\section{\emph{From} Conventions Section}
\label{styleguide:from-conventions-section}
There is a data dictionary for \code{MORTICIA} which defines commonly used variable and data names.

xray.DataArray objects are created routinely, so the constructor is abbreviated to xD.

\code{MORTICIA} often deals with spectral variables, such as spectral transmission, spectral radiance etc.
More often than not, these arrays are multidimensional. The \titleref{xray} package is used in \titleref{MORTICIA} for
purposes of representing N-dimensional arrays (the \titleref{xray.DataArray} class).

However, \titleref{xray} does not (yet) support interpolation when the coordinates of the data hypercube are
not the same and two or more \titleref{xray.DataArray} objects must be added, divided or multiplied.

Utility functions that operate on xray.DataArray objects are found in the \titleref{morticia.tools.xd} package.
These functions perform axis harmonisation as well as unit checking and conversion.

The axis harmonisation functions for \titleref{xray.DataArray} objects requires that all axes have numeric coordinates.
This applies also to axes that would benefit from having text labels. Text labels would be more appropriate for
axes such as spectral channels and field orientation for MTF data. In the case of spectral channels (with axis label
\titleref{chn}) will be channel numbers. These channel numbers would normally start from 0, but in some cases, such as when
using a sub-range of correlated-k band models (e.g. \titleref{kato} or \titleref{fu} in libRadtran) the channel numbers would be a
range of integers. The convention in \code{MORTICIA} is that the text labels then be placed in an axis attribute called
\titleref{labels}.

This curently applies equally well to timeseries. For incorporation in multi-axis \titleref{xray.DataArray} objects, timestamps
must be converted to Julian date. A list of labels for such axes can and should be maintained in the \titleref{xray.DataArray}
attributes (\titleref{attrs}).


\subsection{Units of Measure}
\label{styleguide:units-of-measure}
Tracking of units of measure is not performed automatically in \code{MORTICIA} such as with the use of the pint package.
However, many functions and classes in \code{MORTICIA} expect xray.DataArray instances that provide units of measure in
the metadata. When units are provided in this way, they should be provided in manner consistent with the Python units
package \href{https://pint.readthedocs.org/}{pint} .

Commonly, when a \code{MORTICIA} function or method requires a scalar numeric input, it must be provided as a list
with magnitude and units e.g. {[}30, `mm'{]}. Unitless quantities are provided as a simple numeric magnitude.

If a variable is named \code{x}, then the units for the variable can be stored as \code{units} in the xray.DataArray
attributes dictionary (actually an OrderedDict). This units string should be recognizable to \titleref{pint} as a valid unit.
When exporting xray.DataArray objects to NetCDF files in xray.Dataset objects, this convention of using the
\titleref{units} attribute is recognised by NetCDF browsers and other NetCDF utilities. Further information on conventional
NetCDF attributes can be found at
\href{https://www.unidata.ucar.edu/software/thredds/current/netcdf-java/metadata/DataDiscoveryAttConvention.html}{UCAR/Unidata}.
See the \code{MORTICIA} notebooks for examples of creating \titleref{xray} objects with unit attributes.

The UCAR/Unidata attributes for NetCDF file elements considered as highly recommended are
\begin{itemize}
\item {} 
\titleref{units}, units expressed as a string - SI units preferred

\item {} 
\titleref{long\_name}, such as may commonly be used to label graph axes

\item {} 
\titleref{standard\_name}, the standard name that may be used in a specific scientific community

\end{itemize}

and for \code{MORTICIA}, also
\begin{itemize}
\item {} 
\titleref{title}, such as may be used on the title of a plot of the data

\item {} 
\titleref{labels}, such as may be used in the legends of a plot

\end{itemize}

The \titleref{standard\_name} should come from the CF (Climate and Forecasting) name glossary, or the project should have
its own vocabulary of short, standard and long names for all variables. These are to be found in the
\titleref{morticia.moglo.py} module and may be expanded or updated from time to time.

A pint global unit registry is created when \titleref{morticia} or any sub-package is imported. Any other \titleref{morticia} paackages
or modules share a single global unit registry called ureg. Convenience functions \code{Q\_} for \code{Quantity} and \code{U\_} for
\code{Quantity(1.0, unit\_str)} are also defined. Examples of usage are provided in the Jupyter notebooks/tutorials.


\subsection{\emph{From} Coordinate Systems}
\label{styleguide:from-coordinate-systems}
The general observer/target topocentric, cartesian coordinate system used in \titleref{MORTICIA} is +x towards North, +y towards
the East and +z towards the zenith. Zenith angles are polar angles measured from the +z axis. This is a left-handed
system and the alternative right-handed sytem is the same, except with +z towards nadir.

The global Earth Centered Earth Fixed (ECEF) coordinate system has the north pole in the +Z direction, the prime
meridian (0 deg longitude) in the +X direction and the +Y direction at 90 deg east longitude. This is a right-handed
coordinate system.

When dealing with sightlines and camera orientations, several conventions can be used. The
\href{https://en.wikipedia.org/wiki/Euler\_angles}{Euler angles} provide (relative to a given coordinate system,
typically topocentric/geodetic) the view azimuth angle (VAZ = \(\alpha\)) and view zenith angle (VZA =
\(\beta\)). The camera roll is then the third Euler angle \(\gamma\).


\subsection{Logging Warnings and Exception Handling}
\label{styleguide:logging-warnings-and-exception-handling}
As a rule, \titleref{MORTICIA} does not use logging to files. Preferably, if any checking is performed, exceptions are thrown.
Informational messages should printed to the terminal using the \titleref{logging.info()} or \titleref{logging.debug()} calls.
Warnings that the user should take action on are provided through \titleref{warnings.warn()}. If the warning may relate to
the fact that \titleref{MORTICIA} code should be improved or debugged, it should be issued through \titleref{logging.warning()}.
\titleref{MORTICIA} internal modules do not define any logging handlers or filters. This is left to the user.


\section{General Terminology and Conventions}
\label{styleguide:general-terminology-and-conventions}

\subsection{Camera and Imager}
\label{styleguide:camera-and-imager}
A \titleref{Camera} object in MORTICIA does \emph{not} include a Lens - it is a camera body, including an FPA and a
digitisation stage (which may be fully integrated into the FPA chip - a so-called ``camera on a chip'').
The \titleref{Imager} class incorporates a Camera and a Lens and is capable of producing actual imagery.


\subsection{Modulation Transfer Function Calculation}
\label{styleguide:modulation-transfer-function-calculation}
For image modelling purposes, it is necessary to know the full 2D MTF, whereas the normal situation is that the
MTF is described using horizontal and vertical MTF profile functions. Suppose that \(\eta\) and \(\xi\) are
the spatial frequencies in the horizontal and vertical directions respectively and the \(M\!T\!F_\eta(\eta)\) and
\(M\!T\!F_\xi(\xi)\) are the 1D MTFs in the horizontal and vertical directions. The 2D MTF is then computed as
a rotationally weighted mean of the 1D MTFs as
\begin{align*}\begin{aligned}
\begin{split}M\!T\!F(\eta,\xi)=\frac{\eta^{2}M\!T\!F_{\eta}\left(\sqrt{\eta^{2}+\xi^{2}}\right)+\xi^{2}M\!T\!F_{\xi}\left(\sqrt{\eta^{2}+\xi^{2}}\right)}{\eta^{2}+\xi^{2}},\end{split}\end{aligned}\end{align*}
and if the sagittal spatial frequency is defined as \(\rho=\sqrt{\eta^{2}+\xi^{2}}\), then
\begin{align*}\begin{aligned}
\begin{split}M\!T\!F(\eta,\xi)=\frac{\eta^{2}M\!T\!F_{\eta}\left(\rho\right)+\xi^{2}M\!T\!F_{\xi}\left(\rho\right)}{\rho^{2}}.\end{split}\end{aligned}\end{align*}
It is assumed here that the horizontal and vertical MTFs are symmetrical about the origin.


\chapter{For the Developers}
\label{for_developers:for-the-developers}\label{for_developers::doc}
\code{MORTICIA} is an open-source project, we thus welcome contributions and or suggestions. If you are interested you may:
\begin{enumerate}
\item {} 
Fork us on \href{https://github.com/derekjgriffith/MORTICIA}{Github}

\item {} 
Subscribe to our mailing list here

\item {} 
Follow us on our twitter handle @MORTICIA

\end{enumerate}


\section{Structure}
\label{for_developers:structure}
This section will disclose the structure of MORTICIA, and how different segments interface with each other. It is mainly aimed at developers not so much the users.

The most important top-level objects in \code{MORTICIA} are {\hyperref[packages:sensor\string-package]{\crossref{\DUrole{std,std-ref}{Sensor}}}} , {\hyperref[packages:scene\string-package]{\crossref{\DUrole{std,std-ref}{Scene}}}} and Snap


\chapter{Packages}
\label{packages:packages}\label{packages::doc}
This is a sub-menu for all the packages


\section{Sensor Package}
\label{packages:sensor-package}\label{packages:id1}
The sensor package provides modelling of complete sensors, typically comprising an optical objective lens and
a focal plane detector as a minimum (a camera). A sensor may also include a display and a human observer. The display
and human observer are required in order to calculate ranges and probabilities of target detection, recognitions and
identification (DRI).

Capability is also provided to model direct view systems comprising a telescope or binocular and human observer, without
any electronics in the sensor chain.


\subsection{Optics Module}
\label{packages:id2}\label{packages:optics-module}
The optics module provides modelling of basic objective lenses used by imaging systems. For the most part, these are
optical systems that are near to diffraction-limited, with centred circular entrance pupils, possibly with a centred
circular obscuration (as in a Cassegrain or Newtonian telescope).
\phantomsection\label{packages:module-optics}\index{optics (module)}\index{Lens (class in optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.Lens}\pysiglinewithargsret{\strong{class }\code{optics.}\bfcode{Lens}}{\emph{efl}, \emph{fno}, \emph{trn}, \emph{wfe=None}, \emph{obs=None}, \emph{mtf=None}, \emph{wvn\_step=500.0}, \emph{wfe\_allowed=0.3}, \emph{attrs=None}}{}
The Lens class encapsulates information and behaviour related to imaging lens systems.
The chief characteristics of a lens are its spectral through-field, through-focus and
through-frequency MTF, as well as the spectral transmission.
In order to transform spatial frequencies in the image plane to angular spatial frequencies
in object space, the effective focal length of the lens (efl) must also be known.
The basic lens model is a near diffraction-limited system with a centred circular aperture
having a centred circular obscuration (which may be absent), where the MTF is constant over
the entire field of view (FOV). A lens with field-dependent MTF can be constructed by
providing wavefront error input that varies with field.

The most basic lens model implemented here, from which more complicated lens models could inherit
their properties have the following attributes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{efl}} -- The effective focal length of the lens in mm

\item {} 
\textbf{\texttt{fno}} -- The focal ratio of the lens

\item {} 
\textbf{\texttt{trn}} -- The spectral transmission of the lens (zero to unity).

\item {} 
\textbf{\texttt{wfe}} -- The wavefront error measured in waves. This can be a scalar, assumed the same for
all wavelengths, or it can be provided as a function of wavelength and/or field position.

\item {} 
\textbf{\texttt{obs}} -- The obscuration ratio, being the ratio of the circular obscuration diameter to the
full circular aperture aperture diameter

\item {} 
\textbf{\texttt{mtf}} -- The MTF of the lens. Either the MTF can be provided as a set of measurements or it can be
computed from efl, fno, obs and wfe

\end{itemize}

\end{description}\end{quote}

The lens MTF is computed as a function of spatial frequency in the image, wavelength, defocus and field position.

The total RMS wavefront error is computed as
\begin{align*}\begin{aligned}
\begin{split}W=\sqrt{W_{\Delta\!z}^{2}+W_{a}^{2}}=\sqrt{\left(\frac{\Delta\!z}{8\lambda F^{2}}\right)^{2}+W_{a}^{2}}\end{split}\end{aligned}\end{align*}
where \(\Delta\!z\) is the defocus expressed in the same units as the wavelength \(\lambda\), \(F\) is
the focal ratio and \(W_a\) is the RMS waverfront error due to aberrations at best focus.

Lens constructor.
The lens is constructed using the focal length, focal ratio and spectral transmittance, and
optionally also the obscuration ratio and wavefront error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{efl}} -- The effective focal length of the lens. The effective focal length must be a scalar value
with units, e.g. {[}30, `mm'{]}.

\item {} 
\textbf{\texttt{fno}} -- The focal ratio (or f-number) which is th ratio of focal length to aperture diameter. This input
must be a scalar value.

\item {} 
\textbf{\texttt{trn}} (\emph{\texttt{xarray.DataArray}}) -- The spectral transmission function, typically a function of wavelength. The spectral
transmittance function must be

\item {} 
\textbf{\texttt{wfe}} -- The wavefront error must be expressed in waves (unitless). It can be a function of
wavelength (wvl) and field position (flr) , but not focus (fldz). If no input is provided, the wfe
will default to zero over the same spectral region as the lens transmission function.

\item {} 
\textbf{\texttt{obs}} -- The obscuration ratio of the lens (scalar numeric) range 0.0 - 1.0, Default None (0.0)

\item {} 
\textbf{\texttt{mtf}} -- A complete pre-computed or measured MTF, with axes of spf, wvl, fldz, flr, flo

\item {} 
\textbf{\texttt{wvn\_step}} -- Minimum spectral increment in wavenumbers (cm\textasciicircum{}-1) for MTF calculation. Default 500 cm\textasciicircum{}-1

\item {} 
\textbf{\texttt{wfe\_allowed}} -- Maximum allowed wfe when computing lens defocus wfe, Default 0.5 waves at mean wavelength
of transmission function domain.

\item {} 
\textbf{\texttt{attrs}} -- A dictionary of user-defined attributes and metadata. Consider including `name' and
`long\_name', `title', `summary' or other netCDF convention attributes.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}
\index{\_\_init\_\_() (optics.Lens method)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.Lens.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{efl}, \emph{fno}, \emph{trn}, \emph{wfe=None}, \emph{obs=None}, \emph{mtf=None}, \emph{wvn\_step=500.0}, \emph{wfe\_allowed=0.3}, \emph{attrs=None}}{}
Lens constructor.
The lens is constructed using the focal length, focal ratio and spectral transmittance, and
optionally also the obscuration ratio and wavefront error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{efl}} -- The effective focal length of the lens. The effective focal length must be a scalar value
with units, e.g. {[}30, `mm'{]}.

\item {} 
\textbf{\texttt{fno}} -- The focal ratio (or f-number) which is th ratio of focal length to aperture diameter. This input
must be a scalar value.

\item {} 
\textbf{\texttt{trn}} (\emph{\texttt{xarray.DataArray}}) -- The spectral transmission function, typically a function of wavelength. The spectral
transmittance function must be

\item {} 
\textbf{\texttt{wfe}} -- The wavefront error must be expressed in waves (unitless). It can be a function of
wavelength (wvl) and field position (flr) , but not focus (fldz). If no input is provided, the wfe
will default to zero over the same spectral region as the lens transmission function.

\item {} 
\textbf{\texttt{obs}} -- The obscuration ratio of the lens (scalar numeric) range 0.0 - 1.0, Default None (0.0)

\item {} 
\textbf{\texttt{mtf}} -- A complete pre-computed or measured MTF, with axes of spf, wvl, fldz, flr, flo

\item {} 
\textbf{\texttt{wvn\_step}} -- Minimum spectral increment in wavenumbers (cm\textasciicircum{}-1) for MTF calculation. Default 500 cm\textasciicircum{}-1

\item {} 
\textbf{\texttt{wfe\_allowed}} -- Maximum allowed wfe when computing lens defocus wfe, Default 0.5 waves at mean wavelength
of transmission function domain.

\item {} 
\textbf{\texttt{attrs}} -- A dictionary of user-defined attributes and metadata. Consider including `name' and
`long\_name', `title', `summary' or other netCDF convention attributes.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{mtf\_obs\_wfe() (optics.Lens method)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.Lens.mtf_obs_wfe}\pysiglinewithargsret{\bfcode{mtf\_obs\_wfe}}{}{}
Compute the multidimensional MTF of a Lens class object


\strong{See also:}

\begin{itemize}
\item {} \begin{description}
\item[{optics.atf which shows the method and formula by which the aberration/defocus MTF degradation is}] \leavevmode
computed.

\end{description}

\item {} 
optics.mtf\_obs shows documents the typical calculation formulas for obscured MTF

\end{itemize}



\end{fulllineitems}


\end{fulllineitems}

\index{atf() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.atf}\pysiglinewithargsret{\code{optics.}\bfcode{atf}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{rms\_wavefront\_error}}{}
Compute the MTF degradation factor for a lens operating at the given wavelengths and and with the given
focal ratios, RMS wavefront errors at the the specified spatial frequencies in the image plane.
ATF stands for Aberration Transfer Function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image plane at which to compute the ATF. Spatial frequencies must be in
reciprocal units to wavelengths i.e. if wavelengths are in mm, spatial frequencies must be in cycles per mm.

\item {} 
\textbf{\texttt{wvl}} -- Wavelengths at which to compute the ATF

\item {} 
\textbf{\texttt{fno}} -- Focal ratios at which to compute the ATF

\item {} 
\textbf{\texttt{rms\_wavefront\_error}} -- RMS wavefront error magnitudes (in waves) at which to compute the ATF

\end{itemize}

\item[{Returns}] \leavevmode
A numpy array with the aberration transfer function.

\end{description}\end{quote}

Reference : Shannon, R.R., Handbook of Optics, Volume 1, 2nd Edition, Chapter 35 - Optical
Specifications. ``This is an approximation, however, and it becomes progressively less accurate as
the amount of the rms wavefront error exceeds about 0.18 wavelength.''

The formula used for computing the aberration MTF due to RMS wavefront error of \(W\) at spatial frequency
\(f\) is
\begin{align*}\begin{aligned}
\begin{split}M\!T\!F_{W}(f)=1-\left(\frac{W}{0.18}\right)^{2}\left[1-4\left(\frac{f}{f_{c}}-\frac{1}{2}\right)^{2}\right]\end{split}\end{aligned}\end{align*}
where the diffraction cutoff (or ``critical'') frequency is \(f_c\).


\strong{See also:}


optics.pmtf\_obs\_wfe



\end{fulllineitems}

\index{autocorr\_circle() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.autocorr_circle}\pysiglinewithargsret{\code{optics.}\bfcode{autocorr\_circle}}{\emph{circle\_radius}, \emph{shift}}{}
Compute autocorrelation of a circular aperture of radius \textbf{circle\_radius} with centre-to-centre sample
displacements of \textbf{shift}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{circle\_radius}} -- Radius of circle

\item {} 
\textbf{\texttt{shift}} -- Centre-to-centre displacements at which to compute the autocorrelation

\end{itemize}

\item[{Returns}] \leavevmode
Autocorrelation magnitude

\end{description}\end{quote}


\strong{See also:}


optics.crosscorr\_circle



\end{fulllineitems}

\index{crosscorr\_circle() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.crosscorr_circle}\pysiglinewithargsret{\code{optics.}\bfcode{crosscorr\_circle}}{\emph{circle\_radius}, \emph{shift}}{}
Cross correlation of unit circle with circle of radius \textbf{circle\_radius}.
Compute the cross-correlation of a circular aperture of unit radius at the origin,
with a circular aperture of radius \textbf{circle\_radius}, with centre-to-centre displacements of \textbf{shift}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{circle\_radius}} -- Radius of circle to cross-correlate with unit circle (scalar numeric)

\item {} 
\textbf{\texttt{shift}} -- Centre-to-centre displacements at which to compute the cross-correlation

\end{itemize}

\item[{Returns}] \leavevmode
Cross-correlation magnitude

\end{description}\end{quote}


\strong{See also:}


optics.autocorr\_circle



\end{fulllineitems}

\index{ctf\_eye() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.ctf_eye}\pysiglinewithargsret{\code{optics.}\bfcode{ctf\_eye}}{\emph{spf}, \emph{lum}, \emph{w}, \emph{num\_eyes=2}, \emph{formula=1}}{}
Compute the contrast transfer function of the human eye.
By default, uses the condensed version of the Barten CTF.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- spatial frequencies in eye-space in cycles per milliradian (scalar or vector numpy array input)

\item {} 
\textbf{\texttt{lum}} -- mean luminance of the viewing area in \(cd/m^2\) (scalar or vector numpy array input)

\item {} 
\textbf{\texttt{w}} -- the angular width of the viewing area, or the square root of the angular viewing area in square degrees
(scalar or vector numpy input).

\item {} 
\textbf{\texttt{num\_eyes}} -- The number of eyes used for viewing (2 for binocular viewing or 1 for monocular viewing). The
default is num\_eyes=2.

\item {} 
\textbf{\texttt{formula}} -- The formula variant used for the computation. Defaults (formula=1) to the simple formula first
published by Barten in SPIE 2003. Other options are formula=11 and formula=14, which are slight variations.

\end{itemize}

\item[{Returns}] \leavevmode
The CTF with respect to spf, lum and w (up to a 3D numpy array). Singular dimensions are squeezed out
using numpy.squeeze().

\end{description}\end{quote}

\end{fulllineitems}

\index{mtf() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.mtf}\pysiglinewithargsret{\code{optics.}\bfcode{mtf}}{\emph{spf}, \emph{wvl}, \emph{fno}}{}
Compute the simple (optimally focussed) diffraction Modulation Transfer Function (MTF) of a perfect lens with an
unobscured circular aperture.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image at which to compute the MTF

\item {} 
\textbf{\texttt{wvl}} -- Wavelength in units consistent with the spatial frequencies f

\item {} 
\textbf{\texttt{fno}} -- Focal ratio (working focal ratio) of the lens

\end{itemize}

\item[{Returns}] \leavevmode
Modulation Transfer Function, with spatial frequency (spf) varying down columns and wavelength across rows
If the frequencies are given in cycles per millimetre, the wavelengths must be in mm.

\end{description}\end{quote}

Any of the inputs can be a vector. The spatial frequencies are assigned to the rows of the output array, the
wavelengths vary from column to column and Fno will vary in the third dimension, but singleton dimensions will
be squeezed out.


\strong{See also:}


optics.pmtf, optics.pmtf\_obs, optics.pmtf\_obs\_wfe



\end{fulllineitems}

\index{mtf\_obs() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.mtf_obs}\pysiglinewithargsret{\code{optics.}\bfcode{mtf\_obs}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{obs=0.0}}{}
Compute the optimally focussed diffraction Modulation Transfer Function of a perfect lens with an
circular aperture having a centred circular obscuration. This is the monochromatic MTF computed at
a number of discrete given wavelengths.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image at which to compute the MTF (numpy vector).

\item {} 
\textbf{\texttt{wvl}} -- Wavelength in units consistent with the spatial frequencies \textbf{spf} (numpy vector)

\item {} 
\textbf{\texttt{fno}} -- Focal ratio (working focal ratio) of the lens (numpy vector).

\item {} 
\textbf{\texttt{obs}} -- The obscuration ratio (ratio of obscuration diameter to total aperture diameter).
The obs input must be a scalar numeric.

\end{itemize}

\item[{Returns}] \leavevmode
MTF with respect to spatial frequency, wavelength, focal ratio and obscuration ratio.
Singleton dimensions are squeezed out.

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_air() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.n_air}\pysiglinewithargsret{\code{optics.}\bfcode{n\_air}}{\emph{wvl}, \emph{temperature}, \emph{pressure}}{}
Return the refractive index of air computed using the same formula used by ZEMAX
See the section on Index of Refraction Computation in the Thermal Analysis chapter of the ZEMAX manual.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{wvl}} -- Wavelength(s) in microns. If all values of wvl exceed 100, then wavelengths are assumed to be in nm

\item {} 
\textbf{\texttt{temperature}} -- Temperature in Celsius.

\item {} 
\textbf{\texttt{pressure}} -- Relative air pressure (atmospheres, with 1 atm = 101 325 Pa).

\end{itemize}

\item[{Returns}] \leavevmode
This function returns a matrix with wvl varying from row to row, temperature varying from column to column
and pressure varying in the depth dimension. The returned matrix is subject to np.squeeze() to remove any
singleton dimensions.

\end{description}\end{quote}

Reference :
F. Kohlrausch, Praktische Physik, 1968, Vol 1, page 408

\end{fulllineitems}

\index{patf() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.patf}\pysiglinewithargsret{\code{optics.}\bfcode{patf}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{rms\_wavefront\_error}, \emph{wvl\_weights}}{}
Compute the polychromatic aberration transfer function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image plane at which to compute the ATF. Spatial frequencies must be in
reciprocal units to wavelengths i.e. if wavelengths are in mm, spatial frequencies must be in cycles per mm.

\item {} 
\textbf{\texttt{wvl}} -- Wavelengths at which to compute the ATF

\item {} 
\textbf{\texttt{fno}} -- Focal ratios at which to compute the ATF

\item {} 
\textbf{\texttt{rms\_wavefront\_error}} -- RMS wavefront error magnitudes (in waves) at which to compute the ATF

\item {} 
\textbf{\texttt{wvl\_weights}} -- A numpy vector having the same length as the wvl vector, providing the relative weights of each
of the wavelengths.

\end{itemize}

\item[{Returns}] \leavevmode
Polychromatic Aberration Transfer Function in a numpy array.

\end{description}\end{quote}


\strong{See also:}


optics.atf



\end{fulllineitems}

\index{pmtf() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.pmtf}\pysiglinewithargsret{\code{optics.}\bfcode{pmtf}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{wvl\_weights}}{}
Compute polychromatic MTF of lens at given spatial frequencies (in the image plane) for specified wavelengths
and wavelength weighting factors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).

\item {} 
\textbf{\texttt{wvl}} -- Wavelength in units consistent with the spatial frequencies \textbf{spf} (numpy vector)

\item {} 
\textbf{\texttt{fno}} -- Focal ratio (working focal ratio) of the lens (numpy vector).

\item {} 
\textbf{\texttt{wvl\_weights}} -- A numpy vector having the same length as the wvl vector, providing the relative weights of each
of the wavelengths.

\end{itemize}

\item[{Returns}] \leavevmode
Polychromatic MTF with respect to spatial frequency, wavelength and focal ratio.
Singleton dimensions are squeezed out of the returned numpy array.

\end{description}\end{quote}

\end{fulllineitems}

\index{pmtf\_obs() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.pmtf_obs}\pysiglinewithargsret{\code{optics.}\bfcode{pmtf\_obs}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{wvl\_weights}, \emph{obs=0.0}}{}
Compute polychromatic MTF of obscured lens at given spatial frequencies (in the image plane) for specified
wavelengths and wavelength weighting factors. The lens may have a circular obcuration of specific ratio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).

\item {} 
\textbf{\texttt{wvl}} -- Wavelength in units consistent with the spatial frequencies \textbf{spf} (numpy vector)

\item {} 
\textbf{\texttt{fno}} -- Focal ratio (working focal ratio) of the lens (numpy vector).

\item {} 
\textbf{\texttt{wvl\_weights}} -- A numpy vector having the same length as the wvl vector, providing the relative weights of each
of the wavelengths.

\item {} 
\textbf{\texttt{obs}} -- Obscuration ratio

\end{itemize}

\item[{Returns}] \leavevmode
Polychromatic obscured MTF with respect to spatial frequency, wavelength and focal ratio.
Singleton dimensions are squeezed out of the returned numpy array.

\end{description}\end{quote}

\end{fulllineitems}

\index{pmtf\_obs\_wfe() (in module optics)}

\begin{fulllineitems}
\phantomsection\label{packages:optics.pmtf_obs_wfe}\pysiglinewithargsret{\code{optics.}\bfcode{pmtf\_obs\_wfe}}{\emph{spf}, \emph{wvl}, \emph{fno}, \emph{rms\_wavefront\_error}, \emph{wvl\_weights}, \emph{obs=0.0}}{}
Compute polychromatic modulation transfer function for lens having circular pupil with centred circular
obscuration and with aberrations expressed in terms of RMS wavefront error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spf}} -- Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).

\item {} 
\textbf{\texttt{wvl}} -- Wavelength in units consistent with the spatial frequencies \textbf{spf} (numpy vector)

\item {} 
\textbf{\texttt{fno}} -- Focal ratio (working focal ratio) of the lens (numpy vector).

\item {} 
\textbf{\texttt{rms\_wavefront\_error}} -- Numpy vector of RMS wavefront error values

\item {} 
\textbf{\texttt{wvl\_weights}} -- A numpy vector having the same length as the wvl vector, providing the relative weights of each
of the wavelengths.

\item {} 
\textbf{\texttt{obs}} -- Obscuration ratio (centred circular obscuration in circular pupil), ratio of obscuration diameter to
aperture diameter.

\end{itemize}

\item[{Returns}] \leavevmode
Numpy array with polychromatic modulation transfer function.

\end{description}\end{quote}


\strong{See also:}


optics.atf, optics.pmtf\_obs, optics.pmtf



\end{fulllineitems}



\subsection{Electronics Module}
\label{packages:electronics-module}\label{packages:id3}
The electronics module provides modelling of all electronic components in the imaging chain. Inclusion
of any electronic component into a sensor results in an ``electro-optical'' sensor. Electronic components include
\begin{itemize}
\item {} 
Solid state electro-optical detectors, including focal plane array (FPA) detectors

\item {} 
Image intensifier tubes

\item {} 
Image processing components

\item {} 
Display systems

\end{itemize}
\phantomsection\label{packages:module-electro}\index{electro (module)}\index{Camera (class in electro)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.Camera}\pysiglinewithargsret{\strong{class }\code{electro.}\bfcode{Camera}}{\emph{fpa}, \emph{ad\_bit\_depth}, \emph{digital\_gain=None}, \emph{digital\_offset=(0.0}, \emph{`count')}, \emph{noise=(0.0}, \emph{`count')}, \emph{sitf=None}, \emph{exp\_time\_min=(1e-05}, \emph{`s')}, \emph{exp\_time\_max=(inf}, \emph{`s')}, \emph{attrs=None}}{}
The Camera class composes a FocalPlaneArray (FPA) together with a gain stage (signal transfer function),
an analogue-to-digital converter of specific bit depth and an additional amplifier noise. The Camera
converts photoelectrons to digital output data.
NB : A Camera object in MORTICIA does \emph{not} include the Lens. The most basic sensor object that includes a lens
is an Imager object which includes a lens and a camera.

Camera constructor. This class if for representation of a Camera, which incorporates
a FocalPlaneArray and a converter stage which converts photoelectrons into digital levels (also called
digital numbers - DN and in MORTICIA, the pint unit `count' is used).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fpa}} -- The FocalPlaneArray incorporated into the Camera

\item {} 
\textbf{\texttt{ad\_bit\_depth}} -- Number of bits in the Analogue-to-Digital A/D converter. Must be provided in MORTICIA
scalar format as e.g. {[}16, `bit'{]}

\item {} 
\textbf{\texttt{digital\_gain}} -- The number of photoelectrons required to raise the output by 1 digital level (DN)
Must be provided in MORTICIA scalar format as e.g. {[}2.2, `e/count'{]}.

\item {} 
\textbf{\texttt{digital\_offset}} -- The digital level (DN) output of the camera for zero photoelectrons. This is not
the ``black level'', which typically includes additional dark signal. Must be provided in MORTICIA
scalar format as e.g. {[}10.0, `count'{]}.

\item {} 
\textbf{\texttt{noise}} -- An optional additional noise component to add to the signal. Must be provided as a
MORTICIA scalar in either electrons or counts e.g. {[}2, `e'{]}. This is an RMS noise component,
which is equivalent to a standard deviation.

\item {} 
\textbf{\texttt{sitf}} -- Signal transfer function (SiTF). As an alternative to providing the digital\_gain and
digital\_offset, (particularly should the camera have essentially non-linear response) the SiTF
can be provided as an xray.DataArray, with the input axis in units of electrons (`e') and
the data in units of digital level (`count'). If digital\_gain and digital\_offset are provided,
the SiTF is calculated and stored internally as an xray.DataArray.

\end{itemize}

\end{description}\end{quote}

:param
:param attrs: A user-defined dictionary of other information about this Camera object. Could include
\begin{quote}

items such as `model', `manufacturer' etc. A `title' and `long\_name' are recommended attributes.
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}
\index{\_\_init\_\_() (electro.Camera method)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.Camera.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{fpa}, \emph{ad\_bit\_depth}, \emph{digital\_gain=None}, \emph{digital\_offset=(0.0}, \emph{`count')}, \emph{noise=(0.0}, \emph{`count')}, \emph{sitf=None}, \emph{exp\_time\_min=(1e-05}, \emph{`s')}, \emph{exp\_time\_max=(inf}, \emph{`s')}, \emph{attrs=None}}{}
Camera constructor. This class if for representation of a Camera, which incorporates
a FocalPlaneArray and a converter stage which converts photoelectrons into digital levels (also called
digital numbers - DN and in MORTICIA, the pint unit `count' is used).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fpa}} -- The FocalPlaneArray incorporated into the Camera

\item {} 
\textbf{\texttt{ad\_bit\_depth}} -- Number of bits in the Analogue-to-Digital A/D converter. Must be provided in MORTICIA
scalar format as e.g. {[}16, `bit'{]}

\item {} 
\textbf{\texttt{digital\_gain}} -- The number of photoelectrons required to raise the output by 1 digital level (DN)
Must be provided in MORTICIA scalar format as e.g. {[}2.2, `e/count'{]}.

\item {} 
\textbf{\texttt{digital\_offset}} -- The digital level (DN) output of the camera for zero photoelectrons. This is not
the ``black level'', which typically includes additional dark signal. Must be provided in MORTICIA
scalar format as e.g. {[}10.0, `count'{]}.

\item {} 
\textbf{\texttt{noise}} -- An optional additional noise component to add to the signal. Must be provided as a
MORTICIA scalar in either electrons or counts e.g. {[}2, `e'{]}. This is an RMS noise component,
which is equivalent to a standard deviation.

\item {} 
\textbf{\texttt{sitf}} -- Signal transfer function (SiTF). As an alternative to providing the digital\_gain and
digital\_offset, (particularly should the camera have essentially non-linear response) the SiTF
can be provided as an xray.DataArray, with the input axis in units of electrons (`e') and
the data in units of digital level (`count'). If digital\_gain and digital\_offset are provided,
the SiTF is calculated and stored internally as an xray.DataArray.

\end{itemize}

\end{description}\end{quote}

:param
:param attrs: A user-defined dictionary of other information about this Camera object. Could include
\begin{quote}

items such as `model', `manufacturer' etc. A `title' and `long\_name' are recommended attributes.
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FocalPlaneArray (class in electro)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.FocalPlaneArray}\pysiglinewithargsret{\strong{class }\code{electro.}\bfcode{FocalPlaneArray}}{\emph{pitch}, \emph{aperture}, \emph{pixels}, \emph{wellcapacity}, \emph{readnoise}, \emph{darkcurrent}, \emph{dsnu}, \emph{prnu}, \emph{sqe=None}, \emph{asr=None}, \emph{t\_ref=(25.0}, \emph{`degC')}, \emph{darkcurrent\_delta\_t=(7.0}, \emph{`delta\_degC')}, \emph{temperature=(25.0}, \emph{`degC')}, \emph{attrs=None}}{}
Focal plane array detector. This implementation is typically at the chip level. That is, all or most of the
information for building an FPA object can be found in the chip-level datasheet. The FPAs in question here
are usually CCD, CMOS, scientific CMOS or electron-multiplying CCD (EMCCD).

The FPA class can be combined with an image intensifier tube (IIT) to produce an ICCD device.

This class does not model Time-Delay and Integration (TDI), which is a dynamic imaging process.

The class does allow for setting of FPA operating temperature and recalculation of dark current
based on the dark current doubling delta temperature.

The FPA is a component of a Camera class object and has the basic function of converting photons to
photoelectrons. FPA object can have multiple spectral channels as with a colour camera. The colour sampling
spatial pattern can be as for a Bayer filter or a 3-CCD camera.

Constructor for FocalPlaneAArray objects
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pitch}} -- The centre-to-centre spacing of the FPA detector elements. This must be a list where the
first element is the centre-to-centre spacing in the x-direction (or both x and y), the second element is
the spacing in the y-direction (if different from the x-direction) and the last element is the units
in which the pitch is provided (string). The units must be pint-recognizable.

\item {} 
\textbf{\texttt{aperture}} -- The effective pixel aperture of the FPA detector elements. This must also be a list, providing
the x-aperture of the pixel, y-aperture (if different from x) and the units (string).

\item {} 
\textbf{\texttt{pixels}} -- A list of number of pixels in the x and y directions respectively

\item {} 
\textbf{\texttt{wellcapacity}} -- The well capacity of the pixel in number of electrons

\item {} 
\textbf{\texttt{readnoise}} -- The RMS read noise in electrons.

\item {} 
\textbf{\texttt{darkcurrent}} -- The dark current as a list, giving nagnitude and units. Units can be electrons per pixel
per second (e/s), or in an amperage per pixel (A/s) or an amperage per unit area of the FPA (e.g. A/cm\textasciicircum{}2)

\item {} 
\textbf{\texttt{dsnu}} -- The dark signal non uniformity provided as a list giving the magnitude in the first element
and units in the second element. The units can also be e/s, A or A/area. This is the standard deviation.
The DSNU can also be specified as 0.0 or None.

\item {} 
\textbf{\texttt{prnu}} -- The photo-response non-uniformity. This is also a standard deviation and must be provided in units
of `\%'. That is, the prnu input is a list with the magnitude in the first position and the obligatory
string `\%' in the second position.

\item {} 
\textbf{\texttt{sqe}} -- This is a xray.DataArray object providing the Spectral Quantum Efficiency of the FPA. SQE must be
provided with a single axis of wavelength values. The attribute sqe\_units must be provided in the
DataArray attributes and it must be dimensionless (the literal empty string `'). If any of the values
exceeds unity, the SQE is assumed to be provided in percent. Alternatively, the asr input can be provided,
but either the sqe or the asr input must be provided and not both, since they can be converted one from
the other. SQE outside the spectral domain provided is assumed to be zero.

\item {} 
\textbf{\texttt{asr}} -- This is a xray.DataArray object providing the Absolute Spectral Response of the FPA. It can be
provided as an alternative to the SQE. It must have the single axis of wavelength. Units are equivalent
to A/W (photoelectron current per unit optical flux).

\item {} 
\textbf{\texttt{t\_ref}} -- The reference temperature at which the dark current and other parameters are specified.
To be provided as a {[}value, `units'{]} list. Default is {[}25.0, `degC'{]}.

\item {} 
\textbf{\texttt{darkcurrent\_delta\_t}} -- The increase in temperature that causes doubling of the dark current.
Default is {[}7.0, `delta\_degC'{]}.

\item {} 
\textbf{\texttt{temperature}} -- The operating temperature of the FocalPlaneArray. Default {[}25.0, `degC'{]}

\item {} 
\textbf{\texttt{attrs}} -- Dictionary of attributes and metadata. Entries with `name', `long\_name', `title',
`summary' or others, especially as per netCDF attribute conventions.
The `manufacturer' should possibly also be provided.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}
\index{\_\_init\_\_() (electro.FocalPlaneArray method)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.FocalPlaneArray.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{pitch}, \emph{aperture}, \emph{pixels}, \emph{wellcapacity}, \emph{readnoise}, \emph{darkcurrent}, \emph{dsnu}, \emph{prnu}, \emph{sqe=None}, \emph{asr=None}, \emph{t\_ref=(25.0}, \emph{`degC')}, \emph{darkcurrent\_delta\_t=(7.0}, \emph{`delta\_degC')}, \emph{temperature=(25.0}, \emph{`degC')}, \emph{attrs=None}}{}
Constructor for FocalPlaneAArray objects
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pitch}} -- The centre-to-centre spacing of the FPA detector elements. This must be a list where the
first element is the centre-to-centre spacing in the x-direction (or both x and y), the second element is
the spacing in the y-direction (if different from the x-direction) and the last element is the units
in which the pitch is provided (string). The units must be pint-recognizable.

\item {} 
\textbf{\texttt{aperture}} -- The effective pixel aperture of the FPA detector elements. This must also be a list, providing
the x-aperture of the pixel, y-aperture (if different from x) and the units (string).

\item {} 
\textbf{\texttt{pixels}} -- A list of number of pixels in the x and y directions respectively

\item {} 
\textbf{\texttt{wellcapacity}} -- The well capacity of the pixel in number of electrons

\item {} 
\textbf{\texttt{readnoise}} -- The RMS read noise in electrons.

\item {} 
\textbf{\texttt{darkcurrent}} -- The dark current as a list, giving nagnitude and units. Units can be electrons per pixel
per second (e/s), or in an amperage per pixel (A/s) or an amperage per unit area of the FPA (e.g. A/cm\textasciicircum{}2)

\item {} 
\textbf{\texttt{dsnu}} -- The dark signal non uniformity provided as a list giving the magnitude in the first element
and units in the second element. The units can also be e/s, A or A/area. This is the standard deviation.
The DSNU can also be specified as 0.0 or None.

\item {} 
\textbf{\texttt{prnu}} -- The photo-response non-uniformity. This is also a standard deviation and must be provided in units
of `\%'. That is, the prnu input is a list with the magnitude in the first position and the obligatory
string `\%' in the second position.

\item {} 
\textbf{\texttt{sqe}} -- This is a xray.DataArray object providing the Spectral Quantum Efficiency of the FPA. SQE must be
provided with a single axis of wavelength values. The attribute sqe\_units must be provided in the
DataArray attributes and it must be dimensionless (the literal empty string `'). If any of the values
exceeds unity, the SQE is assumed to be provided in percent. Alternatively, the asr input can be provided,
but either the sqe or the asr input must be provided and not both, since they can be converted one from
the other. SQE outside the spectral domain provided is assumed to be zero.

\item {} 
\textbf{\texttt{asr}} -- This is a xray.DataArray object providing the Absolute Spectral Response of the FPA. It can be
provided as an alternative to the SQE. It must have the single axis of wavelength. Units are equivalent
to A/W (photoelectron current per unit optical flux).

\item {} 
\textbf{\texttt{t\_ref}} -- The reference temperature at which the dark current and other parameters are specified.
To be provided as a {[}value, `units'{]} list. Default is {[}25.0, `degC'{]}.

\item {} 
\textbf{\texttt{darkcurrent\_delta\_t}} -- The increase in temperature that causes doubling of the dark current.
Default is {[}7.0, `delta\_degC'{]}.

\item {} 
\textbf{\texttt{temperature}} -- The operating temperature of the FocalPlaneArray. Default {[}25.0, `degC'{]}

\item {} 
\textbf{\texttt{attrs}} -- Dictionary of attributes and metadata. Entries with `name', `long\_name', `title',
`summary' or others, especially as per netCDF attribute conventions.
The `manufacturer' should possibly also be provided.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_mtf() (electro.FocalPlaneArray method)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.FocalPlaneArray.compute_mtf}\pysiglinewithargsret{\bfcode{compute\_mtf}}{}{}~\begin{description}
\item[{Compute the MTF of a FocalPlaneArray. In this model, the FPA is assumed to be a rectangular array}] \leavevmode
having pixels with rectangular aperture.

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{set\_dark\_current() (electro.FocalPlaneArray method)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.FocalPlaneArray.set_dark_current}\pysiglinewithargsret{\bfcode{set\_dark\_current}}{}{}
Set the dark current of the FocalPlaneArray (FPA) according to the dark current reference temperature and
the current operating temperature of the FPA.
:return:

\end{fulllineitems}


\end{fulllineitems}

\index{Imager (class in electro)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.Imager}\pysiglinewithargsret{\strong{class }\code{electro.}\bfcode{Imager}}{\emph{lens}, \emph{camera}, \emph{attrs=None}}{}
The Imager class encapsulates a complete imaging system with an optics.Lens and an electro.Camera.
The Imager class can provide the digital outputs of the Lens+Camera when looking into a scene that provides the
at-aperture (or at-sensor) radiance (the radiance apparent at the aperture of the Lens).

Constructor for Imager class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{lens}} -- The optics.Lens for the Imager.

\item {} 
\textbf{\texttt{camera}} -- The electro.Camera for the Imager.

\item {} 
\textbf{\texttt{attrs}} -- User-defined dictionary of additional attributes, such as `title', `summary', `long\_name',
`manufacturer', especially those recommended for the netCDF conventions.

\end{itemize}

\item[{Returns}] \leavevmode
an Imager object

\end{description}\end{quote}
\index{\_\_init\_\_() (electro.Imager method)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.Imager.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{lens}, \emph{camera}, \emph{attrs=None}}{}
Constructor for Imager class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{lens}} -- The optics.Lens for the Imager.

\item {} 
\textbf{\texttt{camera}} -- The electro.Camera for the Imager.

\item {} 
\textbf{\texttt{attrs}} -- User-defined dictionary of additional attributes, such as `title', `summary', `long\_name',
`manufacturer', especially those recommended for the netCDF conventions.

\end{itemize}

\item[{Returns}] \leavevmode
an Imager object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{xd\_asr2sqe() (in module electro)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.xd_asr2sqe}\pysiglinewithargsret{\code{electro.}\bfcode{xd\_asr2sqe}}{\emph{asr}}{}
Convert absolute spectral response (ASR) to spectral quantum efficiency (SQE).
\begin{quote}

The conversion is performed through the Planck relationship
\begin{align*}\begin{aligned}
\begin{split}E=h\nu\end{split}\end{aligned}\end{align*}
where \(E\) is the photon energy, \(h\) is the planck constant and \(\nu\) is the optical
frequency.
In terms of optical wavelength in a vacuum, the planck relation is
\begin{align*}\begin{aligned}
\begin{split}E=\frac{hc}{\lambda}\end{split}\end{aligned}\end{align*}
where \(c\) is the speed of light and \(\lambda\) is the wavelength.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{asr}} -- An xray.DataArray object providing the absolute spectral response (ASR). The DataArray must have a single
axis providing the wavelength points, together with the standard attribute `units' for the wavelength axis.

\item[{Returns}] \leavevmode
Spectral Quantum Efficiency as an xray.DataArray object. Returned wavelengths will be `nm' in
the wavelength (`wvl') axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{xd\_sqe2asr() (in module electro)}

\begin{fulllineitems}
\phantomsection\label{packages:electro.xd_sqe2asr}\pysiglinewithargsret{\code{electro.}\bfcode{xd\_sqe2asr}}{\emph{sqe}}{}
Convert spectral quantum efficiency (SQE) to absolute spectral response.
This is the reverse conversion of that provided by electro.xd\_asr2sqe.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sqe}} -- The spectral quantum efficiency (SQE), provided as a xray.DataArray object in which SQE is
provided as a function of wavelength. The wavelength axis must provide the `units' attribute.

\item[{Returns}] \leavevmode
Absolute spectral response (ASR) as an xray.DataArray object, havin a single axis of wavelength
coordinates (`wvl'). Returned units for the wavelength axis will be `nm'.

\end{description}\end{quote}

\end{fulllineitems}



\section{Radiometry Package}
\label{packages:id4}\label{packages:radiometry-package}
The radiometry package provides all MORTICIA functionality relating to radiometry and atmospheric radiative transfer.
Atmospheric radiative transfer is performed by the \href{http://www.libradtran.org}{libRadtran} suite of tools.


\subsection{LibRadTran Module}
\label{packages:librad-module}\label{packages:libradtran-module}
The LibRadTran module concerns itself with calculations for the radiant environment map. It solves the radiative transfer equation for a complex system.
\begin{itemize}
\item {} 
Item 1

\item {} 
Item 2

\item {} 
Item 3

\item {} 
Item 4

\end{itemize}
\phantomsection\label{packages:module-librad}\index{librad (module)}\index{Case (class in librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case}\pysiglinewithargsret{\strong{class }\code{librad.}\bfcode{Case}}{\emph{casename='`}, \emph{filename=None}, \emph{optionlist=None}}{}
Class which encapsulates a run case of libRadtran/uvspec.
This class has methods to read libRadtran/uvspec input files, write uvspec input files, run uvspec in parallel on
multiple compute nodes and read uvspec output files. An important use-case is that of reading a uvspec input
file called the ``base case'', altering the parameters of particular option keywords and then running the case
and reading the outputs. This class is also used by the RadEnv class which encapsulates a radiant environment.
Construction of radiant environment maps typically requires running an array of librad.Case instances.

Instantiate a libRadtran/uvspec case, typically by reading a uvspec .INP file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{casename}} -- A user-defined name for the libRadtran/uvspec case

\item {} 
\textbf{\texttt{filename}} -- An optional filename from which to read the libRadtran/uvspec input

\item {} 
\textbf{\texttt{optionlist}} -- A list of option keywords and parameteres (tokens). The keyword existence
is verified. Besides that, no error checking is performed automatically.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Read a libRadtran/uvspec case from a .INP file and display the expanded input}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{morticia}\PYG{n+nn}{.}\PYG{n+nn}{rad}\PYG{n+nn}{.}\PYG{n+nn}{librad} \PYG{k}{as} \PYG{n+nn}{librad}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{libRadCase} \PYG{o}{=} \PYG{n}{librad}\PYG{o}{.}\PYG{n}{Case}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./examples/UVSPEC\PYGZus{}AEROSOL.INP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Read uvspec input and expand includes, if any}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{libRadCase}   \PYG{c+c1}{\PYGZsh{} This prints the uvspec input file, compare to contents of UVSPEC\PYGZus{}AEROSOL.INP}
\PYG{g+go}{atmosphere\PYGZus{}file ../data/atmmod/afglus.dat}
\PYG{g+go}{source solar ../data/solar\PYGZus{}flux/atlas\PYGZus{}plus\PYGZus{}modtran}
\PYG{g+go}{mol\PYGZus{}modify O3 300. DU}
\PYG{g+go}{day\PYGZus{}of\PYGZus{}year 170}
\PYG{g+go}{albedo 0.2}
\PYG{g+go}{sza 32.0}
\PYG{g+go}{rte\PYGZus{}solver disort}
\PYG{g+go}{number\PYGZus{}of\PYGZus{}streams 6}
\PYG{g+go}{wavelength 299.0 341.0}
\PYG{g+go}{slit\PYGZus{}function\PYGZus{}file ../examples/TRI\PYGZus{}SLIT.DAT}
\PYG{g+go}{spline 300 340 1}
\PYG{g+go}{quiet}
\PYG{g+go}{aerosol\PYGZus{}vulcan 1}
\PYG{g+go}{aerosol\PYGZus{}haze 6}
\PYG{g+go}{aerosol\PYGZus{}season 1}
\PYG{g+go}{aerosol\PYGZus{}visibility 20.0}
\PYG{g+go}{aerosol\PYGZus{}angstrom 1.1 0.2}
\PYG{g+go}{aerosol\PYGZus{}modify ssa scale 0.85}
\PYG{g+go}{aerosol\PYGZus{}modify gg set 0.70}
\PYG{g+go}{aerosol\PYGZus{}file tau ../examples/AERO\PYGZus{}TAU.DAT}
\end{Verbatim}
\index{\_\_init\_\_() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{casename='`}, \emph{filename=None}, \emph{optionlist=None}}{}
Instantiate a libRadtran/uvspec case, typically by reading a uvspec .INP file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{casename}} -- A user-defined name for the libRadtran/uvspec case

\item {} 
\textbf{\texttt{filename}} -- An optional filename from which to read the libRadtran/uvspec input

\item {} 
\textbf{\texttt{optionlist}} -- A list of option keywords and parameteres (tokens). The keyword existence
is verified. Besides that, no error checking is performed automatically.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Read a libRadtran/uvspec case from a .INP file and display the expanded input}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{morticia}\PYG{n+nn}{.}\PYG{n+nn}{rad}\PYG{n+nn}{.}\PYG{n+nn}{librad} \PYG{k}{as} \PYG{n+nn}{librad}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{libRadCase} \PYG{o}{=} \PYG{n}{librad}\PYG{o}{.}\PYG{n}{Case}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./examples/UVSPEC\PYGZus{}AEROSOL.INP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Read uvspec input and expand includes, if any}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{libRadCase}   \PYG{c+c1}{\PYGZsh{} This prints the uvspec input file, compare to contents of UVSPEC\PYGZus{}AEROSOL.INP}
\PYG{g+go}{atmosphere\PYGZus{}file ../data/atmmod/afglus.dat}
\PYG{g+go}{source solar ../data/solar\PYGZus{}flux/atlas\PYGZus{}plus\PYGZus{}modtran}
\PYG{g+go}{mol\PYGZus{}modify O3 300. DU}
\PYG{g+go}{day\PYGZus{}of\PYGZus{}year 170}
\PYG{g+go}{albedo 0.2}
\PYG{g+go}{sza 32.0}
\PYG{g+go}{rte\PYGZus{}solver disort}
\PYG{g+go}{number\PYGZus{}of\PYGZus{}streams 6}
\PYG{g+go}{wavelength 299.0 341.0}
\PYG{g+go}{slit\PYGZus{}function\PYGZus{}file ../examples/TRI\PYGZus{}SLIT.DAT}
\PYG{g+go}{spline 300 340 1}
\PYG{g+go}{quiet}
\PYG{g+go}{aerosol\PYGZus{}vulcan 1}
\PYG{g+go}{aerosol\PYGZus{}haze 6}
\PYG{g+go}{aerosol\PYGZus{}season 1}
\PYG{g+go}{aerosol\PYGZus{}visibility 20.0}
\PYG{g+go}{aerosol\PYGZus{}angstrom 1.1 0.2}
\PYG{g+go}{aerosol\PYGZus{}modify ssa scale 0.85}
\PYG{g+go}{aerosol\PYGZus{}modify gg set 0.70}
\PYG{g+go}{aerosol\PYGZus{}file tau ../examples/AERO\PYGZus{}TAU.DAT}
\end{Verbatim}

\end{fulllineitems}

\index{alter\_option() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.alter_option}\pysiglinewithargsret{\bfcode{alter\_option}}{\emph{option}, \emph{origin=(`user'}, \emph{None)}}{}
Alter the parameters of a uvspec input option. If the option is not found, the option is appended with
append\_option instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{option}} -- List of keyword and tokens (parameters) to provide to the option keyword (list of strings).

\item {} 
\textbf{\texttt{origin}} -- A 2-tuple noting the ``origin'' of the change to this keyword. Default (`user', None)

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{append\_option() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.append_option}\pysiglinewithargsret{\bfcode{append\_option}}{\emph{option}, \emph{origin=(`user'}, \emph{None)}}{}
Append a libRadtran/uvspec options to this uvspec case. It will be appended at the end of the file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{option}} -- A list containing the keyword and keyword parameters (tokens). Boson keywords must be passed
in ``welded''. e.g. x.append\_option({[}'mol\_modify O3', `270.0',  `DU'{]})

\item {} 
\textbf{\texttt{origin}} -- A 2-tuple giving the origin of the option and a ``line number'' reference. Default (`user', None)
uvspec options.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{del\_option() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.del_option}\pysiglinewithargsret{\bfcode{del\_option}}{\emph{option}, \emph{all=True}}{}
Delete a uvspec input option matching the given option.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{option}} -- Keyword of option to be deleted

\item {} 
\textbf{\texttt{all}} -- A flag indicating if all matching options must be deleted or only the first occurrence. The

\end{itemize}

\end{description}\end{quote}

default is to delete all matching occurrences.
:return: True if an option was deleted or False if not

\end{fulllineitems}

\index{distribute\_flux\_data() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.distribute_flux_data}\pysiglinewithargsret{\bfcode{distribute\_flux\_data}}{\emph{fluxdata}}{}
Distribute flux/user data read from uvspec output file to various data fields.
This method will look at \titleref{output\_user} options and attempt to assign flux/user data in a sensible way.
.. note:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{There} \PYG{n}{are} \PYG{n}{potentially} \PYG{n}{uvspec} \PYG{n}{output} \PYG{n}{formats} \PYG{n}{that} \PYG{n}{are} \PYG{o+ow}{not} \PYG{n}{possible} \PYG{n}{to} \PYG{n}{process} \PYG{o+ow}{or} \PYG{n}{to} \PYG{n}{assign} \PYG{n}{correctly}\PYG{o}{.}
\PYG{n}{These} \PYG{n}{are} \PYG{n}{typically} \PYG{n}{cases} \PYG{o+ow}{in} \PYG{n}{which} \PYG{n}{it} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{possible} \PYG{n}{to} \PYG{n}{determine} \PYG{k+kn}{from} \PYG{n+nn}{the} \PYG{o}{.}\PYG{n}{INP} \PYG{o+ow}{and}\PYG{o}{/}\PYG{o+ow}{or} \PYG{o}{.}\PYG{n}{OUT} \PYG{n}{file}
\PYG{n}{how} \PYG{n}{this} \PYG{n}{data} \PYG{n}{should} \PYG{n}{be} \PYG{n}{assigned}\PYG{o}{.}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fluxdata}} -- Flux (irradiance) data read from uvspec output file

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{irrad\_units\_str() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.irrad_units_str}\pysiglinewithargsret{\bfcode{irrad\_units\_str}}{\emph{latex=False}}{}
Provide an irradiance units string e.g. W/m\textasciicircum{}2/nm.
If output\_quantity is set to `brightness' or `reflectivity', irrad\_units will be `K' or `' respectively.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Irradiance units as a string

\end{description}\end{quote}

\end{fulllineitems}

\index{merge\_caselist\_by\_wavelength() (librad.Case static method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.merge_caselist_by_wavelength}\pysiglinewithargsret{\strong{static }\bfcode{merge\_caselist\_by\_wavelength}}{\emph{caselist}, \emph{attr\_name}}{}
Merges data in a particular attribute (property) of a list of librad.Case

This function can be used to merge data from a list of runs created using the function
split\_case\_by\_wavelength.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{caselist}} -- list of librad.Case after all cases have been run

\item {} 
\textbf{\texttt{attr\_name}} -- name of attribute to merge e.g. `edir'

\end{itemize}

\item[{Returns}] \leavevmode
merged wavelengths, requested attribute as numnpy arrays

\end{description}\end{quote}


\strong{See also:}


split\_case\_by\_wavelength



\end{fulllineitems}

\index{prepare\_for\_keyword() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.prepare_for_keyword}\pysiglinewithargsret{\bfcode{prepare\_for\_keyword}}{\emph{keyword}, \emph{tokens}}{}
Make any possible preparations for occurrences of particular keywords
:param keyword: The uvspec option keyword (string)
:param tokens: The parameters (tokens) for the keyword as a list of strings
:return:

\end{fulllineitems}

\index{prepare\_for\_mol\_abs\_param() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.prepare_for_mol_abs_param}\pysiglinewithargsret{\bfcode{prepare\_for\_mol\_abs\_param}}{\emph{tokens}}{}
Make preparations for the desired molecular absorption parametrization. There are various
molecular absorption options in libRadtran/uvspec and the options will certainly evolve.
The default mode is to perform a spectral calculation (fine wavelength grid) with output
of spectral radiances and irradiances. Some of the other modes, such as \titleref{crs} also output
spectral data. The \titleref{crs} mode actually switches off molecular line absorption and considers
only spectrally continuous scattering and absorption. This is really only good for the UV/blue
spectrum. The \titleref{reptran\_channel} mode and the correlated-k modes (\titleref{kato} variants, \titleref{fu}, \titleref{avhrr\_kratz}
and \titleref{lowtran}/\titleref{sbdart}) do not produce spectral radiances and irradiances. They produce band quantities
which may even be summed using the \titleref{output\_process sum} directive. A sub-range of correlated-k
bins/channels can be selected using the \titleref{wavelength\_index} directive.

See the libRadtran manual for further information on the relevant options.
:return:

\end{fulllineitems}

\index{prepare\_for\_output\_process() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.prepare_for_output_process}\pysiglinewithargsret{\bfcode{prepare\_for\_output\_process}}{\emph{tokens}}{}
Prepare for effects of the \titleref{output\_process} keyword in the libRadtran/uvspec input file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{tokens}} -- Keyword tokens of the uvspec \titleref{output\_process} keyword.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_for\_polradtran() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.prepare_for_polradtran}\pysiglinewithargsret{\bfcode{prepare\_for\_polradtran}}{}{}
Prepare for output from the polradtran solver
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_for\_source() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.prepare_for_source}\pysiglinewithargsret{\bfcode{prepare\_for\_source}}{\emph{tokens}}{}
Prepare for source, particularly units of various kinds, depending on the source.
libRadtran/uvspec source options are mainly `solar' and `thermal' with some additional options
for units.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{tokens}} -- uvspec `source' keyword option parameters (tokens)

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_outputs() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.process_outputs}\pysiglinewithargsret{\bfcode{process\_outputs}}{}{}
Process outputs from libRadtran into moglo.Scalar and xr.DataArray objects.
Currently only radiance outputs are processed, along with a few typical flux outputs, such as \titleref{edir}.

Note that this method probably does not cover all libRadtran/uvspec inputs and outputs and will most
likely continue to evolve, perhaps breaking existing code.
:return: None

\end{fulllineitems}

\index{rad\_units\_str() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.rad_units_str}\pysiglinewithargsret{\bfcode{rad\_units\_str}}{\emph{latex=False}}{}
Provide a radiance units string e.g. W/sr/m\textasciicircum{}2/nm.
If output\_quantity is set to `brightness' or `reflectivity', rad\_units will be `K' or `' respectively.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Radiance units as a string

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (librad.Case static method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.read}\pysiglinewithargsret{\strong{static }\bfcode{read}}{\emph{path}, \emph{includes\_seen={[}{]}}}{}
Reads a libRadtran input file. This will construct the libRadtran case from the contents of the .INP file
Adapted from code by libRadtran developers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- File path from which to read the uvspec input

\item {} 
\textbf{\texttt{includes\_seen}} -- List of files already included (for recursion purposes to avoid infinite include loops)

\end{itemize}

\item[{Returns}] \leavevmode
data, line\_nos, path
where data is the full data in the file with includes, line\_nos shows the source of every line and
path is the path to the main input file.

\end{description}\end{quote}

\end{fulllineitems}

\index{readerr() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.readerr}\pysiglinewithargsret{\bfcode{readerr}}{\emph{filename=None}}{}
Read any error output from the uvspec run and attach it to the self object in the self.stderr property

It is important to check error output to see if the uvspec run was successful or what diagnostics were
provided.

WARNING : If the `verbose' option is used in the uvspec input file, the error output file can be VERY large.
The `verbose' option prints a large amount of information relating to setup of the RT problem. Please refer to
the libRadtran manual in respect of using `verbose'. It is encouraged in the beginning stages of setting up
an RT problem to verify correctness, but with (perhaps) a single wavelength to reduce the stderr output
volume.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- The name of te error file to read. If not provided, the default filename will be used. If
provided as the empty string `', a file/open dialog will be presented.

\item[{Returns}] \leavevmode
True if a file was read and False if the file was not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{readout() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.readout}\pysiglinewithargsret{\bfcode{readout}}{\emph{filename=None}}{}
Read uvspec output and assign to variables as intelligently as possible.
\begin{quote}
\begin{description}
\item[{The general process of reading is:}] \leavevmode\begin{enumerate}
\item {} 
If the user has specified output\_user, just assume a flat file and read using
np.loadtxt or np.genfromtxt.

\item {} 
If not user\_output and the solver has no radiance blocks, assume a flat file and
read using np.loadtxt. The variables to be read should be contained in the self.fluxline attribute.

\item {} 
Otherwise, if the output has radiance blocks, read those depending on the radiance block
format for the specific solver. Keep reading flux and radiance blocks until the file is exhausted.

\end{enumerate}

\end{description}

Once the data has all been read, the data is split up between the number of output levels and number of
wavelengths. For radiance data, the order of numpy dimensions is \emph{umu}, \emph{phi}, \emph{wavelength}, \emph{zout} and \emph{stokes}. That
is, if a case has multiple zenith angles, multiple azimuth angles, multiple wavelengths and multiple output
levels, the radiance property uu will have 4 dimensions. In the case of polradtran, there will be 5
dimensions to include the stokes parameters (if more than 1, which is the I = intensity parameter).
\end{quote}

Output from uvspec depends on the solver and a number of other inputs, including the directive \code{output\_user{}`.
For the solvers {}`{}`disort}, \code{sdisort}, \code{spsdisort} and presumably also \code{disort2}, the irradiance (flux) outputs default
to

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{edir} \PYG{n}{edn} \PYG{n}{eup} \PYG{n}{uavgdir} \PYG{n}{uavgdn} \PYG{n}{uavgup}
\end{Verbatim}

If radiances (intensities) have been requested with the umu
(cosine zenith angles input), each line of flux data is followed
by a block of radiance data as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

where u0u is the azimuthally averaged radiance for the requested zenith
angles.

If azimuth angles (phi) have also been specified, then the
radiance block is extended as follows:

\begin{Verbatim}[commandchars=\\\{\}]
                       \PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}     \PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Radiance outputs are not affected by output\_user options.

For the polradtran solver, the flux block is as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{down\PYGZus{}flux}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{up\PYGZus{}flux}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{down\PYGZus{}flux}\PYG{p}{(}\PYG{n}{iS}\PYG{p}{)} \PYG{n}{up\PYGZus{}flux}\PYG{p}{(}\PYG{n}{iS}\PYG{p}{)}
\end{Verbatim}

where iS is the number of Stokes parameters specified using the
`polradtran nstokes' directive.
If umu and phi are also specified, the radiance block is as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
                        \PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}      \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}      \PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{Stokes} \PYG{n}{vector} \PYG{n}{I}
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{n}{u0u}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{uu}\PYG{p}{(}\PYG{n}{umu}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Stokes} \PYG{n}{vector} \PYG{n}{Q}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\PYG{o}{.} \PYG{o}{.} \PYG{o}{.}
\end{Verbatim}

The u0u (azimuthally averaged radiance) is always zero for
polradtran.

For the two-stream solver (twostr), the flux block is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{edir} \PYG{n}{edn} \PYG{n}{eup} \PYG{n}{uavg}
\end{Verbatim}

The directive keyword \code{brightness} can also change output. The documentation simply states that radiances and
irradiances are just converted to brightness temperatures.

The keyword directive \code{zout} and it's parameters will influence output format as well. In general the output
is repeated for each given value of \code{zout} or \code{zout\_sea}.

The keyword directive \code{output} and its parameters will also have a major effect.

The \code{output sum} keyword sums output data over the wavelength dimension. This in contrast to \code{output integrate},
which performs a spectral integral.

The keyword directive \code{header} should not be used at all. This produces some header information in the output
that will cause errors. A warning is issued of the \code{header} keyword is used in the input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- File from which to read the output. Defaults to name of input file, but with the .OUT

\end{description}\end{quote}

extension.
:return: None

\end{fulllineitems}

\index{run() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.run}\pysiglinewithargsret{\bfcode{run}}{\emph{stderr\_to\_file=True}, \emph{write\_input=True}, \emph{read\_output=True}, \emph{block=True}, \emph{purge=True}, \emph{check\_output=False}}{}
Run the libRadtran/uvspec case.

This will run the libRadtran/uvspec Case instance provided. Some control is provided regarding the handling of
the standard error output from uvspec. This function only returns when uvspec terminates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{stderr\_to\_file}} -- Controls whether standard error output goes to the screen or is written to a file
having the same name as the input/output files, except with the extension .ERR. Default is true.
Any error output

\item {} 
\textbf{\texttt{write\_input}} -- Controls whether the input file is written out before execution. Default is True.

\item {} 
\textbf{\texttt{read\_output}} -- Controls whether the output file is read after execution. Default is True.

\item {} 
\textbf{\texttt{block}} -- By default, this method waits until uvspec terminates. If set False, the uvspec process
is released to background and read\_output is set to False (regardless of user input).

\item {} 
\textbf{\texttt{purge}} -- If set True, the input and output files from this run will be deleted after the run is complete
and the outputs have been read. Will only be honoured if read\_output is also True. Default is True.
To prevent purging for a particular librad.Case, set the individual case property to False.

\item {} 
\textbf{\texttt{check\_output}} -- If set True, the uvspec command is executed using the subprocess.check\_output call, which
will place the standard output from the run in self.check\_output. This is useful for diagnostic
purposes.

\end{itemize}

\item[{Returns}] \leavevmode
Returns self. This is important for running across networks.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_option() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.set_option}\pysiglinewithargsret{\bfcode{set\_option}}{\emph{*superlist}}{}
Set a uvspec input option with flexible input format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{superlist}} -- All set\_option arguments are collected into a list which are coverted to strings
(if not already strings), splitting each resulting string at spaces.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{morticia}\PYG{n+nn}{.}\PYG{n+nn}{rad}\PYG{n+nn}{.}\PYG{n+nn}{librad} \PYG{k}{as} \PYG{n+nn}{librad}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{libRadCase} \PYG{o}{=} \PYG{n}{librad}\PYG{o}{.}\PYG{n}{Case}\PYG{p}{(}\PYG{n}{casename}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MyExample}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Creates a blank libRadtran/uvspec case}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{libRadCase}\PYG{o}{.}\PYG{n}{set\PYGZus{}option}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{source solar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data/solar\PYGZus{}flux/atlas\PYGZus{}plus\PYGZus{}modtran}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{libRadCase}\PYG{o}{.}\PYG{n}{set\PYGZus{}option}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wavelength}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+m+mi}{400}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} can provide literal numerics}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{libRadCase}
\end{Verbatim}

\end{fulllineitems}

\index{set\_view\_geometry() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.set_view_geometry}\pysiglinewithargsret{\bfcode{set\_view\_geometry}}{\emph{sza=0.0}, \emph{saa=0.0}, \emph{oza=0.0}, \emph{oaa=0.0}}{}
Set the Case view geometry relative to the sun

Sets the sun and observer zenith and azimuth angles. Note that libRadtran/uvspec sets the light
propagation azimuth angle in the \code{phi} and \code{phi0} inputs. This is 180\$\textasciicircum{}circ\$ different in
azimuth to the direction of viewing. The \code{phi0} input is the direction of solar light propagation
from the sun and is \(180^\circ\) from the saa input here. However, the \code{phi} input is the direction
of light propagation from target to sensor and is therefore \emph{the same} as the oaa input to this
function.

The \code{umu} input to libRadtran/uvspec is the cosine of the zenith angle of light propagation
from target to sensor. Hence \code{umu} is positive for downward-looking (upward-propagating) cases.

Also, from the libRadtran manual :
phi = phi0 indicates that the sensor looks into the direction of the sun, while
phi-phi0 = 180 deg means that the sun is behind the sensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sza}} -- solar zenith angle in degrees from the zenith (range 0 to 90 degrees)

\item {} 
\textbf{\texttt{saa}} -- solar azimuth angle in degrees from north through east (range zero to )

\item {} 
\textbf{\texttt{oza}} -- observation zenith angle in degrees from the zenith. Note that this is the zenith angle
of a vector pointing from the target/scene to the observer (satellite/sensor).

\item {} 
\textbf{\texttt{oaa}} -- observation azimuth angle in degrees from north through east. Note again that this is the
azimuth angle of a vector pointing from the target/scene to the observer.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_wavelength\_grid() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.set_wavelength_grid}\pysiglinewithargsret{\bfcode{set\_wavelength\_grid}}{\emph{wvl\_grid}}{}
Set the internal RT solver wavelength grid for this librad.Case

This method sets the internal grid for the RT calculations in libRadtran. Study the libRadtran manual
before trying to use this option. Once this function has been used, the option wavelength\_grid\_file
will be activated and the grid file will be \emph{casename\_wvl\_grid.dat}, where the casename is the name of
the librad.Case. When the case is Run, the wavelength grid file will be written out to the current
directory before uvspec is executed. By default (unless purge is disabled), the file will also
automatically be deleted once the tun terminates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{wvl\_grid}} -- An np.array of floats that provide the wavelengths in nm at which to perform the
internal radiative transfer calculation.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{split\_case\_by\_wavelength() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.split_case_by_wavelength}\pysiglinewithargsret{\bfcode{split\_case\_by\_wavelength}}{\emph{n\_sub\_ranges}, \emph{overlap}}{}
Split a librad.Case into a list of cases with wavelength sub-ranges
This function can be useful to distribute a case over a compute cluster. Equal wavelength interval sub-cases
should have similar runtimes. Use ipyparallel to run the list on a cluster. If the wavelength range
is sufficiently large, consider setting n\_sub\_ranges to the number of available processors.

This function only works with a librad.Case that uses the \titleref{wavelength} option keyword. Cases that make use of
other methods to set the wavelength range will not work.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{n\_sub\_ranges}} -- Number of cases in the list, which is also the number of wavelength sub-ranges.

\item {} 
\textbf{\texttt{overlap}} -- Amount of wavelength overlap between subrange cases.

\end{itemize}

\item[{Returns}] \leavevmode
List of librad.Case

\end{description}\end{quote}


\strong{See also:}


merge\_caselist\_by\_wavelength



\end{fulllineitems}

\index{unset\_wavelength\_grid() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.unset_wavelength_grid}\pysiglinewithargsret{\bfcode{unset\_wavelength\_grid}}{}{}
Remove the wavelength grid file and associated grid data for this librad.Case.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (librad.Case method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.Case.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename='`}}{}
Write libRadtran/uvspec input to a file (.INP extension by default.
If the filename input is given as `', a file save dialog will be presented
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- Filename to which to write the uvspec input

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{HyperRadEnv (class in librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.HyperRadEnv}\pysiglinewithargsret{\strong{class }\code{librad.}\bfcode{HyperRadEnv}}{\emph{base\_case}, \emph{n\_pol}, \emph{n\_azi}, \emph{hyper\_axes}, \emph{mxumu=48}, \emph{mxphi=19}, \emph{hemi=False}, \emph{n\_sza=0}}{}
A higher dimensional form of radiant environment map REM. This class inherits from RadEnv.
A RadEnv instance has mandatory radiance data dimensions of propagation zenith angle (pza), propaation azimuth
angle (paz), wavelength, height above surface (zout) and stokes parameter. These are the outputs that can all
be obtained from a single run of libRadtran. The HyperRadEnv allows for increasing the dimensionality of the
REM dataset using other (typically scalar) inputs to libRadtran. Most significant amongst these are solar
zenith angle (sza), surface albedo (albedo) and surface temperature (sur\_temperature). Solar zenith angle and
albedo are only applicable in \titleref{source solar} runs, while sur\_temperature is only applicable in \titleref{source thermal}
REMs.

Other possible higher dimensions that can be added include:
Aerosol loading as specified by visibility or optical depth

Create a set of uvspec runs covering the whole sphere to calculate a full radiant environment map.
Where the base\_case is the uvspec case on which to base the environmental map, Name is the name to give the
environmental map and n\_pol and n\_azi are the number of polar and azimuthal sightline angles to generate. The
mxumu and mxphi are the maximum number of polar and azimuth angles to calculate in a single run of uvspec.
The default values are mxumu = 48, and mxphi = 19. These values are taken from the standard libRadtran
distribution (/libsrc\_f/DISORT.MXD) maximum parameter file. If using the polradtran solver, the corresponding
file is /libsrc\_f/POLRADTRAN.MXD. Other solvers may have different restrictions. A warning will be issued if
the solver is not in the DISORT/POLRADTRAN family.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base\_case}} -- 
librad.Case object providing the case on which the environment map is to be based. Note
that not any basecase can be used. As a general guideline, the basecase should have standard irradiance
outputs (i.e. should not use the \titleref{output\_user} keyword). It should also not the use \titleref{output\_process} or
\titleref{output\_quantity} keywords, which change the units and/or format of the libRadtran/uvspec output.
\begin{quote}

Minimal validation of the basecase is performed. However, use with \titleref{mol\_abs\_param} such as \titleref{kato} and
\titleref{fu} is important for \titleref{MORTICIA} and these are supported (k-distribution or \titleref{correlated-k}
parametrizations). Use of \titleref{output\_process per\_nm} is appropriate for \titleref{source thermal} REMs to get
radiance units per nanometre rather than per inverse cm.
\end{quote}


\item {} 
\textbf{\texttt{n\_pol}} -- Number of polar angles (view/propagation zenith angles)

\item {} 
\textbf{\texttt{n\_azi}} -- Number of azimuthal angles.

\item {} 
\textbf{\texttt{hyper\_axes}} -- Dictionary of libRadtran keywords, with a list (or numpy array) of values to assign  to
that keyword to create multiple copies of the REM e.g. \{`sza': {[}0.0 30.0 45.0{]}\} will create 3 runs of the
REM with these solar zenith angles. Note that the number of REMs goes up very rapidly. If 3 surface
albedo values as well as 3 solar zenith angles, the compute overhead goes up by a factor of 9.
In general, the keywords should have a scalar and numeric input (such as \titleref{albedo}, \titleref{sza} and
\titleref{sur\_temperature}). This input parameter is mandatory and there is no default.

\item {} 
\textbf{\texttt{mxumu}} -- Maximum number of polar angles per case.

\item {} 
\textbf{\texttt{mxphi}} -- Maximum number of azimuthal angles per case.

\item {} 
\textbf{\texttt{hemi}} -- If set True, will generate only a single hemisphere being on one side of
the solar principle plane. Default is False i.e. the environment map covers the full sphere.
Note that if hemi=True, the number of REM samples in azimuth becomes n\_azi \(\times\) 2.
This is the recommended mode (hemi=True) for MORTICIA purposes, since it reduces execution time.

\item {} 
\textbf{\texttt{n\_sza}} -- The number of solar zenith angles (SZA) at which to perform transmittance and path radiance
computations. Each SZA will result in another run of the base case (no radiances)

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (librad.HyperRadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.HyperRadEnv.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{base\_case}, \emph{n\_pol}, \emph{n\_azi}, \emph{hyper\_axes}, \emph{mxumu=48}, \emph{mxphi=19}, \emph{hemi=False}, \emph{n\_sza=0}}{}
Create a set of uvspec runs covering the whole sphere to calculate a full radiant environment map.
Where the base\_case is the uvspec case on which to base the environmental map, Name is the name to give the
environmental map and n\_pol and n\_azi are the number of polar and azimuthal sightline angles to generate. The
mxumu and mxphi are the maximum number of polar and azimuth angles to calculate in a single run of uvspec.
The default values are mxumu = 48, and mxphi = 19. These values are taken from the standard libRadtran
distribution (/libsrc\_f/DISORT.MXD) maximum parameter file. If using the polradtran solver, the corresponding
file is /libsrc\_f/POLRADTRAN.MXD. Other solvers may have different restrictions. A warning will be issued if
the solver is not in the DISORT/POLRADTRAN family.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base\_case}} -- 
librad.Case object providing the case on which the environment map is to be based. Note
that not any basecase can be used. As a general guideline, the basecase should have standard irradiance
outputs (i.e. should not use the \titleref{output\_user} keyword). It should also not the use \titleref{output\_process} or
\titleref{output\_quantity} keywords, which change the units and/or format of the libRadtran/uvspec output.
\begin{quote}

Minimal validation of the basecase is performed. However, use with \titleref{mol\_abs\_param} such as \titleref{kato} and
\titleref{fu} is important for \titleref{MORTICIA} and these are supported (k-distribution or \titleref{correlated-k}
parametrizations). Use of \titleref{output\_process per\_nm} is appropriate for \titleref{source thermal} REMs to get
radiance units per nanometre rather than per inverse cm.
\end{quote}


\item {} 
\textbf{\texttt{n\_pol}} -- Number of polar angles (view/propagation zenith angles)

\item {} 
\textbf{\texttt{n\_azi}} -- Number of azimuthal angles.

\item {} 
\textbf{\texttt{hyper\_axes}} -- Dictionary of libRadtran keywords, with a list (or numpy array) of values to assign  to
that keyword to create multiple copies of the REM e.g. \{`sza': {[}0.0 30.0 45.0{]}\} will create 3 runs of the
REM with these solar zenith angles. Note that the number of REMs goes up very rapidly. If 3 surface
albedo values as well as 3 solar zenith angles, the compute overhead goes up by a factor of 9.
In general, the keywords should have a scalar and numeric input (such as \titleref{albedo}, \titleref{sza} and
\titleref{sur\_temperature}). This input parameter is mandatory and there is no default.

\item {} 
\textbf{\texttt{mxumu}} -- Maximum number of polar angles per case.

\item {} 
\textbf{\texttt{mxphi}} -- Maximum number of azimuthal angles per case.

\item {} 
\textbf{\texttt{hemi}} -- If set True, will generate only a single hemisphere being on one side of
the solar principle plane. Default is False i.e. the environment map covers the full sphere.
Note that if hemi=True, the number of REM samples in azimuth becomes n\_azi \(\times\) 2.
This is the recommended mode (hemi=True) for MORTICIA purposes, since it reduces execution time.

\item {} 
\textbf{\texttt{n\_sza}} -- The number of solar zenith angles (SZA) at which to perform transmittance and path radiance
computations. Each SZA will result in another run of the base case (no radiances)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RadEnv (class in librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv}\pysiglinewithargsret{\strong{class }\code{librad.}\bfcode{RadEnv}}{\emph{base\_case}, \emph{n\_pol}, \emph{n\_azi}, \emph{mxumu=48}, \emph{mxphi=19}, \emph{hemi=False}, \emph{n\_sza=0}}{}
RadEnv is a class to encapsulate a large number of uvspec runs to cover a large number of sightlines over the
whole sphere. A radiance map over the complete sphere is called a radiant environment map. The uvspec utility can
only handle a limited number of sighlines per run, determined by the maximum number of polar and azimuthal angles
specified in the file /libsrc\_f/DISORT.MXD. If these values are changed, DISORT and uvspec must be recompiled. If
the values are set too large, the memory requirements could easily exceed your computer's limit (there is
currently no dynamic memory allocation in DISORT). The situation for the cdisort solver is less clear.

\begin{notice}{note}{Note:}
The \titleref{polradtran} radiative transfer (RT) solver does not produce direct irradiance outputs (\titleref{edir}),
This presents a problem for calculation of path transmission (optical depth) between output atmospheric
levels (e.g. as specified by the uvspec \titleref{zout} keyword). This solver only produces total fluxes (irradiances)
for each of desired stokes parameters. Hence for calculation of polarised radiant environment maps (REMs), the only
feasible option for \titleref{MORTICIA} is to use the \titleref{mystic} solver with the \titleref{mc\_polarisation} option. Currently,
the librad.Case uvspec output file reading functions do not cater for \titleref{mystic}.
\end{notice}

Create a set of uvspec runs covering the whole sphere to calculate a full radiant environment map.
Where the base\_case is the uvspec case on which to base the environmental map, Name is the name to give the
environmental map and n\_pol and n\_azi are the number of polar and azimuthal sightline angles to generate. The
mxumu and mxphi are the maximum number of polar and azimuth angles to calculate in a single run of uvspec.
The default values are mxumu = 48, and mxphi = 19. These values are taken from the standard libRadtran
distribution (/libsrc\_f/DISORT.MXD) maximum parameter file. If using the polradtran solver, the corresponding
file is /libsrc\_f/POLRADTRAN.MXD. Other solvers may have different restrictions. A warning will be issued if
the solver is not in the DISORT/POLRADTRAN family.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base\_case}} -- 
librad.Case object providing the case on which the environment map is to be based. Note
that not any basecase can be used. As a general guideline, the basecase should have standard irradiance
outputs (i.e. should not use the \titleref{output\_user} keyword). It should also not the use \titleref{output\_process} or
\titleref{output\_quantity} keywords, which change the units and/or format of the libRadtran/uvspec output.
\begin{quote}

Minimal validation of the basecase is performed. However, use with \titleref{mol\_abs\_param} such as \titleref{kato} and
\titleref{fu} is important for \titleref{MORTICIA} and these are supported (k-distribution or \titleref{correlated-k}
parametrizations). Use of \titleref{output\_process per\_nm} is appropriate for \titleref{source thermal} REMs to get
radiance units per nanometre rather than per inverse cm.
\end{quote}


\item {} 
\textbf{\texttt{n\_pol}} -- Number of polar angles (view/propagation zenith angles)

\item {} 
\textbf{\texttt{n\_azi}} -- Number of azimuthal angles.

\item {} 
\textbf{\texttt{mxumu}} -- Maximum number of polar angles per case.

\item {} 
\textbf{\texttt{mxphi}} -- Maximum number of azimuthal angles per case.

\item {} 
\textbf{\texttt{hemi}} -- If set True, will generate only a single hemisphere being on one side of
the solar principle plane. Default is False i.e. the environment map covers the full sphere.
Note that if hemi=True, the number of REM samples in azimuth becomes n\_azi \(\times\) 2.
This is the recommended mode (hemi=True) for MORTICIA purposes, since it reduces execution time.

\item {} 
\textbf{\texttt{n\_sza}} -- The number of solar zenith angles (SZA) at which to perform transmittance and path radiance
computations. Each SZA will result in another run of the base case (no radiances)

\end{itemize}

\end{description}\end{quote}

The solver cdisort may have dynamic memory allocation, so the warning is still issued because the situation
is less clear.

A note about radiative propagation angles and viewing angles, which are 180 deg opposite to each other.
For radiance calculations define the cosine of the viewing zenith angle
\titleref{umu} and the sensor azimuth \titleref{phi} and don't forget to also specify the solar azimuth
\titleref{phi0}. \titleref{umu} \textgreater{} 0 means sensor looking downward (e.g. a satellite), \titleref{umu} \textless{} 0 means looking
upward. \titleref{phi} = \titleref{phi0} indicates that the sensor looks into the direction of the sun,
\titleref{phi} - \titleref{phi0} = 180 means that the sun is in the back of the sensor.

\titleref{phi} is the propagation azimuth angle \titleref{paz}, except that \titleref{paz} is in radians and \titleref{phi} is in degrees.

\titleref{pza} is the propagation zenith angle in radians.

\titleref{vaz} is the view azimuth angle and is 180 \(^\circ\) different from \titleref{paz}. \titleref{vaz} is expressed
in degrees. \titleref{vza}, the view zenith angle is 180 \(^\circ\) different from \titleref{paz' and is expressed
in degrees. In order to keep all azimuth angles in increasing order, `vaz' is in the range {[}-180, 180{]},
while {}`phi} is in the range {[}0, 360{]} and \titleref{vaz} = \titleref{phi} - 180.

The value of \titleref{umu} is the cosine of the propagation zenith angle. The value of \titleref{phi} is the true azimuth of
the propagation direction.

For all one-dimensional solvers the absolute azimuth does not matter, but only the relative azimuth
\titleref{phi} - \titleref{phi0}.

For \titleref{MORTICIA} work, it is strongly recommended that the \titleref{hemi} flag be set True. This will automatically
set the \titleref{phi0} keyword to zero in the RadEnv cases when running uvspec. This will essentially halve the
execution time for radiant environment maps of the same effective spatial resolution.
\index{\_\_init\_\_() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{base\_case}, \emph{n\_pol}, \emph{n\_azi}, \emph{mxumu=48}, \emph{mxphi=19}, \emph{hemi=False}, \emph{n\_sza=0}}{}
Create a set of uvspec runs covering the whole sphere to calculate a full radiant environment map.
Where the base\_case is the uvspec case on which to base the environmental map, Name is the name to give the
environmental map and n\_pol and n\_azi are the number of polar and azimuthal sightline angles to generate. The
mxumu and mxphi are the maximum number of polar and azimuth angles to calculate in a single run of uvspec.
The default values are mxumu = 48, and mxphi = 19. These values are taken from the standard libRadtran
distribution (/libsrc\_f/DISORT.MXD) maximum parameter file. If using the polradtran solver, the corresponding
file is /libsrc\_f/POLRADTRAN.MXD. Other solvers may have different restrictions. A warning will be issued if
the solver is not in the DISORT/POLRADTRAN family.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base\_case}} -- 
librad.Case object providing the case on which the environment map is to be based. Note
that not any basecase can be used. As a general guideline, the basecase should have standard irradiance
outputs (i.e. should not use the \titleref{output\_user} keyword). It should also not the use \titleref{output\_process} or
\titleref{output\_quantity} keywords, which change the units and/or format of the libRadtran/uvspec output.
\begin{quote}

Minimal validation of the basecase is performed. However, use with \titleref{mol\_abs\_param} such as \titleref{kato} and
\titleref{fu} is important for \titleref{MORTICIA} and these are supported (k-distribution or \titleref{correlated-k}
parametrizations). Use of \titleref{output\_process per\_nm} is appropriate for \titleref{source thermal} REMs to get
radiance units per nanometre rather than per inverse cm.
\end{quote}


\item {} 
\textbf{\texttt{n\_pol}} -- Number of polar angles (view/propagation zenith angles)

\item {} 
\textbf{\texttt{n\_azi}} -- Number of azimuthal angles.

\item {} 
\textbf{\texttt{mxumu}} -- Maximum number of polar angles per case.

\item {} 
\textbf{\texttt{mxphi}} -- Maximum number of azimuthal angles per case.

\item {} 
\textbf{\texttt{hemi}} -- If set True, will generate only a single hemisphere being on one side of
the solar principle plane. Default is False i.e. the environment map covers the full sphere.
Note that if hemi=True, the number of REM samples in azimuth becomes n\_azi \(\times\) 2.
This is the recommended mode (hemi=True) for MORTICIA purposes, since it reduces execution time.

\item {} 
\textbf{\texttt{n\_sza}} -- The number of solar zenith angles (SZA) at which to perform transmittance and path radiance
computations. Each SZA will result in another run of the base case (no radiances)

\end{itemize}

\end{description}\end{quote}

The solver cdisort may have dynamic memory allocation, so the warning is still issued because the situation
is less clear.

A note about radiative propagation angles and viewing angles, which are 180 deg opposite to each other.
For radiance calculations define the cosine of the viewing zenith angle
\titleref{umu} and the sensor azimuth \titleref{phi} and don't forget to also specify the solar azimuth
\titleref{phi0}. \titleref{umu} \textgreater{} 0 means sensor looking downward (e.g. a satellite), \titleref{umu} \textless{} 0 means looking
upward. \titleref{phi} = \titleref{phi0} indicates that the sensor looks into the direction of the sun,
\titleref{phi} - \titleref{phi0} = 180 means that the sun is in the back of the sensor.

\titleref{phi} is the propagation azimuth angle \titleref{paz}, except that \titleref{paz} is in radians and \titleref{phi} is in degrees.

\titleref{pza} is the propagation zenith angle in radians.

\titleref{vaz} is the view azimuth angle and is 180 \(^\circ\) different from \titleref{paz}. \titleref{vaz} is expressed
in degrees. \titleref{vza}, the view zenith angle is 180 \(^\circ\) different from \titleref{paz' and is expressed
in degrees. In order to keep all azimuth angles in increasing order, `vaz' is in the range {[}-180, 180{]},
while {}`phi} is in the range {[}0, 360{]} and \titleref{vaz} = \titleref{phi} - 180.

The value of \titleref{umu} is the cosine of the propagation zenith angle. The value of \titleref{phi} is the true azimuth of
the propagation direction.

For all one-dimensional solvers the absolute azimuth does not matter, but only the relative azimuth
\titleref{phi} - \titleref{phi0}.

For \titleref{MORTICIA} work, it is strongly recommended that the \titleref{hemi} flag be set True. This will automatically
set the \titleref{phi0} keyword to zero in the RadEnv cases when running uvspec. This will essentially halve the
execution time for radiant environment maps of the same effective spatial resolution.

\end{fulllineitems}

\index{compute\_path\_radiance() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.compute_path_radiance}\pysiglinewithargsret{\bfcode{compute\_path\_radiance}}{}{}
Compute path radiances for path segments between all altitudes in the REM.
The path transmittances (optical depth) as well as the total radiances at each altitude are required to
calculate path radiances. If \(L_{pi}^{\downarrow}\) is the downwelling path radiance at level \(i\)
originating between level \(i\) and level \(i+1\) and \(L_{pi}^{\uparrow}\) is the upwelling
path radiance at level \(i\) originating between level \(i\) and level \(i-1\), then
\begin{align*}\begin{aligned}
\begin{split}L_{pi}^{\downarrow}=L_{i}^{\downarrow}-L_{i+1}^{\downarrow}\tau_{i+1}^{\downarrow},\end{split}\end{aligned}\end{align*}
and
\begin{align*}\begin{aligned}
\begin{split}L_{pi}^{\uparrow}=L_{i}^{\uparrow}-L_{i-1}^{\uparrow}\tau_{i-1}^{\uparrow}.\end{split}\end{aligned}\end{align*}
\(L_{i}^{\uparrow}\) is the lower hemisphere (upwelling hemisphere) of the REM and
\(\tau_{i}^{\uparrow}\) is the transmission between level \(i\) and level \(i+1\).


\strong{See also:}


RadEnv.compute\_path\_transmittance()


\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_path\_transmittance() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.compute_path_transmittance}\pysiglinewithargsret{\bfcode{compute\_path\_transmittance}}{}{}
Compute path transmittances from the set of libRadtran/uvspec runs executed for solar zenith angles
of 0 to near 90 degrees.

This method computes optical depth (-log(transmittance)) of all paths from a particular level, both
upward and downward. Paths that lie in the horizontal ``blind zone'' are assigned OD of 0.0. These should
actually be assigned OD of np.nan or perhaps np.inf.


\strong{See also:}


RadEnv.setup\_trans\_cases()


\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_ipyparallel() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.run_ipyparallel}\pysiglinewithargsret{\bfcode{run\_ipyparallel}}{\emph{ipyparallel\_view}, \emph{stderr\_to\_file=False}, \emph{purge=False}}{}
Run a complete set of radiant environment map cases of libRadtran/uvspec using the \titleref{ipyparallel}
Python package, which provides parallel computation from Jupyter notebooks and other Python launch
modes.
Typical code for setting up the view:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipyparallel} \PYG{k+kn}{import} \PYG{n}{Client}
\PYG{n}{paraclient} \PYG{o}{=} \PYG{n}{Client}\PYG{p}{(}\PYG{n}{profile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mycluster}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sshserver}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{me@mycluster.info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mypassword}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{paraclient}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{use\PYGZus{}dill}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Need dill as a pickle replacement for our purposes here}
\PYG{n}{ipyparallel\PYGZus{}view} \PYG{o}{=} \PYG{n}{paraclient}\PYG{o}{.}\PYG{n}{load\PYGZus{}balanced\PYGZus{}view}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ipyparallel\PYGZus{}view}\PYG{o}{.}\PYG{n}{block} \PYG{o}{=} \PYG{n+nb+bp}{True}  \PYG{c+c1}{\PYGZsh{} Must wait for completion of all tasks on the cluster}
\end{Verbatim}
\end{quote}

Note that if new ipengines are started, use\_dill() must be executed again. The use\_dill() call
should be a routine before every function map to the cluster.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ipyparallel\_view}} -- an ipyparallel view of a Python engine cluster (see ipyparallel documentation.)

\item {} 
\textbf{\texttt{stderr\_to\_file}} -- If set to True, standard error output will be sent to a file. use only for debugging
purposes.

\item {} 
\textbf{\texttt{purge}} -- Boolean. If set True, the actual libRadtran cases that are executed to make up the REM are
deleted in order to reduce the size of the object. If the object is purged, it is not possible to rerun
the REM. Default is False - no purging (or minimal purging) is performed.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{run\_parallel() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.run_parallel}\pysiglinewithargsret{\bfcode{run\_parallel}}{\emph{n\_nodes=4}}{}
Run the RadEnv in multiprocessing mode on the local host.

This is not yet tested, but should work with the multiprocessing package on the local host to use all
the available cores. Will only work if libRadtran is installed on the local host.

In order to use dill instead of pickle, it is necessary to use the pathos multiprocessing module
instead of the standard multiprocessing module
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{n\_nodes}} -- Number of compute nodes to use. Default is 4. Preferably set to number of cores you have
available on the local host.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{setup\_trans\_cases() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.setup_trans_cases}\pysiglinewithargsret{\bfcode{setup\_trans\_cases}}{\emph{n\_sza=32}}{}
Setup a list of cases for computing the transmission matrices between every level defined in the
REM (and at every wavelength and stokes parameter combination). The computation of  transmittance between
levels is accomplished in \titleref{MORTICIA} using libRadtran/uvspec by computing the direct solar irradiance
transmittance for multiple zenith angles.

Note that if there is an optically thick cloud layer between two levels in the REM, the transmittance
will compute as zero or very small. This will also result in the incorrect/noisy computation of path
radiances between the two levels. This situation is unavoidable. The recommended approach is that
REMS be computed with altitude levels that all lie between cloud layers (i.e. no levels in the REM
span a cloud layer). The user, or the code which uses the REMs should see to this. Essentially it must
be recognised that optical surveillance is not possible through optically thick cloud layers.

The REM is provided with a cloud flag that indicates if the base case incorporates clouds. The approach to
computing inter-level transmittance (optical depth is the stored parameter, since this scales more
closely in a linear fashion with distance) in the presence of cloud is to vary the `cloudcover'
keyword parameter (water and ice clouds independently). This is done for solar zenith angle of zero.
The optical thickness from TOA to the level in question is then computed as a function of cloud cover
fraction (CCF). The optical depth between levels (i.e the optical depth of a layer between two levels)
is computed as the difference in optical depth to TOA of the lower level minus the optical depth to TOA
of the upper level. If there is no difference in the layer optical depth when the CCF is varied from
zero to some positive value (say 0.1, but not as high as 1), then the layer is free of cloud.

A flag per layer is thus obtained which indicates if the layer contains cloud. If it does, the transmittance
will compute as zero between the two levels in question. This means that the cloud base is not resolved
to better than the level resolution in the REM. It is probably then quite important to ensure that
cloud base altitude statistics are available in the theatre climatology.

An upgrade to cloud handling could be to read the cloud profile files in order to obtain the exact vertical
location of the cloud layers.

Another inherent and unavoidable problem with computation of path optical depths and radiances using
libRadtran/uvspec is that precisely horizontal paths cannot be dealt with using one-dimensional RT
solvers. Therefore in this case, the maximum range that can be dealt with depends on the height difference
between the REM levels and the maximum solar zenith angle (SZA) used for computation of optical depth.

A further implication of the above point is that path transmittances and path radiances cannot be interpolated
between the SZA nearest the horizon and the horizon proper. Some form of logarithmic extrapolation could be
performed, but could result in large errors due to failure of Beer's Law and other problems.

Execution and attribution of transmittance cases will provide each level with transmittance to the level
above that altitude level. Therefore the topmost level will have transmittances to TOA, but the
bottom level will not have transmittances (optical depths) to BOA, unless the bottom level \emph{is} BOA.
It is recommended that all MORTICIA base cases for REM include BOA as an output level.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{n\_sza}} -- The number of solar zenith angles at which to compute path optical depth and radiances.
the SZA values are computed equi-spaced in the cosine of the solar zenith angle rather that the
SZA itself. This is to help with the problem that the slant range between levels increases
in linear relation to the secant of the view zenith angle. The optical depths are later
interpolated to the same

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{sph\_harm\_fat() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.sph_harm_fat}\pysiglinewithargsret{\bfcode{sph\_harm\_fat}}{\emph{degree}}{}
This code was used for debugging purposes - ignore
:param degree:
:return:

\end{fulllineitems}

\index{sph\_harm\_fit() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.sph_harm_fit}\pysiglinewithargsret{\bfcode{sph\_harm\_fit}}{\emph{degree}, \emph{method='trapz'}}{}
Fit spherical harmonics to the radiant environment map (REM).
One set of coefficients per wavelength or spectral channel will be fitted. The coefficients for each spectral
bin/channel comprise one coefficient for order \(-m\) to \(+m\) for \(m = 0, 1, 2, ..., n\).
The total number of coefficients is \((n+1)^2\).

The convention used for the spherical harmonics is that of Sloan with the Ramamoorthi and Hanrahan
normalization. This is a real-valued basis defined as follows:
\begin{align*}\begin{aligned}
\begin{split}y_{n}^{m}=\begin{cases}
(-1)^{m}\sqrt{2}\Re(Y_{n}^{m}) & m>0\\
(-1)^{m}\sqrt{2}\Im(Y_{n}^{m}) & m<0\\
Y_{n}^{0} & m=0
\end{cases}=\begin{cases}
(-1)^{m}\sqrt{2}\cos m\phi\,P_{n}^{m}(\cos\theta) & m>0\\
(-1)^{m}\sqrt{2}\sin|m|\phi\,P_{n}^{|m|}(\cos\theta) & m<0\\
K_{n}^{0}P_{n}^{0}(\cos\theta) & m=0
\end{cases},\end{split}\end{aligned}\end{align*}
where the complex basis functions \(Y^{m}_{n}\) are defined as:
\begin{align*}\begin{aligned}
\begin{split}Y_{n}^{m}(\theta,\phi)=K_{n}^{m}e^{im\phi}P_{n}^{|m|}(\cos\theta),\,n\in\mathbf{N},\,-n\leq m\leq n,\end{split}\end{aligned}\end{align*}
having the normalisation factor of:
\begin{align*}\begin{aligned}
\begin{split}K_{n}^{m}=\sqrt{\frac{(2n+1)(n-|m|)!}{4\pi(n+|m|)!}}.\end{split}\end{aligned}\end{align*}
The definition of the complex basis functions is consistent with the
\href{http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.special.sph\_harm.html}{scipy.special}
definition of the spherical harmonics. Therefore, for fitting of the Sloan/Ramamoorthi/Hanrahan basis, the
first definition is used above, that is \(y_{n}^{m}\) can be calculated from the \titleref{scipy.special} function
\(Y_{n}^{m}\) as:
\begin{align*}\begin{aligned}
\begin{split}y_{n}^{m}=\begin{cases}
(-1)^{m}\sqrt{2}\Re(Y_{n}^{m}) & m>0\\
(-1)^{m}\sqrt{2}\Im(Y_{n}^{m}) & m<0\\
Y_{n}^{0} & m=0
\end{cases}.\end{split}\end{aligned}\end{align*}
The fitted coefficients of the spherical harmonics are computed by multiplying the REM by each of the
harmonics and performing double numerical integration over zenith and azimuth angle as:
\begin{align*}\begin{aligned}
\begin{split}L_{n}^{m}=\int_{\theta=0}^{\pi}\int_{\phi=0}^{2\pi}L(\theta,\phi)y_{n}^{m}(\theta,\phi)\sin\theta d\theta d\phi,\end{split}\end{aligned}\end{align*}
where \(L_{n}^{m}\) are the coefficients and \(L(\theta,\phi)\) is the REM.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{degree}} -- Spherical harmonics up to this degree \(n\), for all orders \(m\) will be fitted.

\item {} 
\textbf{\texttt{method}} -- Integration method by which the coefficients are computed. `trapz' for trapezoidal integration,
`sum' for simple summation and `simpson' for Simpson's Rule. The `trapz' method seems to be
considerably more accurate than `sum' or `simpson'. Therefore `trapz' is the default.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{write\_openexr() (librad.RadEnv method)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.RadEnv.write_openexr}\pysiglinewithargsret{\bfcode{write\_openexr}}{\emph{filename}, \emph{chan\_names=None}, \emph{chan\_per\_exr=3}, \emph{normalise=False}, \emph{half=False}, \emph{repeat\_azi=1}, \emph{use\_mitsuba\_wvl=False}}{}
Write a radiant environment as an OpenEXR file or set of OpenEXR files.

Use of this method requires that the OpenEXR package be installed on your platform. This can be a problem
for Windows. However, it should be possible to find a Python wheel (.whl) file for Windows which will
enable installation if pip cannot do the job.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- Name of the file to which the OpenEXR environment map should be written. If multiple exr
files are written, this will be the filename prefix. No default.

\item {} 
\textbf{\texttt{chan\_names}} -- String or list of strings giving the names to be used for the channels. For example
give `RGB' if channels `R', `G' and `B' if RGB files are to be written. This is the same as giving
{[}'R', `G', `B'{]}. If there are insufficient channel names for all the wavelengths, the names are
reused.

\item {} 
\textbf{\texttt{chan\_per\_exr}} -- Number of spectral channels to write per exr file. Default is 3.

\item {} 
\textbf{\texttt{normalise}} -- Boolean. Normalise all channels to the maximum value (in any one file). Default False.
Normalisation will make ti possible to display the .exr file in IrfanView or mtsgui (Mitsuba GUI), but
will destroy the radiometric correctness.

\item {} 
\textbf{\texttt{half}} -- Boolean. Use float16 instead of default float32. Halves data size at cost of radiometric
resolution.

\item {} 
\textbf{\texttt{repeat\_azi}} -- Integer. Repeat the data in the REM azimuthal direction. This is mostly a convenience for
display purposes when the REM has no azimuthal variation (e.g. in the thermal bands).

\item {} 
\textbf{\texttt{use\_mitsuba\_wvl}} -- Boolean. If set True, write channels using the Mitsuba wavelength assignments i.e.
remap wavelengths to the 360 nm to 830 nm range. Setting this flag True will also scale the radiance
values to W/m\textasciicircum{}2/sr/nm, which are the canonical units for Mitsuba rendering in the context of MORTICIA.

\end{itemize}

\end{description}\end{quote}

Polarization is not dealt with. Only the first Stokes component (I) is written to the EXR files.
The number of channel names should be equal to the number of channels per EXR file, but this is not
enforced.
Irfanview can display three-component, normalised EXR files only. The Mitsuba GUI (mtsgui) can display
EXR files with any number of channels, but it is necessary to step through the channels (using {[} and {]})
and they are displayed in grayscale. Even mtsgui will clip EXR files having radiance values exceeding 1.0.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{angstrom\_law() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.angstrom_law}\pysiglinewithargsret{\code{librad.}\bfcode{angstrom\_law}}{\emph{wavelength}, \emph{alpha}, \emph{beta}}{}
Calculation of aerosol optical thickness according to the Angstrom law.
The Angstrom law is a simple power law that typifies aerosol optical thickness (aka optical depth) variation
with wavelength. The Angstrom law is expressed as
.. math:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZbs{}\PYG{n}{tau\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{aer}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYGZbs{}\PYG{n}{beta}\PYGZbs{}\PYG{k}{lambda}\PYG{o}{\PYGZca{}}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYGZbs{}\PYG{n}{alpha}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The Angstrom law can be used to set aerosol optical thickness in libRadtran/uvspec using the \titleref{aerosol\_angstrom}
keyword.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{wavelength}} -- Wavelength(s) at which to compute the aerosol optical thickness. If any of the wavelengths
are greater than 100, then wavelengths are assumed to be in nm, otherwise wavelengths are assumed to be in
microns.

\item {} 
\textbf{\texttt{alpha}} -- The Angstrom alpha exponent.

\item {} 
\textbf{\texttt{beta}} -- The Angstrom beta (aerosol optical thickness at a wavelength of 1000 nm) parameter

\end{itemize}

\item[{Returns}] \leavevmode
Aerosol optical thickness at given wavelengths with Angstrom alpha and beta parameters as provided.

\end{description}\end{quote}


\strong{See also:}


librad.angstrom\_law\_fit, the libRadtran manual



\end{fulllineitems}

\index{angstrom\_law\_fit() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.angstrom_law_fit}\pysiglinewithargsret{\code{librad.}\bfcode{angstrom\_law\_fit}}{\emph{wavelength}, \emph{aot}}{}
Uses scipy.optimize to fit the Angstrom power law to an array of aerosol optical thickness values given
at an array of wavelengths.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{wavelength}} -- Wavelengths at which the aerosol optical thickness (aka optical depth) is provided in the aot
input. If any of the wavelengths is larger than 100, then wavelengths are assumed to be in nm, otherwise
wavelengths are assumed to be in microns.

\item {} 
\textbf{\texttt{aot}} -- Aerosol optical thickness at the given wavelengths

\end{itemize}

\item[{Returns}] \leavevmode
Angstrom alpha and beta parameters that best fit the input AOT data in the least squares sense.

\end{description}\end{quote}


\strong{See also:}


librad.angstrom\_law



\end{fulllineitems}

\index{king\_byrne\_formula() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.king_byrne_formula}\pysiglinewithargsret{\code{librad.}\bfcode{king\_byrne\_formula}}{\emph{wavelength}, \emph{alpha\_0}, \emph{alpha\_1}, \emph{alpha\_2}}{}
The King Byrne formula for aerosol optical depth variation with wavelength.
The King Byrne formula is
\begin{align*}\begin{aligned}
\begin{split}\tau_{aer}=e^{\alpha_{0}}\lambda^{\alpha_{1}}\lambda^{-\alpha_{2}}\end{split}\end{aligned}\end{align*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{wavelength}} -- Wavelengths at which the aerosol optical thickness (aka optical depth) is provided in the aot
input. If any of the wavelengths is larger than 100, then wavelengths are assumed to be in nm, otherwise
wavelengths are assumed to be in microns.

\item {} 
\textbf{\texttt{alpha\_0}} -- The \(\alpha_0\) parameter

\item {} 
\textbf{\texttt{alpha\_1}} -- The \(\alpha_1\) parameter

\item {} 
\textbf{\texttt{alpha\_2}} -- The \(\alpha_2\) parameter

\end{itemize}

\item[{Returns}] \leavevmode
Aerosol optical thickness at given wavelengths calculated with the King Byrne formula

\end{description}\end{quote}

\end{fulllineitems}

\index{king\_byrne\_formula\_fit() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.king_byrne_formula_fit}\pysiglinewithargsret{\code{librad.}\bfcode{king\_byrne\_formula\_fit}}{\emph{wavelength}, \emph{aot}}{}
Uses scipy.optimize to fit the King Byrne formula to an array of aerosol optical thickness values
provided at the given wavelengths
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{wavelength}} -- Wavelengths at which the aerosol optical thickness (aka optical depth) is provided in the aot
input. If any of the wavelengths is larger than 100, then wavelengths are assumed to be in nm, otherwise
wavelengths are assumed to be in microns.

\item {} 
\textbf{\texttt{aot}} -- Aerosol optical thickness at the given wavelengths

\end{itemize}

\item[{Returns}] \leavevmode
The \(\alpha_0\), \(\alpha_1\) and \(\alpha_2\)

\end{description}\end{quote}

\end{fulllineitems}

\index{koschmieder\_vis() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.koschmieder_vis}\pysiglinewithargsret{\code{librad.}\bfcode{koschmieder\_vis}}{\emph{ext\_550=None}, \emph{aot\_550=None}, \emph{scale\_height=None}, \emph{rayleigh\_ext=0.01159}}{}~\begin{description}
\item[{Compute visibility in km using the Koschmieder relationship}] \leavevmode\begin{align*}\begin{aligned}
\begin{split}V_K = \frac{\ln 50}{\epsilon_{aer} + \epsilon_{ray}}\end{split}\end{aligned}\end{align*}
Or,
\begin{align*}\begin{aligned}
\begin{split}V_K = \frac{\ln 50}{\tau_{aer}/ H + \epsilon_{ray}}\end{split}\end{aligned}\end{align*}
where \(V_K\) is the visibility in km, \(\epsilon_{aer}\) is the aerosol extinction coefficient at
550 nm in units of inverse km, \(\tau_{aer}\) is the vertical aerosol optical depth at 550 nm,
and \(\epsilon_{aer}\) is the Rayleigh extinction coefficient, in units of inverse km.

\(H\) is the scale height or effective mixing layer height assuming that all aerosols are in the mixing
layer. The boundary layer height is usually a good approximation.

\end{description}

Provide either \code{ext\_550} OR \code{aot\_550} together with \code{scale\_height}.
The Rayleigh extinction coefficient is optional.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ext\_550}} -- aerosol extinction coefficient \(\tau_{aer}\) at 550nm in units of inverse km

\item {} 
\textbf{\texttt{aot\_550}} -- vertical aerosol optical thickness

\item {} 
\textbf{\texttt{scale\_height}} -- effective boundary layer height (ABL/mixing height if all aerosols in the mixing layer) in km

\item {} 
\textbf{\texttt{rayleigh\_ext}} -- Rayleigh extinction coefficient, defaults to 0.01159 per km.

\end{itemize}

\item[{Returns}] \leavevmode
Visibility in km according to the Koschmieder relationship

\end{description}\end{quote}

The relationship used here is taken from the MODTRAN manual.

\end{fulllineitems}

\index{lookup\_nearest\_in\_file() (in module librad)}

\begin{fulllineitems}
\phantomsection\label{packages:librad.lookup_nearest_in_file}\pysiglinewithargsret{\code{librad.}\bfcode{lookup\_nearest\_in\_file}}{\emph{filename}, \emph{values\_and\_offsets}, \emph{column\_number=0}}{}
Look up the nearest value in a free form text file of numeric data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- File in which to look up the values

\item {} 
\textbf{\texttt{column\_number}} -- Column number in which to search, starting from 0 - the default is 0

\item {} 
\textbf{\texttt{values\_and\_offsets}} -- An array with the values to search for (nominal values) in the first column and the
minimum offsets to allow from the nominal values. Negative offsets will return the largest value which is
less than the nominal value by at least the absolute value of the offset. Postitive offsets will return the
value which is greater than the nominal value by at least the absolute offset value.

\end{itemize}

\item[{Returns}] \leavevmode
List of lookup values which are nearest to the nominal values by at least the offset values.

\end{description}\end{quote}

In the tradition of libRadtran data files, lines starting with \# are considered to be comments.
The data in the column is assumed to be in monotonic, increasing order.
Very large files should probably not be the subject of this function.

The following excample will fetch the Thuillier solar spectrum wavelengths that span the range of
385 nm to 955 nm with a margin of 2 nm on either side. This is useful when setting the uspec `wavelength'
keyword, which must give wavelengths that are actually listed in the source solar sepctrum file.
\textgreater{}\textgreater{}\textgreater{} import morticia.rad.librad as librad
\textgreater{}\textgreater{}\textgreater{} wavelengths  = librad.lookup\_nearest\_in\_file(`data/Solar\_irradiance\_Thuillier\_2002.txt', {[}{[}385.0, -2.0{]}, {[}955, 2.0{]}{]})

\end{fulllineitems}



\subsection{Radiometric Utilities Module}
\label{packages:radiometric-utilities-module}
The radiometric utilitties module, \titleref{radute} contains utility code for handling of radiometric quantities. This
includes a class \titleref{Flt} for reading, writing, creating and plotting of MODTRAN-style .flt (spectral response/filter
function) files.
\phantomsection\label{packages:module-radute}\index{radute (module)}\index{Flt (class in radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt}\pysiglinewithargsret{\strong{class }\code{radute.}\bfcode{Flt}}{\emph{name, units='nm', filterheaders={[}{]}, filters={[}{]}, centers={[}{]}, fwhms={[}{]}, shapes={[}'gauss'{]}, yedges={[}0.001{]}, centerflats={[}0.0{]}, peakvals={[}1.0{]}, wvmins={[}{]}, wvmaxs={[}{]}, oobs={[}4.9406564584124654e-324{]}}}{}
Encapsulates a MODTRAN-style .flt spectral response function/filter function definition file.

Create a filter definition object (MODTRAN flt style)
Input name is mandatory. All other inputs are optional, but the filterheaders list must have the same number of
string elements as the number of filters. Also, either the filters are given explicitly in the filters input, or
a list of filter definitions are provided for use with rad.srfgen().
If not empty, inputs centers through to oobs must be either scalar or have the same number of list elements as
the filterheaders list. If scalar, the value will be replicated up to the number of filterheader values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Name of the set of filters. If the filterheaders input to this constructor function
is empty, an attempt will be made to read the data from a file called name + `.flt'

\item {} 
\textbf{\texttt{units}} -- Spectral coordinate units for the filter, `nm', `um' or `cm\textasciicircum{}-1'

\item {} 
\textbf{\texttt{filterheaders}} -- List of strings, one header for each filter/SRF in the set.

\item {} 
\textbf{\texttt{filters}} -- A list of numpy arrays. Each list element must comprise a 2-column numpy array with the
spectral coordinate (wavelength in nm or micron or wavenumber per cm) in the first column and the filter
magnitude in the second column.

\item {} 
\textbf{\texttt{centres}} -- rather than provide filters, the inputs to rad.srfgen can be provided, this is a list of center
wavelengths in nm

\item {} 
\textbf{\texttt{fwhms}} -- list of full width at half maximum in nm

\item {} 
\textbf{\texttt{shapes}} -- list of strings providing the shapes of the filters (see rad.srfgen for alternatives)

\item {} 
\textbf{\texttt{yedges}} -- list of yedge values (see rad.srfgen)

\item {} 
\textbf{\texttt{centerflats}} -- list of centerflat values (see rad.srfgen). Note that giving a centerflat value adds this
amount ot the fwhm of the filters (broadens the resulting width to centerflat + fwhm)

\item {} 
\textbf{\texttt{peakvals}} -- list of peak values of the filters

\item {} 
\textbf{\texttt{wvmins}} -- list of minimum wavelength limits in nm

\item {} 
\textbf{\texttt{wvmaxs}} -- list of maximum wavelength limits in nm

\item {} 
\textbf{\texttt{oobs}} -- list of out-of-band leakage values

\end{itemize}

\item[{Returns}] \leavevmode
MODTRAN-style filter/SRF object

\end{description}\end{quote}
\index{\_\_init\_\_() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{name, units='nm', filterheaders={[}{]}, filters={[}{]}, centers={[}{]}, fwhms={[}{]}, shapes={[}'gauss'{]}, yedges={[}0.001{]}, centerflats={[}0.0{]}, peakvals={[}1.0{]}, wvmins={[}{]}, wvmaxs={[}{]}, oobs={[}4.9406564584124654e-324{]}}}{}
Create a filter definition object (MODTRAN flt style)
Input name is mandatory. All other inputs are optional, but the filterheaders list must have the same number of
string elements as the number of filters. Also, either the filters are given explicitly in the filters input, or
a list of filter definitions are provided for use with rad.srfgen().
If not empty, inputs centers through to oobs must be either scalar or have the same number of list elements as
the filterheaders list. If scalar, the value will be replicated up to the number of filterheader values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Name of the set of filters. If the filterheaders input to this constructor function
is empty, an attempt will be made to read the data from a file called name + `.flt'

\item {} 
\textbf{\texttt{units}} -- Spectral coordinate units for the filter, `nm', `um' or `cm\textasciicircum{}-1'

\item {} 
\textbf{\texttt{filterheaders}} -- List of strings, one header for each filter/SRF in the set.

\item {} 
\textbf{\texttt{filters}} -- A list of numpy arrays. Each list element must comprise a 2-column numpy array with the
spectral coordinate (wavelength in nm or micron or wavenumber per cm) in the first column and the filter
magnitude in the second column.

\item {} 
\textbf{\texttt{centres}} -- rather than provide filters, the inputs to rad.srfgen can be provided, this is a list of center
wavelengths in nm

\item {} 
\textbf{\texttt{fwhms}} -- list of full width at half maximum in nm

\item {} 
\textbf{\texttt{shapes}} -- list of strings providing the shapes of the filters (see rad.srfgen for alternatives)

\item {} 
\textbf{\texttt{yedges}} -- list of yedge values (see rad.srfgen)

\item {} 
\textbf{\texttt{centerflats}} -- list of centerflat values (see rad.srfgen). Note that giving a centerflat value adds this
amount ot the fwhm of the filters (broadens the resulting width to centerflat + fwhm)

\item {} 
\textbf{\texttt{peakvals}} -- list of peak values of the filters

\item {} 
\textbf{\texttt{wvmins}} -- list of minimum wavelength limits in nm

\item {} 
\textbf{\texttt{wvmaxs}} -- list of maximum wavelength limits in nm

\item {} 
\textbf{\texttt{oobs}} -- list of out-of-band leakage values

\end{itemize}

\item[{Returns}] \leavevmode
MODTRAN-style filter/SRF object

\end{description}\end{quote}

\end{fulllineitems}

\index{checkparm() (radute.Flt static method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.checkparm}\pysiglinewithargsret{\strong{static }\bfcode{checkparm}}{\emph{parmname}, \emph{parm}, \emph{nfilters}}{}
Input parameter checking for Flt constructor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{parmname}} -- Name of parameter fpr checking

\item {} 
\textbf{\texttt{parm}} -- Parameter value

\item {} 
\textbf{\texttt{nfilters}} -- Number of filters

\end{itemize}

\item[{Returns}] \leavevmode
Checked parameter

\end{description}\end{quote}

\end{fulllineitems}

\index{flt\_as\_xd() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.flt_as_xd}\pysiglinewithargsret{\bfcode{flt\_as\_xd}}{}{}
Convert an Flt class object to a list of xarray DataArray objects
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The set of Flt filters as a list of xarray DataArray objects, with a wavelength coordinate
axis (`wvl', long\_name = `Wavelength'

\end{description}\end{quote}

\end{fulllineitems}

\index{flt\_as\_xd\_harmonised() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.flt_as_xd_harmonised}\pysiglinewithargsret{\bfcode{flt\_as\_xd\_harmonised}}{\emph{quantity\_name='srf'}, \emph{chn\_start\_index=0}}{}
Convert the Flt class object into a single, wavelength-harmonised xr.DataArray.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{quantity\_name}} -- The name of the quantity as defined the long\_names variable in moglo.py. Defaults to
`srf', a Spectral Response Function, but could also be a transmission functions `trn' or other spectral
quantity known to moglo.py.

\item {} 
\textbf{\texttt{chn\_start\_index}} -- Use this parameter to select the starting channel number. Defaults to zero.

\end{itemize}

\item[{Returns}] \leavevmode
The set of Flt filters as a single, wavelength-harmonised xr.DataArray object. The filter
headers are returned in an attribute called `labels'. The fileheader of the Flt object is
returned in an attribute called `title' (netCDF recommendation)

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.plot}\pysiglinewithargsret{\bfcode{plot}}{\emph{filter\_numbers=None}}{}
Plot a MODTRAN-style set of filter/SRF curves.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filter\_numbers}} -- List of filter numbers to plot, defaults to all filters. Filter indices start at 0.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.read}\pysiglinewithargsret{\bfcode{read}}{\emph{filename}, \emph{name='Unknown'}}{}
Read a .flt format spectral band filter definitions file (MODTRAN format)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- 

\item[{Returns}] \leavevmode
object of class Flt, if the file is a well-formatted MODTRAN-style .flt file

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (radute.Flt method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.Flt.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename=None}, \emph{format='  \%f'}}{}
Write a MODTRAN-style .flt file for this filter/SRF set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- Optional filename without extension. If not given, the filter name will be used with

\item {} 
\textbf{\texttt{format}} -- Format specifier as for np.savetext for writing the data, default is `  \%f'
extension .flt

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SpectralDistribution (class in radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution}\pysiglinewithargsret{\strong{class }\code{radute.}\bfcode{SpectralDistribution}}{\emph{extreme\_limits}, \emph{in\_band\_limits=None}, \emph{in\_band\_threshold=0.01}}{}
The SpectralDistribution class defines any band-limited spectral distribution function. This could be
the spectral response functions of a sensor, or the spectral transmittance of an optical filter, the spectral
radiance, irradiance or any other band-limited spectral quantity.

Create a basic, spectral distribution function with certain spectral band limits

By default, wavelenths are specified in nm for SpectralDistribution and SpectralSpace objects.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A SpectralDistribution object

\end{description}\end{quote}
\index{\_\_init\_\_() (radute.SpectralDistribution method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{extreme\_limits}, \emph{in\_band\_limits=None}, \emph{in\_band\_threshold=0.01}}{}
Create a basic, spectral distribution function with certain spectral band limits

By default, wavelenths are specified in nm for SpectralDistribution and SpectralSpace objects.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A SpectralDistribution object

\end{description}\end{quote}

\end{fulllineitems}

\index{avhrr\_kratz() (radute.SpectralDistribution class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.avhrr_kratz}\pysiglinewithargsret{\strong{classmethod }\bfcode{avhrr\_kratz}}{\emph{i\_channel}, \emph{resolution=0.001}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i\_channel}} -- The single AVHRR Kratz channel to obtain. Integer 1 to 16

\item {} 
\textbf{\texttt{resolution}} -- this is the spectral resolution in nm of the band edges. Default 0.001 nm

\end{itemize}

\item[{Returns}] \leavevmode
A SpectralDistribution object defining the requested avhrr\_kratz channel

\end{description}\end{quote}

\end{fulllineitems}

\index{decimate\_resolution() (radute.SpectralDistribution method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.decimate_resolution}\pysiglinewithargsret{\bfcode{decimate\_resolution}}{}{}
Reduce the number of sample points representing the spectral distribution in an intelligent way.

This procedure only works for positive spectral power distributions.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{fu() (radute.SpectralDistribution class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.fu}\pysiglinewithargsret{\strong{classmethod }\bfcode{fu}}{\emph{i\_channel}, \emph{resolution=0.001}}{}
Return a Fu correlated-k channel as a SpectralDistribution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i\_channel}} -- the single Fu channel to be obtained. Integer 1 to 18

\item {} 
\textbf{\texttt{resolution}} -- this is the spectral resolution in nm of the band edges. Default 0.001 nm

\end{itemize}

\item[{Returns}] \leavevmode
A SpectralDistribution object defining the requested Fu channel

\end{description}\end{quote}

\end{fulllineitems}

\index{kato() (radute.SpectralDistribution class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.kato}\pysiglinewithargsret{\strong{classmethod }\bfcode{kato}}{\emph{i\_channel}, \emph{resolution=0.001}}{}
Return a Kato correlated-k channel definition as a SpectralDistribution. Only a single channel can
be represented. Use a SpectralSpace to get multiple Kato channels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i\_channel}} -- the single kato channel to be obtained. Integer 1 to 32

\item {} 
\textbf{\texttt{resolution}} -- this is the spectral resolution in nm of the band edges. Default 0.001 nm
which is typically adequate.

\end{itemize}

\item[{Returns}] \leavevmode
A SpectralDistribution object defining the requested Kato channel

\end{description}\end{quote}

\end{fulllineitems}

\index{sensor\_channel() (radute.SpectralDistribution class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.sensor_channel}\pysiglinewithargsret{\strong{classmethod }\bfcode{sensor\_channel}}{\emph{platform\_series}, \emph{platform\_name}, \emph{sensor\_name}, \emph{channel\_name}}{}
Load a spectral response file from the libRadtran-compatible library as a SpectralDistribution

The available response function filter files can be viewed in the sub-directory rad/radata/filter.
Note that only a single channel can be loaded using this method. To load multiple channels, use
SpectralSpace.sensor\_channels().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{platform\_series}} -- Name of the series of platforms on which the sensor is carried e.g. `landsat'

\item {} 
\textbf{\texttt{platform\_name}} -- Name of the specific satellite/platform on which the sensor is carried
e.g. `landsat7'

\item {} 
\textbf{\texttt{sensor\_name}} -- Name of the specific sensor on the platform e.g. `tm' or `etm'

\item {} 
\textbf{\texttt{channel\_name}} -- Name of the specific spectral channel on the given sensor e.g.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{spectral\_slice() (radute.SpectralDistribution class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralDistribution.spectral_slice}\pysiglinewithargsret{\strong{classmethod }\bfcode{spectral\_slice}}{\emph{extreme\_limits}, \emph{in\_band\_limits}, \emph{resolution=0.001}, \emph{oob\_leakage=0.0}}{}
Create a SpectralDistribution object as a simple spectral slice
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{extreme\_limits}} -- 

\item {} 
\textbf{\texttt{in\_band\_limits}} -- 

\item {} 
\textbf{\texttt{resolution}} -- 

\item {} 
\textbf{\texttt{oob\_leakage}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SpectralSpace (class in radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralSpace}\pysigline{\strong{class }\code{radute.}\bfcode{SpectralSpace}}
A SpectralSpace is a set (represented as a list) of SpectralDistribution objects.

For example, the full Kato correlated-k list of spectral slices constitutes a SpectralSpace.
A sub-range of of Kato or other correlated-k channels (Fu or avhrr\_kratz) also qualify.
The spectral response functions of a sensor can also be represented using a SpectralSpace.

An important use of SpectralSpaces is to compute ``projections'' which could also be thought of as
``dot products''. The projection of one SpectralSpace into another comprises multplying the
distribution functions and integrating over wavelength to obtain a set of weights. The integral is
typically also normalised to retain equivalent units.

Here are some examples:
A set of spectral end-member functions can be represented as a SpectralSpace. These end-members might
be propagated to calculate an end-member response at a camera focal plane. The end-members are projected
onto the spectral response functions of the sensor to get the sensor responses to each of the end-members.

Notes: A SpectralSpace is not generally orthogonal unless specifically designed so by the user.
\index{from\_flt\_file() (radute.SpectralSpace class method)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.SpectralSpace.from_flt_file}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_flt\_file}}{\emph{filename}, \emph{re\_select=None}}{}
Create a SpectralSpace list of SpectralDistribution objects by reading a MODTRAN-compatible
``filter function'' .flt file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- The MODTRAN-compatible .flt file from which to read the filter functions.

\item {} 
\textbf{\texttt{re\_select}} -- Select a sub-set of the channels using a regular expression filter. Only the channel
names/descriptions that match the regular expression will be included. The default is to read
all channels in the file.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{readOpenEXR() (in module radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.readOpenEXR}\pysiglinewithargsret{\code{radute.}\bfcode{readOpenEXR}}{\emph{filename}}{}
Simple read function for an OpenEXR file

Use of this function requires that the OpenEXR package be installed.
:param filename: The name of the OpenEXR file
:return channel\_names: List of image channel names found in the OpenEXR file
:return im\_dict: All image data in a dictionary keyed by channel names or channel groups. Channels are grouped
\begin{quote}

into RGB triplets if the channel names have the form prefix.R, prefix.G and prefix.B.
All image data is returned as numpy arrays.
\end{quote}
\begin{quote}\begin{description}
\item[{Return header}] \leavevmode
OpenEXR header as a dictionary.

\end{description}\end{quote}

\end{fulllineitems}

\index{srfgen() (in module radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.srfgen}\pysiglinewithargsret{\code{radute.}\bfcode{srfgen}}{\emph{center}, \emph{fwhm}, \emph{n=101}, \emph{shape='gauss'}, \emph{yedge=0.001}, \emph{wvmin=None}, \emph{wvmax=None}, \emph{centerflat=0.0}, \emph{oob=4.9406564584124654e-324}, \emph{peakval=1.0}, \emph{units='nm'}}{}
Generate a spectral filter or spectral response function of various shapes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{center}} -- center wavelength of the filter in nm

\item {} 
\textbf{\texttt{fwhm}} -- full width at half maximum of the filter  in nm

\item {} 
\textbf{\texttt{n}} -- number of spectral samples in the filter (minimum of 3, default 101), should be odd

\item {} 
\textbf{\texttt{shape}} -- filter shape, one of `gauss', `bartlett', `welch', `cosine', `box', `cos\textasciicircum{}2' (default `gauss')

\item {} 
\textbf{\texttt{yedge}} -- minimum y-value at the limits of the filter (default 0.001). No filter values below this threshold

\item {} 
\textbf{\texttt{wvmin}} -- extend spectral definition by adding a single point at (wvmin, oob)

\item {} 
\textbf{\texttt{wvmax}} -- exptend spectral definition by adding a single point at (wvmax, oob)

\item {} 
\textbf{\texttt{centerflat}} -- opens a flat region in the centre of filter having a width of centerflat nm

\item {} 
\textbf{\texttt{oob}} -- out-of-band leakage, default 0.0, must be \textless{}= yedge

\item {} 
\textbf{\texttt{peakval}} -- simply scales the peak of the filter function to this value (default 1.0)

\item {} 
\textbf{\texttt{units}} -- spectral axis units, either `nm', `cm\textasciicircum{}-1' or `um' (nanometers, wavenumber per cm or microns)
will be returned

\end{itemize}

\item[{Returns}] \leavevmode
wvlnm, y, wvn, wvlum (wavelengths in nm, filter values, wavenumbers per cm and wavelengths in microns)

\end{description}\end{quote}

\end{fulllineitems}

\index{tophat() (in module radute)}

\begin{fulllineitems}
\phantomsection\label{packages:radute.tophat}\pysiglinewithargsret{\code{radute.}\bfcode{tophat}}{\emph{center}, \emph{fwhm}, \emph{delta=0.0}, \emph{wvmin=None}, \emph{wvmax=None}, \emph{oob=0.0}, \emph{units='nm'}}{}
Return tophat/box filter defined by 6 points
Can also specify out-of-band values and extreme limits, which adds upper and lower bound points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{center}} -- center wavelength in nm

\item {} 
\textbf{\texttt{fwhm}} -- full width at half max in nm

\item {} 
\textbf{\texttt{delta}} -- smallest x-coordinate increment, default see np.nextafter

\item {} 
\textbf{\texttt{wvmin}} -- minimum wavelength to reach default None

\item {} 
\textbf{\texttt{wvmax}} -- maximum wavelength to reach default None

\item {} 
\textbf{\texttt{oob}} -- out-of-band leakage

\item {} 
\textbf{\texttt{units}} -- spectral axis units, either `nm', `cm\textasciicircum{}-1' or `um' (nanometers, wavenumber per cm or microns)
will be returned

\end{itemize}

\item[{Returns}] \leavevmode
wvlnm, y, wvn, wvlum (wavelengths in nm, filter values, wavenumbers per cm and wavelengths in microns)

\end{description}\end{quote}

\end{fulllineitems}



\section{Scene Package}
\label{packages:scene-package}\label{packages:id5}
The Scene package provides all MORTICIA functionality relating to radiometry and atmospheric radiative transfer.
Atmospheric radiative transfer is performed by the \href{http://www.libradtran.org}{libRadtran} suite of tools.


\subsection{Target Module}
\label{packages:target-module}\label{packages:id7}
The Target module concerns itself with calculations for rendering a target
\begin{itemize}
\item {} 
Greyscale Beach Target

\item {} 
Target 2

\item {} 
Target 3

\end{itemize}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Jupyter Notebooks}
\label{index:jupyter-notebooks}
Jupyter notebooks are provided to illustrate usage of the main package (\code{morticia}) as well as sub-packages
documented below.


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\texttt{electro}}, \pageref{packages:module-electro}
\indexspace
\bigletter{o}
\item {\texttt{optics}}, \pageref{packages:module-optics}
\indexspace
\bigletter{r}
\item {\texttt{radute}}, \pageref{packages:module-radute}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
