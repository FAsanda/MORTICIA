

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>optics &mdash; MORTICIA 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="MORTICIA 1.0 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> MORTICIA</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how_to_use.html">How to use MORTICIA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../how_to_use.html#morticia-dependencies">MORTICIA Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how_to_use.html#installation-and-requirements">Installation and Requirements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../styleguide.html">The MORTICIA Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#to-pep-8-or-not-to-pep-8">To PEP-8 or not to PEP-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#code-layout">Code Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#import-statements">Import Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#whitespace">Whitespace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#comments">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#documentation-strings-docstrings">Documentation Strings (docstrings)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#naming-conventions">Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#pep-257">PEP-257</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#from-conventions-section"><em>From</em> Conventions Section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#general-terminology-and-conventions">General Terminology and Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../for_developers.html">For the Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../for_developers.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#sensor-package">Sensor Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#radiometry-package">Radiometry Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#scene-package">Scene Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ChapLibRadtranODandPathRadiance.html">Transmittance and Path Radiance in libRadtran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01a-SpectralChannelsAndFilters.html">IPython Notebook and Sphinx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../01a-SpectralChannelsAndFilters.html#a-spectralchannelsandfilters-ipython-notebook">01a-SpectralChannelsAndFilters IPython Notebook</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">MORTICIA</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>optics</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for optics</h1><div class="highlight"><pre>
<span class="n">__author__</span> <span class="o">=</span> <span class="s">&#39;DGriffith&#39;</span>
<span class="n">__project__</span> <span class="o">=</span> <span class="s">&#39;MORTICIA&#39;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: optics</span>
<span class="sd">    :platform: Windows, Unix</span>
<span class="sd">    :synopsis:</span>
<span class="sd">        The optics module includes all code related to imaging optics as spatial and spectral filters. It also</span>
<span class="sd">        includes everything related to light propagation within such imaging optics. It does not include the</span>
<span class="sd">        atmospheric radiative transfer code. Functions related to the optical characteristics of the human</span>
<span class="sd">        eye are included in this module.</span>

<span class="sd">        Some important conventions:</span>
<span class="sd">        The most common variable names are:</span>
<span class="sd">        wvl : wavelengths, conventionally in nm, but not always, so always make sure</span>
<span class="sd">        spf : spatial frequencies, conventionally (for lenses) in cy/mm at the image plane</span>
<span class="sd">        fno : focal ratios (ratio of effective focal length to aperture diameter</span>
<span class="sd">        wvn : wavenumbers, conventionally in cm^-1</span>

<span class="sd">        As a basic check when dealing with wavelengths, the following can be observed</span>
<span class="sd">        If the wavelength is:</span>
<span class="sd">        &lt; 0.15 : Issue a warning</span>
<span class="sd">        &gt; 0.15 and &lt; 150.0 : Assume the spectral variable is wavelength in microns</span>
<span class="sd">        &gt; 150.0 and &lt; 15000.0 : Assume the spectral variable is wavelength in nm</span>
<span class="sd">        &gt; 15000.0 : Issue a warning</span>

<span class="sd">Dependencies : numpy (as np), pandas (as pd) and xray</span>
<span class="sd">               easygui, pint, warnings</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xray</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>  <span class="c"># TODO set up global logging if required.</span>


<span class="c"># Import units registry from parent to avoid duplicates</span>
<span class="kn">from</span> <span class="nn">morticia</span> <span class="kn">import</span> <span class="n">ureg</span><span class="p">,</span> <span class="n">Q_</span><span class="p">,</span> <span class="n">U_</span>

<span class="c"># Import tools related to xray DataArray and related unit checking/conversion</span>
<span class="kn">from</span> <span class="nn">morticia.tools.xd</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># As a general rule, where relevant and present, optical parameters are passed in in the order</span>
<span class="c">#   spatial frequency (spf), wavelength (wvl), focal ratio (fno) followed by any other parameters.</span>
<span class="c"># Returned functions of these parameters are generally multi-dimensional numpy arrays with spatial</span>
<span class="c"># frequencies varying down columns, wavelength varying across rows and focal ratio varying in the depth</span>
<span class="c"># dimension. However, singleton dimensions are squeezed out using the numpy.squeeze() function. For example,</span>
<span class="c"># if spf and fno are both vectors, but wvl is a scalar, then spf will vary down columns as before, but fno will</span>
<span class="c"># vary along rows rather than in the third dimension.</span>

<span class="c"># TODO : Review the above statements. In general it may not be a good idea to remove singleton dimensions, other</span>
<span class="c"># TODO : than trailing singleton dimensions. The real fix is to use xray.DataArray</span>


<span class="c"># Possible strategy for dealing with units.</span>
<span class="c"># Import pint and define function for creating quantity numpy arrays (typically Q_)</span>
<span class="c"># Alternatively import a &quot;stripped down&quot;, locally written version, which provides access to units, but no automatic</span>
<span class="c"># unit checking or conversion</span>


<div class="viewcode-block" id="mtf"><a class="viewcode-back" href="../packages.html#optics.mtf">[docs]</a><span class="k">def</span> <span class="nf">mtf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the simple (optimally focussed) diffraction Modulation Transfer Function (MTF) of a prefect lens with an</span>
<span class="sd">    unobscured circular aperture.</span>

<span class="sd">    :param spf: Spatial frequencies in the image at which to compute the MTF</span>
<span class="sd">    :param wvl: Wavelength in units consistent with the spatial frequencies f</span>
<span class="sd">    :param fno: Focal ratio (working focal ratio) of the lens</span>
<span class="sd">    :return: Modulation Transfer Function, with spatial frequency (spf) varying down columns and wavelength across rows</span>
<span class="sd">        If the frequencies are given in cycles per millimetre, the wavelengths must be in mm.</span>

<span class="sd">    Any of the inputs can be a vector. The spatial frequencies are assigned to the rows of the output array, the</span>
<span class="sd">    wavelengths vary from column to column and Fno will vary in the third dimension, but singleton dimensions will</span>
<span class="sd">    be squeezed out.</span>

<span class="sd">    .. seealso:: optics.pmtf, optics.pmtf_obs, optics.pmtf_obs_wfe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="c"># Compute the cutoff frequencies</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">wvl</span> <span class="o">*</span> <span class="n">fno</span><span class="p">)</span>
    <span class="c"># Any spatial frequencies above the cutoff are set to the cutoff frequency</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">fno</span> <span class="o">*</span> <span class="n">spf</span> <span class="o">*</span> <span class="n">wvl</span><span class="p">)</span>
    <span class="n">csphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">the_mtf</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="n">csphi</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">the_mtf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="autocorr_circle"><a class="viewcode-back" href="../packages.html#optics.autocorr_circle">[docs]</a><span class="k">def</span> <span class="nf">autocorr_circle</span><span class="p">(</span><span class="n">circle_radius</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute autocorrelation of a circular aperture of radius **circle_radius** with centre-to-centre sample</span>
<span class="sd">    displacements of **shift**.</span>

<span class="sd">    :param circle_radius: Radius of circle</span>
<span class="sd">    :param shift: Centre-to-centre displacements at which to compute the autocorrelation</span>
<span class="sd">    :return: Autocorrelation magnitude</span>

<span class="sd">    .. seealso:: optics.crosscorr_circle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circle_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">circle_radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">circle_radius</span><span class="p">)</span>  <span class="c"># Calculation only valid up to shift = 2 * circle_radius</span>
    <span class="n">surd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">shift</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">circle_radius</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">auto</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">circle_radius</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">surd</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">circle_radius</span><span class="p">))</span> <span class="o">-</span> <span class="n">shift</span><span class="o">*</span><span class="n">surd</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">auto</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="crosscorr_circle"><a class="viewcode-back" href="../packages.html#optics.crosscorr_circle">[docs]</a><span class="k">def</span> <span class="nf">crosscorr_circle</span><span class="p">(</span><span class="n">circle_radius</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Cross correlation of unit circle with circle of radius **circle_radius**.</span>
<span class="sd">    Compute the cross-correlation of a circular aperture of unit radius at the origin,</span>
<span class="sd">    with a circular aperture of radius **circle_radius**, with centre-to-centre displacements of **shift**.</span>

<span class="sd">    :param circle_radius: Radius of circle to cross-correlate with unit circle (scalar numeric)</span>
<span class="sd">    :param shift: Centre-to-centre displacements at which to compute the cross-correlation</span>
<span class="sd">    :return: Cross-correlation magnitude</span>

<span class="sd">    .. seealso:: optics.autocorr_circle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circle_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">circle_radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="c"># Formula only valid for shift between 1-circle_radius and 1+circle_radius</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">circle_radius</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">circle_radius</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">circle_radius</span> <span class="o">+</span> <span class="n">shift</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">circle_radius</span> <span class="o">-</span> <span class="n">shift</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">circle_radius</span> <span class="o">+</span> <span class="n">shift</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
                        <span class="n">circle_radius</span> <span class="o">-</span> <span class="n">shift</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">circle_radius</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">circle_radius</span><span class="o">*</span><span class="n">shift</span> <span class="o">/</span> <span class="p">(</span><span class="n">shift</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">circle_radius</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">shift</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">circle_radius</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">shift</span><span class="p">))</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cross</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="mtf_obs"><a class="viewcode-back" href="../packages.html#optics.mtf_obs">[docs]</a><span class="k">def</span> <span class="nf">mtf_obs</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the optimally focussed diffraction Modulation Transfer Function of a perfect lens with an</span>
<span class="sd">    circular aperture having a centred circular obscuration. This is the monochromatic MTF computed at</span>
<span class="sd">    a number of discrete given wavelengths.</span>

<span class="sd">    :param spf: Spatial frequencies in the image at which to compute the MTF (numpy vector).</span>
<span class="sd">    :param wvl: Wavelength in units consistent with the spatial frequencies **spf** (numpy vector)</span>
<span class="sd">    :param fno: Focal ratio (working focal ratio) of the lens (numpy vector).</span>
<span class="sd">    :param obs: The obscuration ratio (ratio of obscuration diameter to total aperture diameter).</span>
<span class="sd">                The obs input must be a scalar numeric.</span>
<span class="sd">    :return: MTF with respect to spatial frequency, wavelength, focal ratio and obscuration ratio.</span>
<span class="sd">             Singleton dimensions are squeezed out.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obs</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c"># just calculate the unobscured diffraction MTF</span>
        <span class="k">return</span> <span class="n">mtf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">)</span>

    <span class="c"># Otherwise mesh things up and do it the hard way</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="c"># Calculate w at each matrix site</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">fno</span> <span class="o">*</span> <span class="n">spf</span> <span class="o">*</span> <span class="n">wvl</span>
    <span class="n">the_mtf</span> <span class="o">=</span> <span class="p">(</span><span class="n">autocorr_circle</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">crosscorr_circle</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">autocorr_circle</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">obs</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">the_mtf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="pmtf"><a class="viewcode-back" href="../packages.html#optics.pmtf">[docs]</a><span class="k">def</span> <span class="nf">pmtf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute polychromatic MTF of lens at given spatial frequencies (in the image plane) for specified wavelengths</span>
<span class="sd">    and wavelength weighting factors.</span>

<span class="sd">    :param spf: Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).</span>
<span class="sd">    :param wvl: Wavelength in units consistent with the spatial frequencies **spf** (numpy vector)</span>
<span class="sd">    :param fno: Focal ratio (working focal ratio) of the lens (numpy vector).</span>
<span class="sd">    :param wvl_weights: A numpy vector having the same length as the wvl vector, providing the relative weights of each</span>
<span class="sd">        of the wavelengths.</span>
<span class="sd">    :return: Polychromatic MTF with respect to spatial frequency, wavelength and focal ratio.</span>
<span class="sd">        Singleton dimensions are squeezed out of the returned numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># size of weights MUST be the same size as the wvl</span>
    <span class="n">wvl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">wvl_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">wvl</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;Number of wavelength weights must be equal to number of wavelengths in call to optics.pmtf()&#39;</span><span class="p">)</span>
    <span class="c"># Tile the weights up to the same size as the meshgridded arrays</span>
    <span class="n">wvl_weights_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">wvl_weights_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">wvl_weights_1</span><span class="p">,</span> <span class="p">(</span><span class="n">spf</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fno</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span><span class="p">)</span>
    <span class="c"># Compute the cutoff frequencies</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">wvl</span> <span class="o">*</span> <span class="n">fno</span><span class="p">)</span>
    <span class="c"># Any spatial frequencies above the cutoff are set to the cutoff frequency</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">fno</span> <span class="o">*</span> <span class="n">spf</span> <span class="o">*</span> <span class="n">wvl</span><span class="p">)</span>
    <span class="n">csphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">the_mono_mtf</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="n">csphi</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">the_poly_mtf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">the_mono_mtf</span> <span class="o">*</span> <span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">the_poly_mtf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="pmtf_obs"><a class="viewcode-back" href="../packages.html#optics.pmtf_obs">[docs]</a><span class="k">def</span> <span class="nf">pmtf_obs</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute polychromatic MTF of obscured lens at given spatial frequencies (in the image plane) for specified</span>
<span class="sd">    wavelengths and wavelength weighting factors. The lens may have a circular obcuration of specific ratio.</span>

<span class="sd">    :param spf: Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).</span>
<span class="sd">    :param wvl: Wavelength in units consistent with the spatial frequencies **spf** (numpy vector)</span>
<span class="sd">    :param fno: Focal ratio (working focal ratio) of the lens (numpy vector).</span>
<span class="sd">    :param wvl_weights: A numpy vector having the same length as the wvl vector, providing the relative weights of each</span>
<span class="sd">        of the wavelengths.</span>
<span class="sd">    :param obs: Obscuration ratio</span>
<span class="sd">    :return: Polychromatic obscured MTF with respect to spatial frequency, wavelength and focal ratio.</span>
<span class="sd">        Singleton dimensions are squeezed out of the returned numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wvl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">wvl_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">obs</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c"># Just return the unobscured polychromatic MTF</span>
        <span class="k">return</span> <span class="n">pmtf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">)</span>
        <span class="c"># size of weights MUST be the same size as the wvl</span>
    <span class="k">if</span> <span class="n">wvl</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;Number of wavelength weights must be equal to number of wavelengths in call to optics.pmtf_obs()&#39;</span><span class="p">)</span>
    <span class="c"># Tile the weights up to the same size as the meshgridded arrays</span>
    <span class="n">wvl_weights_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">wvl_weights_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">wvl_weights_1</span><span class="p">,</span> <span class="p">(</span><span class="n">spf</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fno</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="c"># Calculate the obscured, monochromatic MTFs</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span><span class="p">)</span>
    <span class="c"># Calculate w at each matrix site</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">fno</span> <span class="o">*</span> <span class="n">spf</span> <span class="o">*</span> <span class="n">wvl</span>
    <span class="n">the_mono_mtf</span> <span class="o">=</span> <span class="p">(</span><span class="n">autocorr_circle</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">crosscorr_circle</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">autocorr_circle</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">obs</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">the_poly_mtf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">the_mono_mtf</span> <span class="o">*</span> <span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">the_poly_mtf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="atf"><a class="viewcode-back" href="../packages.html#optics.atf">[docs]</a><span class="k">def</span> <span class="nf">atf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">rms_wavefront_error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the MTF degradation factor for a lens operating at the given wavelengths and and with the given</span>
<span class="sd">    focal ratios, RMS wavefront errors at the the specified spatial frequencies in the image plane.</span>
<span class="sd">    ATF stands for Aberration Transfer Function.</span>

<span class="sd">    :param spf: Spatial frequencies in the image plane at which to compute the ATF. Spatial frequencies must be in</span>
<span class="sd">        reciprocal units to wavelengths i.e. if wavelengths are in mm, spatial frequencies must be in cycles per mm.</span>
<span class="sd">    :param wvl: Wavelengths at which to compute the ATF</span>
<span class="sd">    :param fno: Focal ratios at which to compute the ATF</span>
<span class="sd">    :param rms_wavefront_error: RMS wavefront error magnitudes (in waves) at which to compute the ATF</span>
<span class="sd">    :return: A numpy array with the aberration transfer function.</span>

<span class="sd">    Reference : Shannon, R.R., Handbook of Optics, Volume 1, 2nd Edition, Chapter 35 - Optical</span>
<span class="sd">    Specifications. &quot;This is an approximation, however, and it becomes progressively less accurate as</span>
<span class="sd">    the amount of the rms wavefront error exceeds about 0.18 wavelength.&quot;</span>

<span class="sd">    The formula used for computing the aberration MTF due to RMS wavefront error of :math:`W` at spatial frequency</span>
<span class="sd">    :math:`f` is</span>

<span class="sd">    .. math::</span>
<span class="sd">        M\\!T\\!F_{W}(f)=1-\\left(\\frac{W}{0.18}\\right)^{2}\\left[1-4\\left(\\frac{f}{f_{c}}-\\frac{1}{2}\\right)^{2}\\right]</span>

<span class="sd">    where the diffraction cutoff (or &quot;critical&quot;) frequency is :math:`f_c`.</span>

<span class="sd">    .. seealso:: optics.pmtf_obs_wfe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rms_wavefront_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">)</span>  <span class="c"># Force positive</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;optics.atf function generally only valid up to RMS wavefront error of 0.3. Called with&#39;</span>
                        <span class="s">&#39;maximum value of </span><span class="si">%f</span><span class="s">.&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">))</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">rms_wavefront_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="c"># Find the cutoff frequencies</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">fno</span> <span class="o">*</span> <span class="n">wvl</span><span class="p">)</span>
    <span class="c"># Compute the spatial frequencies as a fraction of the cutoff</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">spf</span> <span class="o">/</span> <span class="n">cutoff</span>
    <span class="c"># Compute the ATF according to Shannon</span>
    <span class="n">the_atf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">((</span><span class="n">rms_wavefront_error</span> <span class="o">/</span> <span class="mf">0.18</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="c"># Values above 1.0 are not possible, so set those to 1.0</span>
    <span class="n">the_atf</span><span class="p">[</span><span class="n">the_atf</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">the_atf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="patf"><a class="viewcode-back" href="../packages.html#optics.patf">[docs]</a><span class="k">def</span> <span class="nf">patf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the polychromatic aberration transfer function.</span>

<span class="sd">    :param spf: Spatial frequencies in the image plane at which to compute the ATF. Spatial frequencies must be in</span>
<span class="sd">        reciprocal units to wavelengths i.e. if wavelengths are in mm, spatial frequencies must be in cycles per mm.</span>
<span class="sd">    :param wvl: Wavelengths at which to compute the ATF</span>
<span class="sd">    :param fno: Focal ratios at which to compute the ATF</span>
<span class="sd">    :param rms_wavefront_error: RMS wavefront error magnitudes (in waves) at which to compute the ATF</span>
<span class="sd">    :param wvl_weights: A numpy vector having the same length as the wvl vector, providing the relative weights of each</span>
<span class="sd">        of the wavelengths.</span>
<span class="sd">    :return: Polychromatic Aberration Transfer Function in a numpy array.</span>

<span class="sd">    .. seealso:: optics.atf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wvl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">wvl_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">rms_wavefront_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c"># size of weights MUST be the same size as the wvl</span>
    <span class="k">if</span> <span class="n">wvl</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;Number of wavelength weights must be equal to number of wavelengths in call to optics.patf()&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wvl</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">rms_wavefront_error</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;Number of wavefront error elements must be equal to number of wavelengths in&#39;</span>
                      <span class="s">&#39; call to optics.patf()&#39;</span><span class="p">)</span>
    <span class="c"># Tile the weights up to the same size as the meshgridded arrays</span>
    <span class="n">wvl_weights_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">wvl_weights</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">wvl_weights_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">wvl_weights_1</span><span class="p">,</span> <span class="p">(</span><span class="n">spf</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fno</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="c"># Also tile up the wavefront errors to the same size</span>
    <span class="n">rms_wavefront_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">)</span>  <span class="c"># Force positive</span>
    <span class="n">rms_wavefront_error_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rms_wavefront_error</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">rms_wavefront_error_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">rms_wavefront_error_1</span><span class="p">,</span> <span class="p">(</span><span class="n">spf</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fno</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;optics.atf function generally only valid up to RMS wavefront error of 0.3. Called with&#39;</span>
                        <span class="s">&#39;maximum value of </span><span class="si">%f</span><span class="s">.&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rms_wavefront_error</span><span class="p">))</span>
    <span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">spf</span><span class="p">,</span> <span class="n">fno</span><span class="p">)</span>
    <span class="c"># Find the cutoff frequencies</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">fno</span> <span class="o">*</span> <span class="n">wvl</span><span class="p">)</span>
    <span class="c"># Compute the spatial frequencies as a fraction of the cutoff</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">spf</span> <span class="o">/</span> <span class="n">cutoff</span>
    <span class="c"># Compute the ATF according to Shannon</span>
    <span class="n">the_mono_atf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">((</span><span class="n">rms_wavefront_error_2</span> <span class="o">/</span> <span class="mf">0.18</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">the_poly_atf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">the_mono_atf</span> <span class="o">*</span> <span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wvl_weights_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Values above 1.0 are not possible, so set those to 1.0</span>
    <span class="n">the_poly_atf</span><span class="p">[</span><span class="n">the_poly_atf</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">the_poly_atf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="pmtf_obs_wfe"><a class="viewcode-back" href="../packages.html#optics.pmtf_obs_wfe">[docs]</a><span class="k">def</span> <span class="nf">pmtf_obs_wfe</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute polychromatic modulation transfer function for lens having circular pupil with centred circular</span>
<span class="sd">    obscuration and with aberrations expressed in terms of RMS wavefront error.</span>

<span class="sd">    :param spf: Spatial frequencies in the image at which to compute the polychromatic MTF (numpy vector).</span>
<span class="sd">    :param wvl: Wavelength in units consistent with the spatial frequencies **spf** (numpy vector)</span>
<span class="sd">    :param fno: Focal ratio (working focal ratio) of the lens (numpy vector).</span>
<span class="sd">    :param rms_wavefront_error: Numpy vector of RMS wavefront error values</span>
<span class="sd">    :param wvl_weights: A numpy vector having the same length as the wvl vector, providing the relative weights of each</span>
<span class="sd">        of the wavelengths.</span>
<span class="sd">    :param obs: Obscuration ratio (centred circular obscuration in circular pupil), ratio of obscuration diameter to</span>
<span class="sd">        aperture diameter.</span>
<span class="sd">    :return: Numpy array with polychromatic modulation transfer function.</span>

<span class="sd">    .. seealso:: optics.atf, optics.pmtf_obs, optics.pmtf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Compute the obscured polychromatic MTF</span>
    <span class="n">poly_mtf_obs</span> <span class="o">=</span> <span class="n">pmtf_obs</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">,</span> <span class="n">obs</span><span class="p">)</span>
    <span class="c"># Compute the polychromatic aberration transfer function</span>
    <span class="n">poly_atf</span> <span class="o">=</span> <span class="n">patf</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">rms_wavefront_error</span><span class="p">,</span> <span class="n">wvl_weights</span><span class="p">)</span>
    <span class="c"># Compute the return result as an element-wise product</span>
    <span class="n">poly_mtf_obs_wfe</span> <span class="o">=</span> <span class="n">poly_mtf_obs</span> <span class="o">*</span> <span class="n">poly_atf</span>
    <span class="k">return</span> <span class="n">poly_mtf_obs_wfe</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="n_air"><a class="viewcode-back" href="../packages.html#optics.n_air">[docs]</a><span class="k">def</span> <span class="nf">n_air</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">pressure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the refractive index of air computed using the same formula used by ZEMAX</span>
<span class="sd">    See the section on Index of Refraction Computation in the Thermal Analysis chapter of the ZEMAX manual.</span>

<span class="sd">    :param wvl:  Wavelength(s) in microns. If all values of wvl exceed 100, then wavelengths are assumed to be in nm</span>
<span class="sd">    :param temperature: Temperature in Celsius.</span>
<span class="sd">    :param pressure: Relative air pressure (atmospheres, with 1 atm = 101 325 Pa).</span>
<span class="sd">    :return: This function returns a matrix with wvl varying from row to row, temperature varying from column to column</span>
<span class="sd">        and pressure varying in the depth dimension. The returned matrix is subject to np.squeeze() to remove any</span>
<span class="sd">        singleton dimensions.</span>

<span class="sd">    Reference :</span>
<span class="sd">    F. Kohlrausch, Praktische Physik, 1968, Vol 1, page 408</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wvl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">wvl</span> <span class="o">&gt;=</span> <span class="mf">100.0</span><span class="p">):</span>
        <span class="n">wvl</span> <span class="o">/=</span> <span class="mf">1000.0</span>  <span class="c"># Convert to microns if all wavelengths are greater than 100</span>
    <span class="n">temperature</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">pressure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">wvl</span><span class="p">,</span> <span class="n">pressure</span><span class="p">)</span>
    <span class="c"># Compute the reference refractive indices across all wavelengths</span>
    <span class="n">n_ref</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="p">(</span><span class="mf">6432.8</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2949810.</span> <span class="o">*</span> <span class="n">wvl</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">146.</span> <span class="o">*</span> <span class="n">wvl</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">25540.</span> <span class="o">*</span> <span class="n">wvl</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">41.</span> <span class="o">*</span> <span class="n">wvl</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1e-8</span>
    <span class="c"># Compute the full data set (potentially 3D)</span>
    <span class="n">air_rin</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="p">((</span><span class="n">n_ref</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">pressure</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="p">(</span><span class="n">temperature</span> <span class="o">-</span> <span class="mf">15.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.4785e-3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">air_rin</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="c"># Functions related to the human eye, namely contrast transfer function (CTF) and modulation transfer function (MTF)</span></div>
<div class="viewcode-block" id="ctf_eye"><a class="viewcode-back" href="../packages.html#optics.ctf_eye">[docs]</a><span class="k">def</span> <span class="nf">ctf_eye</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">lum</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">num_eyes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">formula</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the contrast transfer function of the human eye.</span>
<span class="sd">    By default, uses the condensed version of the Barten CTF.</span>

<span class="sd">    :param spf: spatial frequencies in eye-space in cycles per milliradian (scalar or vector numpy array input)</span>
<span class="sd">    :param lum: mean luminance of the viewing area in :math:`cd/m^2` (scalar or vector numpy array input)</span>
<span class="sd">    :param w: the angular width of the viewing area, or the square root of the angular viewing area in square degrees</span>
<span class="sd">        (scalar or vector numpy input).</span>
<span class="sd">    :param num_eyes: The number of eyes used for viewing (2 for binocular viewing or 1 for monocular viewing). The</span>
<span class="sd">        default is num_eyes=2.</span>
<span class="sd">    :param formula: The formula variant used for the computation. Defaults (formula=1) to the simple formula first</span>
<span class="sd">        published by Barten in SPIE 2003. Other options are formula=11 and formula=14, which are slight variations.</span>
<span class="sd">    :return: The CTF with respect to spf, lum and w (up to a 3D numpy array). Singular dimensions are squeezed out</span>
<span class="sd">        using numpy.squeeze().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">spf</span><span class="p">,</span> <span class="n">lum</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">lum</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="c"># Convert spatial frequencies to cycles per degree</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">spf</span> <span class="o">/</span> <span class="mf">180.0</span>
    <span class="k">if</span> <span class="n">formula</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="mf">540.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">/</span> <span class="n">lum</span><span class="p">)</span><span class="o">**-</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">u</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mf">0.06</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="n">lum</span><span class="p">)</span><span class="o">**</span><span class="mf">0.15</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">u</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">formula</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="mf">540.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">/</span> <span class="n">lum</span><span class="p">)</span><span class="o">**-</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">12.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">u</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c"># Notice square on 1+u/3 factor</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mf">0.06</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="n">lum</span><span class="p">)</span><span class="o">**</span><span class="mf">0.15</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">u</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">formula</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>  <span class="c"># A more complex formula that also only uses the viewing size and mean luminance</span>
        <span class="n">m_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.0016</span> <span class="o">*</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">100.0</span> <span class="o">/</span> <span class="n">lum</span><span class="p">)</span><span class="o">**</span><span class="mf">0.08</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mf">5200.0</span> <span class="o">*</span> <span class="n">m_opt</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">144.</span> <span class="o">/</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.64</span> <span class="o">*</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">63.</span> <span class="o">/</span> <span class="n">lum</span><span class="o">**</span><span class="mf">0.83</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">/</span> <span class="n">num</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c"># create array of nans</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">spf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">thresh</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">thresh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_eyes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">thresh</span><span class="p">[</span><span class="n">thresh</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c"># Threshold greater than 1 is meaningless</span>
    <span class="k">return</span> <span class="n">thresh</span>


</div>
<div class="viewcode-block" id="Lens"><a class="viewcode-back" href="../packages.html#optics.Lens">[docs]</a><span class="k">class</span> <span class="nc">Lens</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The Lens class encapsulates information and behaviour related to imaging lens systems.</span>
<span class="sd">    The chief characteristics of a lens are its spectral through-field, through-focus and</span>
<span class="sd">    through-frequency MTF, as well as the spectral transmission.</span>
<span class="sd">    In order to transform spatial frequencies in the image plane to angular spatial frequencies</span>
<span class="sd">    in object space, the effective focal length of the lens (efl) must also be known.</span>
<span class="sd">    The basic lens model is a near diffraction-limited system with a centred circular aperture</span>
<span class="sd">    having a centred circular obscuration (which may be absent), where the MTF is constant over</span>
<span class="sd">    the entire field of view (FOV). A lens with field-dependent MTF can be constructed by</span>
<span class="sd">    providing wavefront error input that varies with field.</span>

<span class="sd">    The most basic lens model implemented here, from which more complicated lens models could inherit</span>
<span class="sd">    their properties have the following attributes</span>

<span class="sd">    :param efl: The effective focal length of the lens in mm</span>
<span class="sd">    :param fno: The focal ratio of the lens</span>
<span class="sd">    :param trn: The spectral transmission of the lens (zero to unity).</span>
<span class="sd">    :param wfe: The wavefront error measured in waves. This can be a scalar, assumed the same for</span>
<span class="sd">        all wavelengths, or it can be provided as a function of wavelength and/or field position.</span>
<span class="sd">    :param obs: The obscuration ratio, being the ratio of the circular obscuration diameter to the</span>
<span class="sd">        full circular aperture aperture diameter</span>
<span class="sd">    :param mtf: The MTF of the lens. Either the MTF can be provided as a set of measurements or it can be</span>
<span class="sd">        computed from efl, fno, obs and wfe</span>

<span class="sd">    The lens MTF is computed as a function of spatial frequency in the image, wavelength, defocus and field position.</span>

<span class="sd">    The total RMS wavefront error is computed as</span>

<span class="sd">    .. math::</span>
<span class="sd">        W=\\sqrt{W_{\\Delta\\!z}^{2}+W_{a}^{2}}=\\sqrt{\\left(\\frac{\\Delta\\!z}{8\\lambda F^{2}}\\right)^{2}+W_{a}^{2}}</span>

<span class="sd">    where :math:`\\Delta\\!z` is the defocus expressed in the same units as the wavelength :math:`\\lambda`, :math:`F` is</span>
<span class="sd">    the focal ratio and :math:`W_a` is the RMS waverfront error due to aberrations at best focus.</span>

<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Lens.__init__"><a class="viewcode-back" href="../packages.html#optics.Lens.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">efl</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="n">trn</span><span class="p">,</span> <span class="n">wfe</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mtf</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wvn_step</span><span class="o">=</span><span class="mf">500.0</span><span class="p">,</span> <span class="n">wfe_allowed</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Lens constructor.</span>
<span class="sd">        The lens is constructed using the focal length, focal ratio and spectral transmittance, and</span>
<span class="sd">        optionally also the obscuration ratio and wavefront error.</span>

<span class="sd">        :param efl: The effective focal length of the lens. The effective focal length must be a scalar value</span>
<span class="sd">            with units, e.g. [30, &#39;mm&#39;].</span>
<span class="sd">        :param fno: The focal ratio (or f-number) which is th ratio of focal length to aperture diameter. This input</span>
<span class="sd">            must be a scalar value.</span>
<span class="sd">        :param trn: The spectral transmission function, typically a function of wavelength. The spectral</span>
<span class="sd">            transmittance function must be</span>
<span class="sd">        :type trn: xray.DataArray</span>
<span class="sd">        :param wfe: The wavefront error must be expressed in waves (unitless). It can be a function of</span>
<span class="sd">            wavelength (wvl) and field position (flr) , but not focus (fldz). If no input is provided, the wfe</span>
<span class="sd">            will default to zero over the same spectral region as the lens transmission function.</span>
<span class="sd">        :param obs: The obscuration ratio of the lens (scalar numeric) range 0.0 - 1.0, Default None (0.0)</span>
<span class="sd">        :param mtf: A complete pre-computed or measured MTF, with axes of spf, wvl, fldz, flr, flo</span>
<span class="sd">        :param wvn_step: Minimum spectral increment in wavenumbers (cm^-1) for MTF calculation. Default 500 cm^-1</span>
<span class="sd">        :param wfe_allowed: Maximum allowed wfe when computing lens defocus wfe, Default 0.5 waves at mean wavelength</span>
<span class="sd">            of transmission function domain.</span>
<span class="sd">        :param attrs: A dictionary of user-defined attributes and metadata. Consider including &#39;name&#39; and</span>
<span class="sd">            &#39;long_name&#39;, &#39;title&#39;, &#39;summary&#39; or other netCDF convention attributes.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Check some assertions : this is bad practice - assertions are used to trap situations</span>
        <span class="c"># the demonstrate that there is a bug in the code. Rather deal with input checking</span>
        <span class="c"># in other ways</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trn</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="p">(</span><span class="s">&#39;wvl&#39;</span><span class="p">,):</span>  <span class="c"># TODO : Throw exception, issue warning, log warning</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Data axes for transmission of optics.Lens are likely missing/incorrect.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MissingDataArrayAxis</span><span class="p">(</span><span class="s">&#39;Transmission data for optics.Lens to be function of wavelength only.&#39;</span><span class="p">)</span>
        <span class="c"># Check units of transmission wavelength scale and convert</span>
        <span class="n">xd_check_convert_units</span><span class="p">(</span><span class="n">trn</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">)</span>  <span class="c"># Change units on wvl axis to nm in place</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">trn</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">150.0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">trn</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">15000.0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Wavelength units for optics.Lens transmission probably not in units of &#39;</span><span class="o">+</span> <span class="n">trn</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;wvl_units&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trn</span> <span class="o">=</span> <span class="n">trn</span>
        <span class="c"># Check units of efl and convert</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efl</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="s">&#39;efl&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">efl</span><span class="p">)</span>  <span class="c"># convert efl units to default units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fno</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="s">&#39;fno&#39;</span><span class="p">,</span> <span class="n">fno</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>  <span class="c"># fno is unitless</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trn</span> <span class="o">=</span> <span class="n">trn</span>  <span class="c"># this should be an xray.DataArray</span>
        <span class="k">if</span> <span class="n">obs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obs</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">obs</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Obscuration ratio for optics.Lens must be from 0.0 to 1.0&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="s">&#39;obs&#39;</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>  <span class="c"># Obscuration is unitless</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># no obscuration</span>
        <span class="c"># Need to choose the wavelength grid on which to compute the MTF</span>
        <span class="c"># At this point is is assumed that EFL is in mm and wavelengths are in nm</span>
        <span class="n">wvl_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">trn</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
        <span class="n">wvl_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">trn</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
        <span class="n">wvl_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">wvl_min</span><span class="p">,</span> <span class="n">wvl_max</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">wvl_min</span> <span class="o">==</span> <span class="n">wvl_max</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Spectral transmission function of optics.Lens should span a wavelength region.&#39;</span><span class="p">)</span>
        <span class="c"># Spectral points will be evenly spaced in wavenumber</span>
        <span class="n">wvn_min</span> <span class="o">=</span> <span class="mf">1.0e7</span> <span class="o">/</span> <span class="n">wvl_max</span>  <span class="c"># cm^-1</span>
        <span class="n">wvn_max</span> <span class="o">=</span> <span class="mf">1.0e7</span> <span class="o">/</span> <span class="n">wvl_min</span>  <span class="c"># cm^-1</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">wvn_max</span> <span class="o">-</span> <span class="n">wvn_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">wvn_step</span><span class="p">)</span>
        <span class="n">wvn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wvn_max</span><span class="p">,</span> <span class="n">wvn_min</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># cm^-1</span>
        <span class="n">wvl</span> <span class="o">=</span> <span class="mf">1.0e7</span> <span class="o">/</span> <span class="n">wvn</span>  <span class="c"># nm</span>
        <span class="c"># Convert wvl back to identity DataArray</span>
        <span class="n">wvl</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">wvl</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span> <span class="o">=</span> <span class="n">wvl</span>
       <span class="c"># Need to choose the spatial frequency grid on which to computer the MTF</span>
        <span class="c"># This depends on the cutoff (or &quot;critical&quot;) frequency mainly.</span>
        <span class="c"># Determine the minimum and maximum cutoff frequencies</span>
        <span class="n">cutoff_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0e-6</span> <span class="o">*</span> <span class="n">wvl_min</span> <span class="o">*</span> <span class="n">fno</span><span class="p">)</span>  <span class="c"># wvl assumed now in nm, freq in cy/mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_max</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="s">&#39;spfcut&#39;</span><span class="p">,</span> <span class="n">cutoff_max</span><span class="p">,</span> <span class="s">&#39;1/mm&#39;</span><span class="p">)</span>
        <span class="n">cutoff_min</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0e-6</span> <span class="o">*</span> <span class="n">wvl_max</span> <span class="o">*</span> <span class="n">fno</span><span class="p">)</span>  <span class="c"># cy/mm</span>
        <span class="n">spf_step</span> <span class="o">=</span> <span class="n">cutoff_min</span> <span class="o">/</span> <span class="mf">12.0</span>  <span class="c"># Want at least 15 samples up to minimum cutoff</span>
        <span class="n">n_steps_spf</span> <span class="o">=</span> <span class="n">cutoff_max</span> <span class="o">*</span> <span class="mf">1.1</span> <span class="o">/</span> <span class="n">spf_step</span>  <span class="c"># Want sampling up to 1.1 times maximum spf</span>
        <span class="n">spf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cutoff_max</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">,</span> <span class="n">n_steps_spf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># cy/mm</span>
        <span class="c"># Create a DataArray of spatial frequencies</span>
        <span class="n">spf</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="s">&#39;spf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spf</span> <span class="o">=</span> <span class="n">spf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spf_max</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="s">&#39;spf&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spf</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="s">&#39;1/mm&#39;</span><span class="p">)</span>
        <span class="c"># Need to compute the defocus grid on which to compute the MTF</span>
        <span class="c"># There is no real point in computing MTF using the Shannon formula</span>
        <span class="c"># if the total wavefront deformation is greater than 0.18 waves.</span>
        <span class="c"># Will allow up to 0.5 waves of defocus in steps of 0.02 waves</span>
        <span class="c"># Wavefront deformation can be a function of up to 3 variables:</span>
        <span class="c"># wvl, fld and image azimuth (sagittal/tangential)</span>
        <span class="c"># First find the maximum aberration wavefront deformation</span>
        <span class="k">if</span> <span class="n">wfe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wfe_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wfe</span><span class="p">)</span>  <span class="c"># waves, RMS</span>
            <span class="n">wfe_wvl_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">wfe</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
            <span class="n">wfe_wvl_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wfe</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">wfe_wvl_min</span> <span class="o">!=</span> <span class="n">wvl_min</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">wfe_wvl_max</span> <span class="o">!=</span> <span class="n">wvl_max</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Wavefront error input to optics.Lens does not have same wavelength limits as trn.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wfe_max</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c"># Default to zero</span>
            <span class="n">wfe</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[(</span><span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">wvl_min</span><span class="p">,</span> <span class="n">wvl_max</span><span class="p">],</span> <span class="p">{</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="s">&#39;nm&#39;</span><span class="p">})],</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;wfe&#39;</span><span class="p">,</span>
                                 <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">wfe_max</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;WFE for optics.Lens exceeds 0.5 waves. ATF generally invalid for large WFE.&#39;</span><span class="p">)</span>
        <span class="n">defocus_max</span> <span class="o">=</span> <span class="mf">3.5</span> <span class="o">*</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="n">wvl_mean</span> <span class="o">*</span> <span class="n">fno</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wfe_allowed</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">wfe_max</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="c"># Calculate defocus positions in mm</span>
        <span class="n">z_defocus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">defocus_max</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># 10 defocus positions in mm</span>
        <span class="c"># Turn this into an identity DataArray</span>
        <span class="n">z_defocus</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">z_defocus</span><span class="p">,</span> <span class="s">&#39;fldz&#39;</span><span class="p">)</span>
        <span class="c"># Now calculate the wfe values for the different defocus positions, bearing in mind that the wfe could</span>
        <span class="c"># have been given with up to 3 axes (wavelength, field position and field orientation)</span>
        <span class="c"># Axes of wfe should only include wavelength and field position. Those axes must now</span>
        <span class="c"># be complemented with a defocus axis.</span>
        <span class="c"># Calculate the RMS wavefront error due to defocus</span>
        <span class="n">rms_wfe_defocus</span>  <span class="o">=</span> <span class="n">z_defocus</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.5</span> <span class="o">*</span> <span class="mf">8.0</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">wvl</span> <span class="o">*</span> <span class="n">fno</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>  <span class="c"># Shannon formula, wvl and fldz axes</span>
        <span class="n">rms_wfe_defocus</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;wfe&#39;</span>
        <span class="n">rms_wfe_defocus</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">}</span>
        <span class="c"># Combine this in quadrature w, but first need to harmonise rms_wfe_defocus with wfe</span>
        <span class="n">rms_wfe_aberr</span><span class="p">,</span> <span class="n">rms_wfe_defocus</span> <span class="o">=</span> <span class="n">xd_harmonise_interp</span><span class="p">([</span><span class="n">wfe</span><span class="p">,</span> <span class="n">rms_wfe_defocus</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_aberr</span> <span class="o">=</span> <span class="n">rms_wfe_aberr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_defocus</span> <span class="o">=</span> <span class="n">rms_wfe_defocus</span>
        <span class="c"># Calculate total wfe as quadrature sum of aberration and defocus wfe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_aberr</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_defocus</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="c"># Set up attributes of the rms_wfe_total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_total</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_total</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rms_wfe_aberr</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_total</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rms_wfe_defocus</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="c"># Now compute the multidimensional MTF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mtf_obs_wfe</span><span class="p">()</span>
        <span class="c"># The MTF is a function of spatial frequency, wavelength and defocus (always), with possible extra dimensions</span>
        <span class="c"># of field position (fldx, fldy) and field orientation (fldo).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">attrs</span>  <span class="c"># attach user-defined attribute dictionary</span>

</div>
<div class="viewcode-block" id="Lens.mtf_obs_wfe"><a class="viewcode-back" href="../packages.html#optics.Lens.mtf_obs_wfe">[docs]</a>    <span class="k">def</span> <span class="nf">mtf_obs_wfe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the multidimensional MTF of a Lens class object</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            - optics.atf which shows the method and formula by which the aberration/defocus MTF degradation is</span>
<span class="sd">                computed.</span>
<span class="sd">            - optics.mtf_obs shows documents the typical calculation formulas for obscured MTF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># Compute the obscured MTF</span>
            <span class="c"># Calculate w at each matrix site</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fno</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spf</span> <span class="o">*</span> <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span>
            <span class="c"># print w</span>
            <span class="n">the_mtf</span> <span class="o">=</span> <span class="p">(</span><span class="n">autocorr_circle</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">crosscorr_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span>
                       <span class="n">autocorr_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))</span>
            <span class="n">the_mtf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">the_mtf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="c"># print the_mtf</span>
            <span class="c"># Recreate a data array</span>
            <span class="n">the_mtf</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">the_mtf</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;mtf&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># Compute the unobscured MTF</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fno</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spf</span> <span class="o">*</span> <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span>
            <span class="n">csphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">the_mtf</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="n">csphi</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">the_mtf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">the_mtf</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c"># Set MTF to zero if nan</span>
        <span class="c"># Compute the aberration/defocus transfer function (ATF)</span>
        <span class="c"># Find the cutoff frequencies</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fno</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span>  <span class="c"># cy/mm</span>
        <span class="c"># Compute the spatial frequencies as a fraction of the cutoff (relative spf)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spf</span> <span class="o">/</span> <span class="n">cutoff</span>
        <span class="c"># Compute the ATF according to Shannon</span>
        <span class="n">the_atf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rms_wfe_total</span> <span class="o">/</span> <span class="mf">0.18</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="c"># Values above 1.0 are not possible, so set those to 1.0</span>
        <span class="n">the_atf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">the_atf</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="c"># Take the product of the MTF and the ATF</span>
        <span class="n">the_mtf</span> <span class="o">=</span> <span class="n">the_mtf</span> <span class="o">*</span> <span class="n">the_atf</span>
        <span class="n">the_mtf</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># MTF is a unitless quantity</span>
        <span class="c"># Merge Attributes of contributing axes</span>
        <span class="n">the_mtf</span><span class="p">[</span><span class="s">&#39;spf&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spf</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="n">the_mtf</span><span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="n">the_mtf</span><span class="p">[</span><span class="s">&#39;fldz&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="s">&#39;mm&#39;</span><span class="p">,</span> <span class="s">&#39;long_name&#39;</span><span class="p">:</span> <span class="n">long_name</span><span class="p">[</span><span class="s">&#39;fldz&#39;</span><span class="p">]})</span>
        <span class="n">the_mtf</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;mtf&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mtf</span> <span class="o">=</span> <span class="n">the_mtf</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efl</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fno</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;Attributes :&#39;</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span>
                <span class="nb">repr</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)]))</span>
</pre></div></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, D Griffith, A Ramkilowan.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>