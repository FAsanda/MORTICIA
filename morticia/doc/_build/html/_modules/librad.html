

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librad &mdash; MORTICIA 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="MORTICIA 1.0 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> MORTICIA</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how_to_use.html">How to use MORTICIA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../how_to_use.html#morticia-dependencies">MORTICIA Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how_to_use.html#installation-and-requirements">Installation and Requirements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../styleguide.html">The MORTICIA Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#to-pep-8-or-not-to-pep-8">To PEP-8 or not to PEP-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#code-layout">Code Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#import-statements">Import Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#whitespace">Whitespace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#comments">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#documentation-strings-docstrings">Documentation Strings (docstrings)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#naming-conventions">Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#pep-257">PEP-257</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#from-conventions-section"><em>From</em> Conventions Section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../styleguide.html#general-terminology-and-conventions">General Terminology and Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../for_developers.html">For the Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../for_developers.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#sensor-package">Sensor Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#radiometry-package">Radiometry Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages.html#scene-package">Scene Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ChapLibRadtranODandPathRadiance.html">Transmittance and Path Radiance in libRadtran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01a-SpectralChannelsAndFilters.html">IPython Notebook and Sphinx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../01a-SpectralChannelsAndFilters.html#a-spectralchannelsandfilters-ipython-notebook">01a-SpectralChannelsAndFilters IPython Notebook</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">MORTICIA</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>librad</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for librad</h1><div class="highlight"><pre>
<span class="n">__author__</span> <span class="o">=</span> <span class="s">&#39;DGriffith&#39;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> *--------------------------------------------------------------------</span>
<span class="sd"> *</span>
<span class="sd"> * This file is part of MORTICIA.</span>
<span class="sd"> * Copyright (c) 2015-2016 by Derek Griffith and Ari Ramkiloawn</span>
<span class="sd"> *</span>
<span class="sd"> *</span>
<span class="sd"> * This program is free software; you can redistribute it and/or</span>
<span class="sd"> * modify it under the terms of the GNU General Public License</span>
<span class="sd"> * as published by the Free Software Foundation; either version 2</span>
<span class="sd"> * of the License, or (at your option) any later version.</span>
<span class="sd"> *</span>
<span class="sd"> * This program is distributed in the hope that it will be useful,</span>
<span class="sd"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="sd"> * GNU General Public License for more details.</span>
<span class="sd"> *</span>
<span class="sd"> * You should have received a copy of the GNU General Public License</span>
<span class="sd"> * along with this program; if not, write to the Free Software</span>
<span class="sd"> * Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="sd"> * Boston, MA 02111-1307, USA.</span>
<span class="sd"> *--------------------------------------------------------------------&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: librad</span>
<span class="sd">    :platform: Unix only if running of libRadtran/uvspec is required. Also Windows for setting up uvspec cases.</span>
<span class="sd">    :synopsis: This module provides access to libRadtran through the uvspec utility. For information on libRadtran go to</span>
<span class="sd">    http://www.libtradtran.org</span>
<span class="sd">Some of the code within this module and code imported by the module is provided with libRadtran in the src_py</span>
<span class="sd">directory. In order to run libRadtran cases it is necessary to have libRadtran installed on your computer.</span>
<span class="sd">There is no Windows-native version of libRadtran, so that generally implies that you are running on a Unix/Linux,</span>
<span class="sd">however, reading and writing of uvspec input files, as well as reading of uvspec output files is possible on any</span>
<span class="sd">platform.</span>

<span class="sd">Important note concerning the uu output:</span>
<span class="sd">The uu field in the libRadtran/uvspec Case object contains the output radiances. In the most general case, this is a</span>
<span class="sd">5-dimensional numpy array, with axes in the following order:</span>
<span class="sd">1) umu - the cosine of the propagation zenith angles, where umu=1 is looking downward</span>
<span class="sd">2) phi - the propagation azimuth angle, where 180 deg is viewing northwards</span>
<span class="sd">3) spectral variable (&#39;wavelength&#39;/&#39;wvl&#39;, &#39;wavenumber&#39;/&#39;wvn&#39; and &#39;lambda&#39; are alternative names)</span>
<span class="sd">4) altitudes of viewing point (&#39;zout&#39;, &#39;zout_sea&#39;, &#39;pressure&#39;/&#39;p&#39; and &#39;cth&#39; are alternative level variables</span>
<span class="sd">5) stokes polarisation component (up to 4 stokes components, called I, Q, U and V)</span>

<span class="sd">By &#39;propagation&#39; is meant the direction in which light is travelling, which is 180 degrees different from the</span>
<span class="sd">&#39;viewing&#39; direction.</span>

<span class="sd">Trailing singleton dimensions are dropped. That is, if there is only one stokes component, then uu has only 4</span>
<span class="sd">dimensions. If there is also only one level output (zout etc.), then uu has only 3 dimensions and so forth.</span>

<span class="sd">Leading and sandwiched singleton dimensions are not dropped in the current implementation. Dropping of singleton</span>
<span class="sd">dimensions can break existing code.</span>

<span class="sd">The relevant code here is taken from libRadtran version 2.0</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># TODO Reading of montecarlo (mystic/mc) output files, particularly:</span>
<span class="c"># mc.flx.spc - spectral irradiance, actinic flux at levels</span>
<span class="c"># mc.rad.spc - spectral radiance at levels</span>
<span class="c"># TODO Dealing with exceptions, warnings. Keywords missing from the options library etc.</span>
<span class="c"># TODO dealing with setting of units based on whatever is known about inputs/outputs, thermal is W/m^2/cm^-1</span>


<span class="n">_isfloatnum</span> <span class="o">=</span> <span class="s">&#39;^[-+]?[0-9]*</span><span class="se">\\</span><span class="s">.?[0-9]+([eE][-+]?[0-9]+)?$&#39;</span>  <span class="c"># regular expression for matching tokens to floating point</span>

<span class="kn">import</span> <span class="nn">writeLex</span>  <span class="c"># This imports all the libradtran option definitions</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">easygui</span>  <span class="c"># For file open dialogs</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xray</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">morticia.moglo</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">morticia.tools.xd</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>  <span class="c">#Used in RadEnv constructor</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">uvsOptions</span> <span class="o">=</span> <span class="n">writeLex</span><span class="o">.</span><span class="n">loadOptions</span><span class="p">()</span>  <span class="c"># Load all options into a global dictionary of uvspec option specifications.</span>

<span class="c"># The following dictionary provides units for some of the source solar files provided with libRadtran</span>
<span class="n">sourceSolarUnits</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;apm_0_5nm&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;apm_1nm&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;atlas_plus_modtran&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;atlas_plus_modtran_ph&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;count/s&#39;</span><span class="p">,</span> <span class="s">&#39;cm^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>  <span class="c"># count photons</span>
    <span class="s">&#39;atlas2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;atlas3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;fu&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">],</span>  <span class="c"># in band</span>
    <span class="s">&#39;kato&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">],</span>  <span class="c"># in band</span>
    <span class="s">&#39;kurudz_0.1nm.dat&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;kurudz_1.0nm.dat&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;NewGuey2003.dat&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">],</span>
    <span class="s">&#39;Thekaekara.dat&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c"># Units generally depend on the units in the solar flux file, but may be dictated by the correlated-k band model</span>
<span class="n">uvspecOutVars</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;lambda&#39;</span><span class="p">:</span> <span class="s">&#39;Wavelength [nm]&#39;</span><span class="p">,</span>  <span class="c"># Cannot be used in Python because lambda is a keyword use &#39;wvl</span>
    <span class="s">&#39;wavelength&#39;</span><span class="p">:</span> <span class="s">&#39;Wavelength [nm]&#39;</span><span class="p">,</span> <span class="c"># scalar per line</span>
    <span class="s">&#39;wavenumber&#39;</span><span class="p">:</span> <span class="s">&#39;Wavenumber [cm^1]&#39;</span><span class="p">,</span>  <span class="c"># abbreviate to wvn</span>
    <span class="s">&#39;wvn&#39;</span><span class="p">:</span> <span class="s">&#39;Wavenumber [cm^-1]&#39;</span><span class="p">,</span>
    <span class="s">&#39;wvl&#39;</span><span class="p">:</span> <span class="s">&#39;Wavelength [nm]&#39;</span><span class="p">,</span>
    <span class="s">&#39;edir&#39;</span><span class="p">:</span> <span class="s">&#39;Direct beam irradiance (same unit as extraterrestrial irradiance, e.g mW/m^2/nm if using the &quot;atlas3&quot; spectrum in the /data/solar_flux/ directory.)&#39;</span><span class="p">,</span>
    <span class="s">&#39;edn&#39;</span><span class="p">:</span> <span class="s">&#39;Diffuse downwelling irradiance, i.e. total minus direct beam (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;eup&#39;</span><span class="p">:</span> <span class="s">&#39;Diffuse upwelling irradiance (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;uavg&#39;</span><span class="p">:</span> <span class="s">&#39;The mean intensity. Proportional to the actinic flux: To obtain the actinic flux, multiply the mean intensity by 4 pi (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;uavgdir&#39;</span><span class="p">:</span> <span class="s">&#39;Direct beam contribution to the mean intensity. (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;uavgdn&#39;</span><span class="p">:</span> <span class="s">&#39;Diffuse downward radiation contribution to the mean intensity. (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;uavgup&#39;</span><span class="p">:</span> <span class="s">&#39;Diffuse upward radiation contribution to the mean intensity. (same unit as edir).&#39;</span><span class="p">,</span>
    <span class="s">&#39;umu&#39;</span><span class="p">:</span> <span class="s">&#39;Cosine of the zenith angles for sightline radiance (intensity) calculations.&#39;</span><span class="p">,</span>  <span class="c"># This is a vector of values</span>
    <span class="s">&#39;u0u&#39;</span><span class="p">:</span> <span class="s">&#39;The azimuthally averaged intensity at n_umu user specified angles umu. (units of e.g. mW/m^2/nm/sr if using the &quot;atlas3&quot; spectrum in the /data/solar_flux/ directory.)&#39;</span><span class="p">,</span> <span class="c"># vector</span>
    <span class="s">&#39;uu&#39;</span><span class="p">:</span> <span class="s">&#39;The radiance (intensity) at umu and phi user specified angles (unit e.g. mW/m^2/nm/sr if using the &quot;atlas3&quot; spectrum in the /data/solar_flux/ directory.)&#39;</span><span class="p">,</span> <span class="c"># vector</span>
    <span class="s">&#39;uu_down&#39;</span><span class="p">:</span> <span class="s">&#39;The downwelling radiances (intensity) at cmu and phi angles (unit e.g. mW/m^2/nm/sr if using the &quot;atlas3&quot; spectrum in the /data/solar_flux? directory.)&#39;</span><span class="p">,</span> <span class="c"># vector</span>
    <span class="s">&#39;uu_up&#39;</span><span class="p">:</span> <span class="s">&#39;The upwelling radiances (intensity) at cmu and phi angles (unit e.g. mW/m^2/nm/sr if using the &quot;atlas3&quot; spectrum in the /data/solar_flux/ directory.)&#39;</span><span class="p">,</span> <span class="c"># vector</span>
    <span class="s">&#39;cmu&#39;</span><span class="p">:</span> <span class="s">&#39;Computational polar angles from polradtran&#39;</span><span class="p">,</span>
    <span class="s">&#39;down_fluxI&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) downward (down flux) irradiances (Stokes I component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;up_fluxI&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) upward (up flux) irradiances (Stokes I component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;down_fluxQ&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) downward (down flux) irradiances (Stokes Q component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;up_fluxQ&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) upward (up flux) irradiances (Stokes Q component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;down_fluxU&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) downward (down flux) irradiances (Stokes U component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;up_fluxU&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) upward (up flux) irradiances (Stokes U component). Same units as extraterrestrial irradiance&#39;</span><span class="p">,</span>
    <span class="s">&#39;down_fluxV&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) downward (down flux) irradiances (Stokes V component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;up_fluxV&#39;</span><span class="p">:</span> <span class="s">&#39;The total (direct+diffuse) upward (up flux) irradiances (Stokes V component). Same units as extraterrestrial irradiance.&#39;</span><span class="p">,</span>
    <span class="s">&#39;eglo&#39;</span><span class="p">:</span> <span class="s">&#39;Global downwelling irradiance&#39;</span><span class="p">,</span>
    <span class="s">&#39;enet&#39;</span><span class="p">:</span> <span class="s">&#39;Global downwelling minus upwelling (net downward irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;esum&#39;</span><span class="p">:</span> <span class="s">&#39;Global downwelling plus upwelling&#39;</span><span class="p">,</span>
    <span class="s">&#39;fdir&#39;</span><span class="p">:</span> <span class="s">&#39;Direct actinic flux (scalar irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;fglo&#39;</span><span class="p">:</span> <span class="s">&#39;Global actinic flux (scalar irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;fdn&#39;</span><span class="p">:</span> <span class="s">&#39;Downwelling actinic flux (scalar irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;fup&#39;</span><span class="p">:</span> <span class="s">&#39;Upwelling actinic flux (scalar irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;uavgglo&#39;</span><span class="p">:</span> <span class="s">&#39;Total (global) mean diffuse intensity (radiance) = actinic flux/4pi&#39;</span><span class="p">,</span>
    <span class="s">&#39;f&#39;</span><span class="p">:</span> <span class="s">&#39;Actinic flux (scalar irradiance)&#39;</span><span class="p">,</span>
    <span class="s">&#39;sza&#39;</span><span class="p">:</span> <span class="s">&#39;Solar zenith angle [deg]&#39;</span><span class="p">,</span>
    <span class="s">&#39;n_air&#39;</span><span class="p">:</span> <span class="s">&#39;Air refractive index&#39;</span><span class="p">,</span>
    <span class="s">&#39;zout&#39;</span><span class="p">:</span> <span class="s">&#39;Altitude above ground [km]&#39;</span><span class="p">,</span>
    <span class="s">&#39;zout_sea&#39;</span><span class="p">:</span> <span class="s">&#39;Altitude above sea level [km]&#39;</span><span class="p">,</span>
    <span class="s">&#39;sph_alb&#39;</span><span class="p">:</span> <span class="s">&#39;Spherical albedo of the complete atmosphere&#39;</span><span class="p">,</span>
    <span class="s">&#39;albedo&#39;</span><span class="p">:</span> <span class="s">&#39;Albedo&#39;</span><span class="p">,</span>
    <span class="s">&#39;heat&#39;</span><span class="p">:</span> <span class="s">&#39;Heating rate in K/day&#39;</span><span class="p">,</span>
    <span class="s">&#39;n_xxx&#39;</span><span class="p">:</span> <span class="s">&#39;Number density of gas xxx [cm^-3]&#39;</span><span class="p">,</span>
    <span class="s">&#39;rho_xxx&#39;</span><span class="p">:</span> <span class="s">&#39;Mass density of gas xxx [kg/m^3]&#39;</span><span class="p">,</span>
    <span class="s">&#39;mmr_xxx&#39;</span><span class="p">:</span> <span class="s">&#39;Mass mixing ratio of gas xxx [kg/kg]&#39;</span><span class="p">,</span>
    <span class="s">&#39;vmr_xxx&#39;</span><span class="p">:</span> <span class="s">&#39;Volume mixing ratio of gas xxx [m^3/m^3]&#39;</span><span class="p">,</span>
    <span class="s">&#39;p&#39;</span><span class="p">:</span> <span class="s">&#39;Pressure [hPa]&#39;</span><span class="p">,</span>
    <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="s">&#39;Temperature [K]&#39;</span><span class="p">,</span>
    <span class="s">&#39;T_d&#39;</span><span class="p">:</span> <span class="s">&#39;Dewpoint temperature [K]&#39;</span><span class="p">,</span>
    <span class="s">&#39;T_sur&#39;</span><span class="p">:</span> <span class="s">&#39;Surface temperature [K]&#39;</span><span class="p">,</span>
    <span class="s">&#39;theta&#39;</span><span class="p">:</span> <span class="s">&#39;Potential temperature [K]&#39;</span><span class="p">,</span>
    <span class="s">&#39;theta_e&#39;</span><span class="p">:</span> <span class="s">&#39;Equivalent potential temperature [K]&#39;</span><span class="p">,</span>
    <span class="s">&#39;rh&#39;</span><span class="p">:</span> <span class="s">&#39;Relative humidity over water [%]&#39;</span><span class="p">,</span>
    <span class="s">&#39;rh_ice&#39;</span><span class="p">:</span> <span class="s">&#39;Relative humidity over ice [%]&#39;</span><span class="p">,</span>
    <span class="s">&#39;c_p&#39;</span><span class="p">:</span> <span class="s">&#39;Specific heat capacity of the air&#39;</span><span class="p">,</span>
    <span class="s">&#39;CLWC&#39;</span><span class="p">:</span> <span class="s">&#39;Cloud liquid water content [kg/kg]&#39;</span><span class="p">,</span>
    <span class="s">&#39;CLWD&#39;</span><span class="p">:</span> <span class="s">&#39;Cloud liquid water density [g/m^3]&#39;</span><span class="p">,</span>
    <span class="s">&#39;CIWC&#39;</span><span class="p">:</span> <span class="s">&#39;Cloud ice water content [kg/kg]&#39;</span><span class="p">,</span>
    <span class="s">&#39;CIWD&#39;</span><span class="p">:</span> <span class="s">&#39;Cloud ice water density [g/m^3]&#39;</span><span class="p">,</span>
    <span class="s">&#39;TCC&#39;</span><span class="p">:</span> <span class="s">&#39;Total cloud cover [0-1]&#39;</span><span class="p">,</span>
    <span class="s">&#39;cth&#39;</span><span class="p">:</span> <span class="s">&#39;Cloud top height [km]&#39;</span>
<span class="p">}</span>
<span class="c">#  the following gas species can appear for _xxx in the above list of output variables.</span>
<span class="n">gasSpecies</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;air&#39;</span><span class="p">,</span> <span class="s">&#39;O3&#39;</span><span class="p">,</span> <span class="s">&#39;O2&#39;</span><span class="p">,</span> <span class="s">&#39;H2O&#39;</span><span class="p">,</span> <span class="s">&#39;CO2&#39;</span><span class="p">,</span> <span class="s">&#39;NO2&#39;</span><span class="p">,</span> <span class="s">&#39;BRO&#39;</span><span class="p">,</span> <span class="s">&#39;OCLO&#39;</span><span class="p">,</span> <span class="s">&#39;HCHO&#39;</span><span class="p">,</span> <span class="s">&#39;O4&#39;</span><span class="p">]</span>

<span class="c"># Insert the additional items programatically</span>
<span class="n">outVars</span> <span class="o">=</span> <span class="n">uvspecOutVars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c"># first make a copy</span>
<span class="k">for</span> <span class="n">thisVar</span> <span class="ow">in</span> <span class="n">uvspecOutVars</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">thisVar</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s">&#39;_xxx&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">gas</span> <span class="ow">in</span> <span class="n">gasSpecies</span><span class="p">:</span>
            <span class="n">outVars</span><span class="p">[</span><span class="n">thisVar</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;xxx&#39;</span><span class="p">,</span> <span class="n">gas</span><span class="p">)]</span> <span class="o">=</span> <span class="n">outVars</span><span class="p">[</span><span class="n">thisVar</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;xxx&#39;</span><span class="p">,</span> <span class="n">gas</span><span class="p">)</span>  <span class="c"># insert in copy</span>
        <span class="k">del</span> <span class="n">outVars</span><span class="p">[</span><span class="n">thisVar</span><span class="p">]</span>  <span class="c"># delete the template entry</span>
<span class="n">uvspecOutVars</span> <span class="o">=</span> <span class="n">outVars</span>  <span class="c"># copy the updated dict back to the original</span>

<span class="c"># For the output_user option, only certain variables are allowed as first and second index variables,</span>
<span class="c"># These are wavelength (lambda, wvn), zout, zout_sea, p (pressure)</span>
<span class="c"># The only two index variables that are allowed together is one height variable and one wavelength/number variable</span>
<span class="c"># A height as well as a wavelength/number output should only be specified if there are both multiple</span>
<span class="c"># wavelengths and multiple output heights. FOr the TZS solver, the cloud top height (cth) may be index.</span>
<span class="n">indexVars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;lambda&#39;</span><span class="p">,</span> <span class="s">&#39;wavelength&#39;</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="s">&#39;wvn&#39;</span><span class="p">,</span> <span class="s">&#39;zout&#39;</span><span class="p">,</span> <span class="s">&#39;zout_sea&#39;</span><span class="p">,</span> <span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="s">&#39;cth&#39;</span><span class="p">]</span>

<span class="c"># Define a regexp for determining if a token of the zout keyword is a single level</span>
<span class="c"># It is a single level if it is either a floating point number or the words boa, sur, cpt or toa (for surface,</span>
<span class="c"># cold point tropopause and top of atmosphere)</span>
<span class="n">re_isSingleOutputLevel</span> <span class="o">=</span> <span class="s">&#39;(^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$)|(^boa$)|(^sur$)|(^surface$)|(^cpt$)|(^toa$)&#39;</span>

<div class="viewcode-block" id="Case"><a class="viewcode-back" href="../radpack.html#librad.Case">[docs]</a><span class="k">class</span> <span class="nc">Case</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class which encapsulates a run case of libRadtran/uvspec.</span>
<span class="sd">    This class has methods to read libRadtran/uvspec input files, write uvspec input files, run uvspec in parallel on</span>
<span class="sd">    multiple compute nodes and read uvspec output files. An important use-case is that of reading a uvspec input</span>
<span class="sd">    file called the &quot;base case&quot;, altering the parameters of particular option keywords and then running the case</span>
<span class="sd">    and reading the outputs. This class is also used by the RadEnv class which encapsulates a radiant environment.</span>
<span class="sd">    Construction of radiant environment maps typically requires running an array of librad.Case instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Definitions of some of the possible uvspec output variables</span>

<div class="viewcode-block" id="Case.__init__"><a class="viewcode-back" href="../radpack.html#librad.Case.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">casename</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">optionlist</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Instantiate a libRadtran/uvspec case, typically by reading a uvspec .INP file.</span>

<span class="sd">        :param casename: A user-defined name for the libRadtran/uvspec case</span>
<span class="sd">        :param filename: An optional filename from which to read the libRadtran/uvspec input</span>
<span class="sd">        :param optionlist: A list of option keywords and parameteres (tokens). The keyword existence</span>
<span class="sd">            is verified. Besides that, no error checking is performed automatically.</span>
<span class="sd">        :return: None</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Implement checking of uvspec input keyword tokens (parameters)</span>

<span class="sd">        &gt;&gt;&gt; # Read a libRadtran/uvspec case from a .INP file and display the expanded input</span>
<span class="sd">        &gt;&gt;&gt; import morticia.rad.librad as librad</span>
<span class="sd">        &gt;&gt;&gt; libRadCase = librad.Case(filename=&#39;./examples/UVSPEC_AEROSOL.INP&#39;)  # Read uvspec input and expand includes, if any</span>
<span class="sd">        &gt;&gt;&gt; print libRadCase   # This prints the uvspec input file, compare to contents of UVSPEC_AEROSOL.INP</span>
<span class="sd">        atmosphere_file ../data/atmmod/afglus.dat</span>
<span class="sd">        source solar ../data/solar_flux/atlas_plus_modtran</span>
<span class="sd">        mol_modify O3 300. DU</span>
<span class="sd">        day_of_year 170</span>
<span class="sd">        albedo 0.2</span>
<span class="sd">        sza 32.0</span>
<span class="sd">        rte_solver disort</span>
<span class="sd">        number_of_streams 6</span>
<span class="sd">        wavelength 299.0 341.0</span>
<span class="sd">        slit_function_file ../examples/TRI_SLIT.DAT</span>
<span class="sd">        spline 300 340 1</span>
<span class="sd">        quiet</span>
<span class="sd">        aerosol_vulcan 1</span>
<span class="sd">        aerosol_haze 6</span>
<span class="sd">        aerosol_season 1</span>
<span class="sd">        aerosol_visibility 20.0</span>
<span class="sd">        aerosol_angstrom 1.1 0.2</span>
<span class="sd">        aerosol_modify ssa scale 0.85</span>
<span class="sd">        aerosol_modify gg set 0.70</span>
<span class="sd">        aerosol_file tau ../examples/AERO_TAU.DAT</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">casename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_txt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># options is a list [option_name (string), option_tokens (list of strings),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># option keyword parameters (tokens)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optionobj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># option object from writeLex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filorigin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&#39;disort&#39;</span>  <span class="c"># default, modified b y the rte_solver option keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="s">&#39;edir&#39;</span><span class="p">,</span> <span class="s">&#39;edn&#39;</span><span class="p">,</span> <span class="s">&#39;eup&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdir&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdn&#39;</span><span class="p">,</span> <span class="s">&#39;uavgup&#39;</span><span class="p">]</span>  <span class="c"># default output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># wavelengths, wavenumbers and output levels difficult to ascertain to start with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wvn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sza</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c"># default solar zenith angle for this case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># If no zout (or equivalent) is given, uvspec produces output at the surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># altitudes above seal level, same as zout unless ground &#39;altitude&#39; provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pressure_out</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># Only populated if pressure_out keyword is given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># set with the output_user keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">=</span> <span class="s">&#39;radiance&#39;</span> <span class="c"># default is radiances and irradiances in units determined by input solar file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># &#39;solar&#39; or &#39;thermal&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_file</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># TOA irradiance source file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># number of zenith angles (actually cosine of zenith angle)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umu</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># zenith angles for radiance calculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c"># This will be populated if there is radiance data output by the case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># number of azimuth radiance angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># np.zeros(1)  # azimuth angles for radiance calculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Assume only one output level, unless zout/zout_sea/pressure_out keyword is used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_out</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;boa&#39;</span><span class="p">]</span>  <span class="c"># Tokens provided on an output level keyword (zout, zout_sea, pressure_out), default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">=</span> <span class="s">&#39;zout&#39;</span>  <span class="c"># Assume that type of levels out data is altitude above surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>  <span class="c"># number of wavelengths is difficult to ascertain to start with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># default number of stokes parameters for polradtran</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">]</span>  <span class="c"># default is to compute intensity component only (all solvers, including polradtran)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radND</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># N-dimensional radiance data (umu, phi, wvn, zout, stokes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mW&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;nm&#39;</span><span class="p">]</span>  <span class="c"># radiance/irradiance units, could be K for brightness temperatures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Default surface (ground) height above sea level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;reptran&#39;</span>  <span class="c"># REPTRAN is the default molecular absorption parametrization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;coarse&#39;</span>  <span class="c"># The coarse 15 cm^-1 spectral resolution is the default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reptran_channel</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># Used with mol_abs_param keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_channels</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c">#  These are the spectral channels, such as for &#39;kato&#39;, &#39;fu&#39; band models.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;wvl&#39;</span>  <span class="c"># By default RT calculations are spectral, with wavelength as the variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_index</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># set by &#39;wavelength_index&#39; keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_index_range</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># for use where range() would be applicable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>  <span class="c"># Default is to output spectral data. See output_process in uvspec manual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_ice_clouds</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Default, unless discovered otherwise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_water_clouds</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># ditto</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># either water or ice clouds</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="p">:</span>
                <span class="c"># Open a dialog to get the filename</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">easygui</span><span class="o">.</span><span class="n">fileopenbox</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s">&#39;Please select a uvspec input file.&#39;</span><span class="p">,</span> <span class="n">filetypes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;*.INP&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&#39;.inp&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">+=</span> <span class="s">&#39;.INP&#39;</span>
            <span class="n">opdata</span><span class="p">,</span> <span class="n">line_nos</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">Case</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infile</span> <span class="o">=</span> <span class="n">path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;.OUT&#39;</span>
            <span class="c"># option_object, source_file_nos (filename, line_number)]</span>
            <span class="c"># Process the results into lists of options</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">optnumber</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opdata</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># the option keyword (string)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c"># The tokens following the keyword (list of strings)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filorigin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_nos</span><span class="p">[</span><span class="n">optnumber</span><span class="p">])</span>  <span class="c"># The file origin of this keyword</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">optnumber</span><span class="p">]</span> <span class="ow">in</span> <span class="n">uvsOptions</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optionobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvsOptions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">optnumber</span><span class="p">]])</span>  <span class="c"># The option object (dict lookup)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Warning, keyword option &#39;</span> <span class="o">+</span>  <span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39; not found in options library.&#39;</span><span class="p">)</span>
                <span class="c"># Make any possible preparations for occurance of this keyword</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_keyword</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>  <span class="c"># set the name as the basname of the filename, excluding the extension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infile</span><span class="p">)[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="c">#TODO Build the case from the option list ?</span>
</div>
    <span class="k">def</span> <span class="nf">prepare_for_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># First token gives the solver</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="n">thesolver</span> <span class="k">for</span> <span class="n">thesolver</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;disort&#39;</span><span class="p">,</span> <span class="s">&#39;disort2&#39;</span><span class="p">,</span> <span class="s">&#39;sdisort&#39;</span><span class="p">,</span>
                                                           <span class="s">&#39;spsdisort&#39;</span><span class="p">,</span> <span class="s">&#39;fdisort1&#39;</span><span class="p">,</span> <span class="s">&#39;fdisort2&#39;</span><span class="p">]]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="s">&#39;edir&#39;</span><span class="p">,</span> <span class="s">&#39;edn&#39;</span><span class="p">,</span> <span class="s">&#39;eup&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdir&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdn&#39;</span><span class="p">,</span> <span class="s">&#39;uavgup&#39;</span><span class="p">]</span>  <span class="c"># default output</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="n">thesolver</span> <span class="k">for</span> <span class="n">thesolver</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;twostr&#39;</span><span class="p">,</span><span class="s">&#39;rodents&#39;</span><span class="p">]]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">,</span> <span class="s">&#39;edir&#39;</span><span class="p">,</span> <span class="s">&#39;edn&#39;</span><span class="p">,</span> <span class="s">&#39;eup&#39;</span><span class="p">,</span> <span class="s">&#39;uavg&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;polradtran&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_polradtran</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;sslidar&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;center_of_range&#39;</span><span class="p">,</span> <span class="s">&#39;number_of_photons&#39;</span><span class="p">,</span> <span class="s">&#39;lidar_ratio&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;montecarlo&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&#39;mystic&#39;</span>  <span class="c"># Same as mystic, use mystic</span>

<div class="viewcode-block" id="Case.prepare_for_source"><a class="viewcode-back" href="../radpack.html#librad.Case.prepare_for_source">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare for source, particularly units of various kinds, depending on the source.</span>
<span class="sd">        libRadtran/uvspec source options are mainly &#39;solar&#39; and &#39;thermal&#39; with some additional options</span>
<span class="sd">        for units.</span>

<span class="sd">        :param tokens: uvspec &#39;source&#39; keyword option parameters (tokens)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO : More work required here - see libRadtran manual under source keyword</span>
        <span class="c"># TODO : Also need to verify default radiance output units (mW/m^2/sr/nm or W/m^2/sr/nm)</span>
        <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;solar&#39;</span><span class="p">:</span>  <span class="c"># dealing with solar spectrum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="s">&#39;solar&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># solar source file provided</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># extract the filename only</span>
                <span class="c"># try to establish the radiometric units based on the filename</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_file</span> <span class="ow">in</span> <span class="n">sourceSolarUnits</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="n">sourceSolarUnits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source_file</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;per_nm&#39;</span><span class="p">:</span> <span class="s">&#39;nm&#39;</span><span class="p">,</span> <span class="s">&#39;per_cm-1&#39;</span><span class="p">:</span><span class="s">&#39;cm^-1&#39;</span><span class="p">,</span>
                                      <span class="s">&#39;per_band&#39;</span><span class="p">:</span> <span class="s">&#39;&#39;</span><span class="p">}[</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;thermal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="s">&#39;thermal&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">==</span> <span class="s">&#39;radiance&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;m^2&#39;</span><span class="p">,</span> <span class="s">&#39;cm^-1&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Case.prepare_for_mol_abs_param"><a class="viewcode-back" href="../radpack.html#librad.Case.prepare_for_mol_abs_param">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_mol_abs_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make preparations for the desired molecular absorption parametrization. There are various</span>
<span class="sd">        molecular absorption options in libRadtran/uvspec and the options will certainly evolve.</span>
<span class="sd">        The default mode is to perform a spectral calculation (fine wavelength grid) with output</span>
<span class="sd">        of spectral radiances and irradiances. Some of the other modes, such as `crs` also output</span>
<span class="sd">        spectral data. The `crs` mode actually switches off molecular line absorption and considers</span>
<span class="sd">        only spectrally continuous scattering and absorption. This is really only good for the UV/blue</span>
<span class="sd">        spectrum. The `reptran_channel` mode and the correlated-k modes (`kato` variants, `fu`, `avhrr_kratz`</span>
<span class="sd">        and `lowtran`/`sbdart`) do not produce spectral radiances and irradiances. They produce band quantities</span>
<span class="sd">        which may even be summed using the `output_process sum` directive. A sub-range of correlated-k</span>
<span class="sd">        bins/channels can be selected using the `wavelength_index` directive.</span>

<span class="sd">        See the libRadtran manual for further information on the relevant options.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;reptran&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;reptran&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;wvl&#39;</span>  <span class="c"># RT calculations are spectral as opposed to band</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;coarse&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;coarse&#39;</span>
                <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;medium&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;medium&#39;</span>
                <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;fine&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;fine&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Invalid REPTRAN spectral resolution qualifier found in mol_abs_param directive.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;crs&#39;</span><span class="p">:</span>  <span class="c"># This option actually switches off line-absorption and only considers continua</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;crs&#39;</span>  <span class="c"># Only good for UV really, but will output in any spectral region</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;wvn&#39;</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;reptran_channel&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;reptran_channel&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reptran_channel</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="c"># Not sure if spectral or band-integrated quantities are provided</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;kato&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;kato&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># band integrated quantity out</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;kato2&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;kato2&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># band integrated quantity</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;kato2.96&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;kato2.96&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># band integrated quanitity</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;fu&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;fu&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># band integrated quantity</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;avhrr_kratz&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;avhrr_kratz&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># band integrated quantity</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;lowtran&#39;</span> <span class="ow">or</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;sbdart&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_abs_param</span> <span class="o">=</span> <span class="s">&#39;lowtran&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_res</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">=</span> <span class="s">&#39;chn&#39;</span>  <span class="c"># These are pseudo-spectral with 20 cm^-1 resolution</span>
            <span class="c"># Spectral quantities are provided</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown mol_abs_param type encountered.&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Case.prepare_for_output_process"><a class="viewcode-back" href="../radpack.html#librad.Case.prepare_for_output_process">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_output_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare for effects of the `output_process` keyword in the libRadtran/uvspec input file.</span>

<span class="sd">        :param tokens: Keyword tokens of the uvspec `output_process` keyword.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;sum&#39;</span><span class="p">:</span>  <span class="c"># the units become per band (?)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;sum&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># TODO : Check that this is correct somehow</span>
        <span class="k">elif</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;integrate&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="s">&#39;wvl&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Option output_process integrate probably not valid with band quantities&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;integrate&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># The third element in the rad_units list gives the spectral variable</span>
        <span class="k">elif</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;per_nm&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;per_nm&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;nm&#39;</span>
        <span class="k">elif</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;per_cm-1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;per_cm-1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cm^-1&#39;</span>
        <span class="k">elif</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;per_band&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;per_band&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">elif</span> <span class="n">process</span> <span class="o">==</span> <span class="s">&#39;none&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_process</span> <span class="o">=</span> <span class="s">&#39;none&#39;</span>
            <span class="c"># TODO : Probably need to revert to other defaults here</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Invalid output_process option encountered in uvspec input file.&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Case.prepare_for_keyword"><a class="viewcode-back" href="../radpack.html#librad.Case.prepare_for_keyword">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make any possible preparations for occurrences of particular keywords</span>
<span class="sd">        :param keyword: The uvspec option keyword (string)</span>
<span class="sd">        :param tokens: The parameters (tokens) for the keyword as a list of strings</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Prepare for different output formats, depending on the solver</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;rte_solver&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_solver</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;source&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_source</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="c"># Prepare for radiances</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;umu&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>  <span class="c"># The number of umu values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">umu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pza</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umu</span><span class="p">),</span> <span class="s">&#39;pza&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paz</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="s">&#39;paz&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;phi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paz</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="s">&#39;paz&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;output_user&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;lambda&#39;</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">]</span>  <span class="c"># lambda is a keyword</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="s">&#39;wvn&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span><span class="p">]</span>  <span class="c"># abbreviate wavenumber</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span> <span class="o">=</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;wavelength&#39;</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span><span class="p">]</span>  <span class="c"># abbreviate wavelength</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;polradtran&#39;</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;nstokes&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;U&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;U&#39;</span><span class="p">,</span> <span class="s">&#39;V&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;uvspec input polradtran nstokes must be 1, 3 or 4.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_polradtran</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;zout&#39;</span> <span class="ow">or</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;zout_sea&#39;</span> <span class="ow">or</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;pressure_out&#39;</span> <span class="ow">or</span>
            <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;tzs_cloud_top_height&#39;</span><span class="p">):</span>  <span class="c"># Determine number of output levels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">=</span> <span class="n">keyword</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re_isSingleOutputLevel</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels_out</span> <span class="o">=</span> <span class="n">tokens</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># Number of output levels is not known, will have to auto-detect</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># This indicates that the number of output levels is not known</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;output_quantity&#39;</span><span class="p">:</span>  <span class="c"># Try to set output units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">==</span> <span class="s">&#39;brightness&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">==</span> <span class="s">&#39;reflectivity&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span> <span class="o">==</span> <span class="s">&#39;transmittance&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;heating_rate&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;zout&#39;</span><span class="p">,</span> <span class="s">&#39;heat&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c">#TODO note that heating rate outputs for multiple wavelengths have a header line</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;print_disort_info&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>  <span class="c"># this output format is unknown or too complex to handle</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;altitude&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># This is the ground altitude above sea level</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;mol_abs_param&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_mol_abs_param</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;wavelength_index&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_index_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;output_process&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_output_process</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;wc_file&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_water_clouds</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;ic_file&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_ice_clouds</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;profile_file&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;wc&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_water_clouds</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;ic&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_ice_clouds</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;sza&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sza</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Case.prepare_for_polradtran"><a class="viewcode-back" href="../radpack.html#librad.Case.prepare_for_polradtran">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_polradtran</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare for output from the polradtran solver</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wvl&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">stokes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&#39;down_flux&#39;</span> <span class="o">+</span> <span class="n">stokes</span><span class="p">,</span> <span class="s">&#39;up_flux&#39;</span> <span class="o">+</span> <span class="n">stokes</span><span class="p">])</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;The polradtran solver does not produce direct solar irradiances and will only produce&#39;</span> <span class="o">+</span>
                      <span class="s">&#39; output if the atmosphere file contains the altitudes specified by zout (see &quot;zout&quot; &#39;</span> <span class="o">+</span>
                      <span class="s">&#39; in the uvspec manual). &#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Case.append_option"><a class="viewcode-back" href="../radpack.html#librad.Case.append_option">[docs]</a>    <span class="k">def</span> <span class="nf">append_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Append a libRadtran/uvspec options to this uvspec case. It will be appended at the end of the file</span>

<span class="sd">        :param option: A list containing the keyword and keyword parameters (tokens)</span>
<span class="sd">        :param origin: A 2-tuple giving the origin of the option and a &quot;line number&quot; reference. Default (&#39;user&#39;, None)</span>
<span class="sd">        uvspec options.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># the option keyword (string)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c"># The tokens following the keyword (list of strings)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filorigin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>  <span class="c"># The origin of this keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optionobj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvsOptions</span><span class="p">[</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>  <span class="c"># The option object</span>
        <span class="c"># Make any possible preparations for occurance of this keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_keyword</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</div>
<div class="viewcode-block" id="Case.alter_option"><a class="viewcode-back" href="../radpack.html#librad.Case.alter_option">[docs]</a>    <span class="k">def</span> <span class="nf">alter_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Alter the parameters of a uvspec input option. If the option is not found, the option is appended with</span>
<span class="sd">        append_option instead.</span>

<span class="sd">        :param option: List of keyword and tokens (parameters) to provide to the option keyword (list of strings).</span>
<span class="sd">        :param origin: A 2-tuple noting the &quot;origin&quot; of the change to this keyword. Default (&#39;user&#39;, None)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ioption</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>  <span class="c"># just append the option if not found</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">ioption</span><span class="p">]</span> <span class="o">=</span> <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c"># The tokens following the keyword (list of strings)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filorigin</span><span class="p">[</span><span class="n">ioption</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span>  <span class="c"># The origin of this keyword</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_keyword</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</div>
<div class="viewcode-block" id="Case.del_option"><a class="viewcode-back" href="../radpack.html#librad.Case.del_option">[docs]</a>    <span class="k">def</span> <span class="nf">del_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Delete a uvspec input option matching the given option.</span>

<span class="sd">        :param option: Keyword of option to be deleted</span>
<span class="sd">        :param all: A flag indicating if all matching options must be deleted or only the first occurrence. The</span>
<span class="sd">        default is to delete all matching occurrences.</span>
<span class="sd">        :return: True if an option was deleted or False if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#TODO consider providing warning if options does not exist</span>
        <span class="n">deletedsomething</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="n">option</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="n">deletedsomething</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">ioption</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ioption</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ioption</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filorigin</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ioption</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionobj</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ioption</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deletedsomething</span><span class="p">:</span>
            <span class="c"># Run through all options and reconstruct preparations</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ioption</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_keyword</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">ioption</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">ioption</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">deletedsomething</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Case.read"><a class="viewcode-back" href="../radpack.html#librad.Case.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">includes_seen</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; Reads a libRadtran input file. This will construct the libRadtran case from the contents of the .INP file</span>
<span class="sd">        Adapted from code by libRadtran developers.</span>

<span class="sd">        :param path: File path from which to read the uvspec input</span>
<span class="sd">        :param includes_seen: List of files already included (for recursion purposes to avoid infinite include loops)</span>
<span class="sd">        :return: data, line_nos, path</span>
<span class="sd">          where data is the full data in the file with includes, line_nos shows the source of every line and</span>
<span class="sd">          path is the path to the main input file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Get the full path</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c"># print includes_seen</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">INPfile</span><span class="p">:</span>
            <span class="n">opdata</span> <span class="o">=</span> <span class="n">INPfile</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>  <span class="c"># read in the entire file and process in memory afterwards</span>
        <span class="n">opdata</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">opdata</span><span class="p">]</span>  <span class="c"># Split lines into keywords and option parameters (tokens)</span>
        <span class="n">line_nos</span> <span class="o">=</span> <span class="p">[(</span><span class="n">path</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">opdata</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c"># Remove lines with comments and merge continuous lines</span>
        <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">opdata</span><span class="p">):</span>  <span class="c"># Remove empty lines, comments and merge options split over multiple file lines</span>
            <span class="c"># Skip empty lines</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]:</span>
                <span class="n">opdata</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">line_nos</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c"># Skip comments  #TODO save comments as well in the librad.Case</span>
            <span class="k">if</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">):</span>
                <span class="n">opdata</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">line_nos</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c"># Remove comments from the line  #TODO save comments into the librad.Case</span>
            <span class="k">elif</span> <span class="p">[</span><span class="bp">True</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">word</span> <span class="o">!=</span> <span class="s">&quot;#&quot;</span><span class="p">:</span>
                            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="c"># continuous line</span>
            <span class="k">elif</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span><span class="p">):</span>
                <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">opdata</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># remove the \</span>
                    <span class="c"># if the \ was preceded and continued by whitespace</span>
                <span class="k">if</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">line_nos</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">opdata</span><span class="p">[</span><span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># Get the includes and include them at the point where the include keyword appears</span>
        <span class="n">all_opdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_line_nos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">this_includes</span> <span class="o">=</span> <span class="n">includes_seen</span><span class="p">[:]</span> <span class="c"># These are the include files seen up to this point in the recursion</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opdata</span><span class="p">)):</span>  <span class="c"># Run through all lines in the file and perform include substitutions</span>
            <span class="k">if</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;include&#39;</span><span class="p">:</span>  <span class="c"># Have found an include file, read it and append to all_opdata</span>
                <span class="n">include_file</span> <span class="o">=</span> <span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Obtain the filename</span>
                <span class="n">include_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">include_file</span><span class="p">))</span>  <span class="c"># Extend to full path name</span>
                <span class="k">if</span> <span class="n">this_includes</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">include_file</span><span class="p">):</span>  <span class="c"># This file has been included before</span>
                    <span class="c"># print(this_includes, include_file)</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;Attempted to include the same uvspec input file more than once in parent.&#39;</span><span class="p">)</span>
                <span class="n">this_includes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">include_file</span><span class="p">)</span>  <span class="c"># Add the filename to the list of included files already seen</span>
                <span class="c"># Read the data from the included file</span>
                <span class="n">inc_opdata</span><span class="p">,</span> <span class="n">inc_line_nos</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Case</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">include_file</span><span class="p">,</span> <span class="n">this_includes</span><span class="p">)</span>  <span class="c"># Recursion</span>
                <span class="c"># Insert the data at this point in the file option and line number lists</span>
                <span class="n">all_opdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inc_opdata</span><span class="p">)</span>
                <span class="n">all_line_nos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inc_line_nos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># Not an include option, just append</span>
                <span class="n">all_opdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opdata</span><span class="p">[</span><span class="n">line</span><span class="p">])</span>
                <span class="n">all_line_nos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_nos</span><span class="p">[</span><span class="n">line</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">all_opdata</span><span class="p">,</span> <span class="n">all_line_nos</span><span class="p">,</span> <span class="n">path</span>

        <span class="c"># The following is the old code that inserted all include files at the end, which is not the same</span>
        <span class="c"># behaviour as a C #INCLUDE statement, which inserts at the point where the #INCLUDE appears.</span>
        <span class="c"># buff = 0</span>
        <span class="c"># this_includes = []</span>
        <span class="c"># for line in xrange(len(opdata)):</span>
        <span class="c">#     if (opdata[line + buff][0] == &quot;include&quot; and len(opdata[line + buff]) == 2):</span>
        <span class="c">#         include_file = opdata.pop(line + buff)[1]  # Obtain the filename of the included file and pop option</span>
        <span class="c">#         include_file = os.path.normpath(os.path.join(folder, include_file))  # Extend to full path name</span>
        <span class="c">#         this_includes.append(include_file)  # Add the filename to the list of included files at this level</span>
        <span class="c">#         line_nos.pop(line + buff)  # Also pop the line numbers from the list of line numbers</span>
        <span class="c">#         buff -= 1  # Take into account that a line has been removed</span>
        <span class="c"># for include_path in this_includes:</span>
        <span class="c">#     if not os.path.exists(include_path):</span>
        <span class="c">#         msg = &quot;Include file &#39;%s&#39; in &#39;%s&#39; does not exist.&quot; % (include_path, path)</span>
        <span class="c">#         raise IOError(msg)</span>
        <span class="c">#         #print &quot; &quot; * len(includes) + msg</span>
        <span class="c">#     # If the file has been included before.</span>
        <span class="c">#     elif (this_includes + includes_seen).count(include_path) != 1:  # Count number of times file is included</span>
        <span class="c">#         msg = &quot;File %s included more than once in %s. Please fix this.&quot; % (include_path, path)</span>
        <span class="c">#         raise IOError(msg)</span>
        <span class="c">#         #self.error_txt.append(msg)</span>
        <span class="c">#         #print &quot; &quot; * len(includes) + msg</span>
        <span class="c">#     else:</span>
        <span class="c">#         include_data = Case.read(include_path, includes_seen + this_includes)</span>
        <span class="c">#         # The include file might contain errors and return None.</span>
        <span class="c">#         if include_data:</span>
        <span class="c">#             opdata.extend(include_data[0])  #TODO surely an insert rather than extend ?</span>
        <span class="c">#             line_nos.extend(include_data[1])</span>
        <span class="c"># print opdata</span>
        <span class="c"># print line_nos</span>
        <span class="c"># return opdata, line_nos, path</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; libRadtran/uvspec input data</span>
<span class="sd">        :return: The uvspec input data as it would appear in an input file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uvsinp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ioption</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
            <span class="n">uvsinp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keyword</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">ioption</span><span class="p">]))</span>  <span class="c">#TODO add comments</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">uvsinp</span><span class="p">)</span>

<div class="viewcode-block" id="Case.write"><a class="viewcode-back" href="../radpack.html#librad.Case.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write libRadtran/uvspec input to a file (.INP extension by default.</span>
<span class="sd">        If the filename input is given as &#39;&#39;, a file save dialog will be presented</span>

<span class="sd">        :param filename: Filename to which to write the uvspec input</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">easygui</span><span class="o">.</span><span class="n">filesavebox</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s">&#39;Please save the uvspec input file.&#39;</span><span class="p">,</span> <span class="n">filetypes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;*.INP&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&#39;.inp&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s">&#39;.INP&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">uvINP</span><span class="p">:</span>
            <span class="n">alldata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>
            <span class="n">uvINP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alldata</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Case.distribute_flux_data"><a class="viewcode-back" href="../radpack.html#librad.Case.distribute_flux_data">[docs]</a>    <span class="k">def</span> <span class="nf">distribute_flux_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluxdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Distribute flux/user data read from uvspec output file to various data fields.</span>
<span class="sd">        This method will look at `output_user` options and attempt to assign flux/user data in a sensible way.</span>
<span class="sd">        .. note::</span>
<span class="sd">            There are potentially uvspec output formats that are not possible to process or to assign correctly.</span>
<span class="sd">            These are typically cases in which it is not possible to determine from the .INP and/or .OUT file</span>
<span class="sd">            how this data should be assigned.</span>

<span class="sd">        :param fluxdata: Flux (irradiance) data read from uvspec output file</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#TODO rename this function to just distribute_data ?</span>
        <span class="c"># First split the data amongst output levels or output wavelengths/wavenumbers</span>
        <span class="c"># We assume and handle only those cases of output_user where the primary variable is</span>
        <span class="c"># zout, lambda (wvl) or wavenumber (wvn)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span><span class="p">:</span>  <span class="c"># distribute to user-defined output variables</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span>
        <span class="n">datashape</span> <span class="o">=</span> <span class="n">fluxdata</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datashape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># Need some special cases to deal with single line output files</span>
            <span class="n">linecount</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">linecount</span> <span class="o">=</span> <span class="n">datashape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># Deal with the shape of the data output and try to reshape, depending on the number of</span>
        <span class="c"># wavelengths and output levels (zout, zout_sea or pressure)</span>
        <span class="c"># if len(datashape) == 2:</span>
        <span class="c">#    if datashape[1] != len(fields):  # number of fields in data does not match number of fields</span>
                <span class="c"># print datashape[1], &#39; not the same as &#39;, len(fields) #TODO try to deal with this</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;zout&#39;</span> <span class="ow">or</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;zout_sea&#39;</span> <span class="ow">or</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;p&#39;</span> <span class="ow">or</span>
            <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;cth&#39;</span><span class="p">):</span>  <span class="c"># output level or pressure level is the primary variable</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Unknown number of output levels</span>
                <span class="c"># Try just using the number of unique values in the first column</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxdata</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">linecount</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;wvl&#39;</span> <span class="ow">or</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;wvn&#39;</span><span class="p">:</span>  <span class="c"># wavelength/wavenumber is the primary variable</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Don&#39;t know number of output levels</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>  <span class="c"># Try to determine number of wavelengths/wavenumbers</span>
                <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxdata</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">linecount</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxdata</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span><span class="p">,</span> <span class="n">linecount</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># Assume secondary variable is zout</span>
            <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxdata</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span><span class="p">,</span> <span class="n">linecount</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>  <span class="c">#TODO provide warning or something</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxdata</span>  <span class="c"># retain the flux data in the instance, reshaped as well as possible</span>
        <span class="k">if</span> <span class="n">linecount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># here the data is actually distributed, single line a special case</span>
            <span class="c"># Some output fields, such as umu, uu, u0u, uu_down, uu_up, cmu(?) are vectors and therefore occupy</span>
            <span class="c"># multiple columns, so keep track of columns and try to</span>
            <span class="n">colstart</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># keep track of starting column</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ifield</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu&#39;</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu_up&#39;</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu_down&#39;</span><span class="p">:</span>  <span class="c"># Do uu_up and uu_down actually exist ?</span>
                    <span class="c"># Number of columns is n_umu * n_phi</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;u0u&#39;</span><span class="p">:</span>  <span class="c">#TODO does this exist and if so, what is the size ?</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;umu&#39;</span><span class="p">:</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c"># All other output variables are assumed to occupy only one column</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c"># setattr(self, field, np.squeeze(fluxdata[colstart:(colstart + ncols)]))</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">fluxdata</span><span class="p">[</span><span class="n">colstart</span><span class="p">:(</span><span class="n">colstart</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">)])</span>
                <span class="n">colstart</span> <span class="o">=</span> <span class="n">colstart</span> <span class="o">+</span> <span class="n">ncols</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># There is more than 1 line of output flux/user data</span>
            <span class="c"># Some output fields, such as umu, uu, u0u, uu_down, uu_up, cmu(?) are vectors and therefore occupy</span>
            <span class="c"># multiple columns, so keep track of columns and try to distribute in a reasonable way</span>
            <span class="n">colstart</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># keep track of starting column</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ifield</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu&#39;</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu_up&#39;</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;uu_down&#39;</span><span class="p">:</span>  <span class="c"># Do uu_up and uu_down actually exist ?</span>
                    <span class="c"># Number of columns is n_umu * n_phi</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;u0u&#39;</span><span class="p">:</span>  <span class="c">#TODO does this exist and if so, what is the size ?</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s">&#39;umu&#39;</span><span class="p">:</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c"># All other output variables are assumed to occupy only one column</span>
                    <span class="n">ncols</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c"># setattr(self, field, np.squeeze(fluxdata[:, :, colstart:(colstart + ncols)]))</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">fluxdata</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">colstart</span><span class="p">:(</span><span class="n">colstart</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">)])</span>
                <span class="n">colstart</span> <span class="o">=</span> <span class="n">colstart</span> <span class="o">+</span> <span class="n">ncols</span>
        <span class="c"># Clean up zout and wavelength/wavenumber data</span>
        <span class="c"># Convert levels to real numbers</span>
        <span class="c"># TODO : What number should TOA translate to ? Maximum height defined in the atmosphere file ? Fixed number ? np.inf ?</span>
        <span class="c"># TOA -&gt; np.inf seems to cause problems for xray</span>
        <span class="n">level_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;boa&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span> <span class="s">&#39;BOA&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span> <span class="s">&#39;sur&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span>
                      <span class="s">&#39;SUR&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span> <span class="s">&#39;surface&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span> <span class="s">&#39;SURFACE&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span>
                      <span class="s">&#39;toa&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="s">&#39;TOA&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="s">&#39;cpt&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;CPT&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
        <span class="n">level_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">level_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">level_dict</span><span class="p">:</span>
                    <span class="n">level_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_values</span><span class="p">,</span> <span class="n">level_dict</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>  <span class="c"># Try translating</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Invalid level token found in &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">+</span> <span class="s">&#39; keyword.&#39;</span><span class="p">)</span>
        <span class="c">#print &#39;level_values ++&#39;</span>
        <span class="c">#print level_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_values</span> <span class="o">=</span> <span class="n">level_values</span>
        <span class="c">#self.zout = np.unique(self.zout)  #TODO check that this does not reorder the zout values (especially pressure)</span>
        <span class="c">#if len(self.zout) &gt; 0:  #  TODO : Problems here with pressure_out, zout_sea etc.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">==</span> <span class="s">&#39;zout&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level_values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zout</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zout</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">==</span> <span class="s">&#39;zout_sea&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level_values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">==</span> <span class="s">&#39;pressure_out&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pressure_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level_values</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Reverse order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pressure_out</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zout_sea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c">#    self.n_levels_out = len(self.zout)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wvn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Calculate wavenumbers if wavelengths available</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wvn</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Calculate wavelengths if wavenumbers available</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wvl</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wvn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Case.rad_units_str"><a class="viewcode-back" href="../radpack.html#librad.Case.rad_units_str">[docs]</a>    <span class="k">def</span> <span class="nf">rad_units_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Provide a radiance units string e.g. W/sr/m^2/nm.</span>
<span class="sd">        If output_quantity is set to &#39;brightness&#39; or &#39;reflectivity&#39;, rad_units will be &#39;K&#39; or &#39;&#39; respectively.</span>

<span class="sd">        :return: Radiance units as a string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rad_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rad_units</span> <span class="ow">and</span> <span class="n">rad_units</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;W&#39;</span><span class="p">:</span>
            <span class="n">rad_units</span> <span class="o">+=</span> <span class="s">&#39;/sr&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">rad_units</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">rad_units</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="n">rad_units</span> <span class="o">=</span> <span class="s">&#39; [$&#39;</span> <span class="o">+</span> <span class="n">rad_units</span> <span class="o">+</span> <span class="s">&#39;$]&#39;</span>
        <span class="k">return</span> <span class="n">rad_units</span>
</div>
<div class="viewcode-block" id="Case.irrad_units_str"><a class="viewcode-back" href="../radpack.html#librad.Case.irrad_units_str">[docs]</a>    <span class="k">def</span> <span class="nf">irrad_units_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Provide an irradiance units string e.g. W/m^2/nm.</span>
<span class="sd">        If output_quantity is set to &#39;brightness&#39; or &#39;reflectivity&#39;, irrad_units will be &#39;K&#39; or &#39;&#39; respectively.</span>

<span class="sd">        :return: Irradiance units as a string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">irrad_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">irrad_units</span> <span class="ow">and</span> <span class="n">irrad_units</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;W&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">irrad_units</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">irrad_units</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="n">irrad_units</span> <span class="o">=</span> <span class="s">&#39; [$&#39;</span> <span class="o">+</span> <span class="n">irrad_units</span> <span class="o">+</span> <span class="s">&#39;$]&#39;</span>
        <span class="k">return</span> <span class="n">irrad_units</span>
</div>
<div class="viewcode-block" id="Case.readout"><a class="viewcode-back" href="../radpack.html#librad.Case.readout">[docs]</a>    <span class="k">def</span> <span class="nf">readout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read uvspec output and assign to variables as intelligently as possible.</span>

<span class="sd">         The general process of reading is:</span>
<span class="sd">          1) If the user has specified output_user, just assume a flat file and read using</span>
<span class="sd">             np.loadtxt or np.genfromtxt.</span>
<span class="sd">          2) If not user_output and the solver has no radiance blocks, assume a flat file and</span>
<span class="sd">             read using np.loadtxt. The variables to be read should be contained in the self.fluxline attribute.</span>
<span class="sd">          3) Otherwise, if the output has radiance blocks, read those depending on the radiance block</span>
<span class="sd">             format for the specific solver. Keep reading flux and radiance blocks until the file is exhausted.</span>

<span class="sd">         Once the data has all been read, the data is split up between the number of output levels and number of</span>
<span class="sd">         wavelengths. For radiance data, the order of numpy dimensions is *umu*, *phi*, *wavelength*, *zout* and *stokes*. That</span>
<span class="sd">         is, if a case has multiple zenith angles, multiple azimuth angles, multiple wavelengths and multiple output</span>
<span class="sd">         levels, the radiance property uu will have 4 dimensions. In the case of polradtran, there will be 5</span>
<span class="sd">         dimensions to include the stokes parameters (if more than 1, which is the I = intensity parameter).</span>

<span class="sd">        Output from uvspec depends on the solver and a number of other inputs, including the directive ``output_user`.</span>
<span class="sd">        For the solvers ``disort``, ``sdisort``, ``spsdisort`` and presumably also ``disort2``, the irradiance (flux) outputs default</span>
<span class="sd">        to</span>
<span class="sd">        ::</span>
<span class="sd">         lambda edir edn eup uavgdir uavgdn uavgup</span>

<span class="sd">        If radiances (intensities) have been requested with the umu</span>
<span class="sd">        (cosine zenith angles input), each line of flux data is followed</span>
<span class="sd">        by a block of radiance data as follows:</span>
<span class="sd">        ::</span>
<span class="sd">         umu(0) u0u(umu(0))</span>
<span class="sd">         umu(1) u0u(umu(1))</span>
<span class="sd">         . . . .</span>
<span class="sd">         . . . .</span>
<span class="sd">         umu(n) u0u(umu(n))</span>

<span class="sd">        where u0u is the azimuthally averaged radiance for the requested zenith</span>
<span class="sd">        angles.</span>

<span class="sd">        If azimuth angles (phi) have also been specified, then the</span>
<span class="sd">        radiance block is extended as follows:</span>
<span class="sd">        ::</span>
<span class="sd">                                phi(0)        ...     phi(m)</span>
<span class="sd">         umu(0) u0u(umu(0)) uu(umu(0),phi(0)) ... uu(umu(0),phi(m))</span>
<span class="sd">         umu(1) u0u(umu(1)) uu(umu(1),phi(0)) ... uu(umu(1),phi(m))</span>
<span class="sd">         . . . .</span>
<span class="sd">         . . . .</span>
<span class="sd">         umu(n) u0u(umu(n)) uu(umu(n),phi(0)) ... uu(umu(n),phi(m))</span>

<span class="sd">        Radiance outputs are not affected by output_user options.</span>

<span class="sd">        For the polradtran solver, the flux block is as follows:</span>
<span class="sd">        ::</span>
<span class="sd">           lambda down_flux(1) up_flux(1) ... down_flux(iS) up_flux(iS)</span>

<span class="sd">        where iS is the number of Stokes parameters specified using the</span>
<span class="sd">        &#39;polradtran nstokes&#39; directive.</span>
<span class="sd">        If umu and phi are also specified, the radiance block is as</span>
<span class="sd">        follows:</span>
<span class="sd">        ::</span>
<span class="sd">                                 phi(0)      ...      phi(m)</span>
<span class="sd">         Stokes vector I</span>
<span class="sd">         umu(0) u0u(umu(0)) uu(umu(0),phi(0)) ... uu(umu(0),phi(m))</span>
<span class="sd">         umu(1) u0u(umu(1)) uu(umu(1),phi(0)) ... uu(umu(1),phi(m))</span>
<span class="sd">         . . . .</span>
<span class="sd">         . . . .</span>
<span class="sd">         umu(n) u0u(umu(n)) uu(umu(n),phi(0)) ... uu(umu(n),phi(m))</span>
<span class="sd">         Stokes vector Q</span>
<span class="sd">         . . .</span>
<span class="sd">         . . .</span>

<span class="sd">        The u0u (azimuthally averaged radiance) is always zero for</span>
<span class="sd">        polradtran.</span>

<span class="sd">        For the two-stream solver (twostr), the flux block is</span>
<span class="sd">        ::</span>
<span class="sd">           lambda edir edn eup uavg</span>

<span class="sd">        The directive keyword ``brightness`` can also change output. The documentation simply states that radiances and</span>
<span class="sd">        irradiances are just converted to brightness temperatures.</span>

<span class="sd">        The keyword directive ``zout`` and it&#39;s parameters will influence output format as well. In general the output</span>
<span class="sd">        is repeated for each given value of ``zout`` or ``zout_sea``.</span>

<span class="sd">        The keyword directive ``output`` and its parameters will also have a major effect.</span>

<span class="sd">        The ``output sum`` keyword sums output data over the wavelength dimension. This in contrast to ``output integrate``,</span>
<span class="sd">        which performs a spectral integral.</span>

<span class="sd">        The keyword directive ``header`` should not be used at all. This produces some header information in the output</span>
<span class="sd">        that will cause errors. A warning is issued of the ``header`` keyword is used in the input.</span>

<span class="sd">        :param filename: File from which to read the output. Defaults to name of input file, but with the .OUT</span>
<span class="sd">        extension.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#TODO check for use of header keyword</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Unknown output format. Skipping file read.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outfile</span>
        <span class="k">elif</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">easygui</span><span class="o">.</span><span class="n">fileopenbox</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s">&#39;Please select the uvspec output file.&#39;</span><span class="p">,</span> <span class="n">filetypes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;*.OUT&quot;</span><span class="p">])</span>
        <span class="n">fluxdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Output file does not exist. Run uvspec.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_user</span><span class="p">:</span>
            <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribute_flux_data</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;sslidar&#39;</span> <span class="ow">or</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;mystic&#39;</span><span class="p">):</span>  <span class="c"># There are no radiance blocks (sslidar). Mystic puts radiances in other files.</span>
            <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribute_flux_data</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">)</span>
        <span class="c"># elif self.n_phi == 0:   # Not sure about format for n_umu &gt; 0, n_phi == 0</span>
        <span class="c">#  Look at example UVSPEC_FILTER_SOLAR.INP, which indicates manual is not correct</span>
        <span class="c">#     fluxdata = np.loadtext(filename)</span>
        <span class="c">#     # Take away the radiance data</span>
        <span class="c">#     raddata = fluxdata[len(self.fluxline):]</span>
        <span class="c">#     fluxdata = fluxdata[:len(self.fluxline)]</span>
        <span class="c">#     self.raddata = raddata</span>
        <span class="c">#     self.fluxdata = fluxdata</span>
        <span class="c">#     self.distribute_flux_data(fluxdata)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># read radiance blocks  #TODO polradtran has different format</span>
            <span class="n">phicheck</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">radND</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># full 3D/4D radiance data is here (umu, phi and wavelength)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">uvOUT</span><span class="p">:</span>
                <span class="c"># Read and append a line of flux data</span>
                <span class="n">txtline</span> <span class="o">=</span> <span class="n">uvOUT</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">txtline</span><span class="p">:</span>
                    <span class="n">fluxline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">txtline</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fluxdata</span><span class="p">,</span> <span class="n">fluxline</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fluxdata</span> <span class="o">=</span> <span class="n">fluxline</span>
                    <span class="c"># Read the radiance block</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># There is a line of phi angles</span>
                        <span class="n">philine</span> <span class="o">=</span> <span class="n">uvOUT</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c">#TODO check that phi angles are correct</span>
                        <span class="n">phicheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">philine</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="c"># Read the lines for the umu values (radiances in radiance block)</span>
                    <span class="n">raddata</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># All polarisation blocks are vstacked</span>
                    <span class="k">for</span> <span class="n">polComp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span><span class="p">:</span>  <span class="c"># read a radiances block for each polarisation component</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;polradtran&#39;</span><span class="p">:</span>  <span class="c"># Read the polarisation block header</span>
                            <span class="n">polBlockHeader</span> <span class="o">=</span> <span class="n">uvOUT</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="c"># print polBlockHeader + &#39;}&#39;</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;^Stokes vector &#39;</span> <span class="o">+</span> <span class="n">polComp</span> <span class="o">+</span> <span class="s">&#39;$&#39;</span><span class="p">,</span> <span class="n">polBlockHeader</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;Stokes vector header not found for component &#39;</span> <span class="o">+</span> <span class="n">polComp</span><span class="p">)</span>
                        <span class="c"># raddata = []</span>
                        <span class="k">for</span> <span class="n">i_umuline</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span><span class="p">):</span>  <span class="c">#TODO this is possibly wrong if there is no phi specified - see manual</span>
                            <span class="n">umuline</span> <span class="o">=</span> <span class="n">uvOUT</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                            <span class="n">radline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">umuline</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raddata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">raddata</span> <span class="o">=</span> <span class="n">radline</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">raddata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">raddata</span><span class="p">,</span> <span class="n">radline</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">radND</span> <span class="o">=</span> <span class="n">raddata</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">radND</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">radND</span><span class="p">,</span> <span class="n">raddata</span><span class="p">))</span>
                    <span class="n">txtline</span> <span class="o">=</span> <span class="n">uvOUT</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c"># Read what should be the next line of flux data</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">distribute_flux_data</span><span class="p">(</span><span class="n">fluxdata</span><span class="p">)</span>  <span class="c"># distribute the flux data, which should also determine</span>
                                                 <span class="c"># the number of wavelengths definitively</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radND</span> <span class="o">=</span> <span class="n">radND</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_check</span> <span class="o">=</span> <span class="n">phicheck</span>

            <span class="c"># See if one size fits all</span>
            <span class="c"># self.u0u = radND[:,1].reshape(self.n_umu, self.n_stokes, self.n_wvl, -1, order=&#39;F&#39;).squeeze()  # should actually all be zero</span>
            <span class="c"># print radND.shape</span>
            <span class="c"># print radND</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u0u</span> <span class="o">=</span> <span class="n">radND</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="c"># There is actually some radiance data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">radND</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c"># checks how many elements actually</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_umu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_wvl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c"># transpose so that the nstokes axis is last</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c"># At this point, uu should be 5 dimensional (possibly with singleton dimensions) in order of</span>
            <span class="c"># &#39;umu&#39;, &#39;phi&#39;, &#39;wv&#39;, &#39;zout&#39; (or equivalent) and stokes</span>
            <span class="c"># if self.uu.shape[3] == 0:  # singleton dimension in zout</span>
            <span class="c">#     print &#39;Singleton in zout dimension, n_wvl = &#39;</span>
            <span class="c">#     print self.n_wvl</span>
            <span class="c">#     print &#39;self.uu&#39;</span>
            <span class="c">#     print self.uu</span>
            <span class="c">#     print &#39;self.u0u&#39;</span>
            <span class="c">#     print self.u0u</span>
                <span class="c"># self.uu = self.uu</span>

            <span class="c"># while self.uu.shape[-1] == 1:  # Remove any hanging singleton dimensions at the end</span>
            <span class="c">#    self.uu = self.uu.squeeze(axis=self.uu.ndim-1)</span>

            <span class="c"># if self.solver == &#39;polradtran&#39;:</span>
            <span class="c">#     self.u0u = radND[:,1].reshape(self.n_umu, self.nstokes, self.n_wvl, -1, order=&#39;F&#39;).squeeze()  # should actually all be zero</span>
            <span class="c">#     if radND.ndim == 3:  # There are multiple n_phi values</span>
            <span class="c">#         self.uu = radND[:,2:,:]</span>
            <span class="c">#         # Reshape to multiple nstokes values, multiple wavelengths and multiple zout levels</span>
            <span class="c">#         self.uu = self.uu.reshape((self.n_umu, self.nstokes, self.n_phi, self.n_wvl, -1), order=&#39;F&#39;).squeeze()</span>
            <span class="c">#</span>
            <span class="c">#     else: # There are only different umu values, no different phi values</span>
            <span class="c">#         self.uu = radND[:,2:]</span>
            <span class="c">#         # reshape to multiple nstokes</span>
            <span class="c">#         self.uu = self.uu.reshape((self.n_umu, self.nstokes, max(self.n_phi, 1), self.n_wvl, -1), order=&#39;F&#39;).squeeze()</span>
            <span class="c">#</span>
            <span class="c"># else:</span>
            <span class="c">#     self.u0u = radND[:,1].reshape(self.n_umu, self.nstokes, self.n_wvl, -1, order=&#39;F&#39;).squeeze()</span>
            <span class="c">#     #if self.u0u.shape[1] / self.n_wvl &gt; 1:  #TODO problem here with single wavelength data</span>
            <span class="c">#     #    self.u0u = self.u0u.reshape((self.n_umu, self.n_wvl, -1), order=&#39;F&#39;)</span>
            <span class="c">#     if radND.ndim == 3:</span>
            <span class="c">#         self.uu = radND[:,2:,:]</span>
            <span class="c">#         # If there are multiple zout levels, must reshape self.uu</span>
            <span class="c">#         if self.uu.shape[2] / self.n_wvl &gt; 1:</span>
            <span class="c">#             self.uu = self.uu.reshape((self.n_umu, self.n_phi, self.n_wvl, -1), order=&#39;F&#39;)</span>
            <span class="c">#     else:</span>
            <span class="c">#         self.uu = radND[:,2:]</span>
            <span class="c">#         if self.uu.shape[1] / self.n_wvl &gt; 1:  # if multiple output levels, reshape the radiance data appropriately</span>
            <span class="c">#             self.uu = self.uu.reshape((self.n_umu, self.n_wvl, -1), order=&#39;F&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;mystic&#39;</span><span class="p">:</span>
            <span class="c"># TODO : Read mystic fluxes and radiances from mc.flx.spc and mc.rad.spc</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Reading of mc.flx.spc and mc.rad.spc skipped. To be implemented.&#39;</span><span class="p">)</span>
        <span class="c"># Perform further processing of outputs, mainly production of xray.DataArray versions of outputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_outputs</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Case.run"><a class="viewcode-back" href="../radpack.html#librad.Case.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stderr_to_file</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">write_input</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">read_output</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">purge</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run the libRadtran/uvspec case.</span>

<span class="sd">        This will run the libRadtran/uvspec Case instance provided. Some control is provided regarding the handling of</span>
<span class="sd">        the standard error output from uvspec. This function only returns when uvspec terminates.</span>

<span class="sd">        :param stderr_to_file: Controls whether standard error output goes to the screen or is written to a file</span>
<span class="sd">            having the same name as the input/output files, except with the extension .ERR.</span>
<span class="sd">        :param write_input: Controls whether the input file is written out before execution. Default is True.</span>
<span class="sd">        :param read_output: Controls whether the output file is read after execution. Default is True.</span>
<span class="sd">        :param block: By default, this method waits until uvspec terminates. If set False, the uvspec process</span>
<span class="sd">            is released to background and read_output is set to False (regardless of user input).</span>
<span class="sd">        :param purge: If set True, the input and output files from this run will be deleted after the run is complete</span>
<span class="sd">            and the outputs have been read. Will only be honoured if read_output is also True. Default is True.</span>
<span class="sd">        :return: The shell command string executed in order to run the case and the return status of the command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Write input file by default</span>
        <span class="c"># Note that the location of the following imports is actually important, since this run code may be</span>
        <span class="c"># executed on a foreign host with a different operating system to the machine calling for the</span>
        <span class="c"># RT computations.</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="k">if</span> <span class="n">write_input</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.INP&#39;</span><span class="p">)</span>
        <span class="c"># Spawn a sub-process using the subprocess module</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stderr_to_file</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.INP&#39;</span><span class="p">,</span> <span class="s">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stin</span><span class="p">,</span> \
                     <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.OUT&#39;</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stout</span><span class="p">:</span>
                    <span class="n">return_code</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s">&#39;uvspec&#39;</span><span class="p">],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">stin</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">stout</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>  <span class="c"># the uvspec command likely does not exist</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unable to spawn uvspec process. Probably not installed system-wide on platform.&#39;</span><span class="p">)</span>
                <span class="n">return_code</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># redirect the standard error output to a file as well</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.INP&#39;</span><span class="p">,</span> <span class="s">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stin</span><span class="p">,</span> \
                     <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.OUT&#39;</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stout</span><span class="p">,</span> \
                     <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.ERR&#39;</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">sterr</span><span class="p">:</span>
                    <span class="n">return_code</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s">&#39;uvspec&#39;</span><span class="p">],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">stin</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">stout</span><span class="p">,</span> <span class="n">sterr</span><span class="o">=</span><span class="n">sterr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>  <span class="c"># the uvspec command likely does not exist</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unable to spawn uvspec process. Probably not installed system-wide on platform.&#39;</span><span class="p">)</span>
                <span class="n">return_code</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_code</span> <span class="ow">and</span> <span class="n">read_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">readout</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.OUT&#39;</span><span class="p">)</span>  <span class="c"># Read the output into the instance if the return code OK</span>
            <span class="k">if</span> <span class="n">purge</span><span class="p">:</span>  <span class="c"># Delete the input and output files</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.INP&#39;</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.OUT&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stderr_to_file</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;.ERR&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c"># Just move on if file delete fails.</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Case.process_outputs"><a class="viewcode-back" href="../radpack.html#librad.Case.process_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">process_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Process outputs from libRadtran into moglo.Scalar and xray.DataArray objects.</span>
<span class="sd">        Currently only radiance outputs are processed, along with a few typical flux outputs, such as `edir`.</span>

<span class="sd">        Note that this method probably does not cover all libRadtran/uvspec inputs and outputs and will most</span>
<span class="sd">        likely continue to evolve, perhaps breaking existing code.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Determine output levels if possible</span>
        <span class="c"># &#39;cpt&#39;, being cold-point tropopause is mapped to np.nan and toa maps to np.inf</span>


        <span class="c"># The most important output for MORTICIA is radiances (self.uu), so those get processed</span>
        <span class="c"># first. This is a 5 dimensional numpy array with axes &#39;umu&#39;. &#39;phi&#39;, &#39;wvl&#39;, &#39;zout&#39; (or equivalent)</span>
        <span class="c"># and &#39;stokes&#39;. The &#39;wvl&#39; axis could also be &#39;chn&#39; (spectral channel) or &#39;wvn&#39; (spectral wavenumber)</span>
        <span class="c"># Create each of the axes individually using xd_identity</span>
        <span class="c"># TODO : Also include putting irradiance or other user output into xray.DataArray objects</span>
        <span class="c"># TODO : Want to deal with azimuthally averaged radiances as well if possible (to xray.DataArray)</span>
        <span class="c"># Azimuthally averaged radiances occur when phi is not specified</span>
        <span class="c"># Set up sepctral axis, output level axis and stokes component axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="s">&#39;wvl&#39;</span><span class="p">:</span>
            <span class="n">spectral_axis</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvl</span><span class="p">,</span> <span class="s">&#39;wvl&#39;</span><span class="p">,</span><span class="s">&#39;nm&#39;</span><span class="p">)</span>  <span class="c"># The spectral axis is wavelength</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="s">&#39;wvn&#39;</span><span class="p">:</span>
            <span class="n">spectral_axis</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wvn</span><span class="p">,</span> <span class="s">&#39;wvn&#39;</span><span class="p">,</span> <span class="s">&#39;cm^-1&#39;</span><span class="p">)</span>  <span class="c"># The spectral axis is wavenumber</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="s">&#39;chn&#39;</span><span class="p">:</span>  <span class="c"># The spectral axis is channel number</span>
            <span class="n">spectral_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_channels</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">level_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">)</span>  <span class="c"># Presume units correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="n">stokes</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_stokes</span><span class="p">),</span> <span class="s">&#39;stokes&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stokes</span> <span class="o">=</span> <span class="n">stokes</span>
        <span class="c"># Convert uu radiance output to xray.DataArray</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c"># OK, there is some radiance data (not azimuthally averaged)</span>
            <span class="n">umu</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umu</span><span class="p">,</span> <span class="s">&#39;umu&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>  <span class="c"># TODO : This must change to the propagation zenith (polar) angle</span>
            <span class="n">paz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span>
            <span class="n">pza</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pza</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span>
            <span class="c"># Determine the units of uu</span>
            <span class="n">uu_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_units_str</span><span class="p">()</span>
            <span class="c"># Build the xray.DataArray</span>
            <span class="n">qty_name</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;radiance&#39;</span><span class="p">:</span> <span class="s">&#39;specrad&#39;</span><span class="p">,</span> <span class="s">&#39;transmittance&#39;</span><span class="p">:</span> <span class="s">&#39;trnx&#39;</span><span class="p">,</span> <span class="s">&#39;reflectivity&#39;</span><span class="p">:</span> <span class="s">&#39;reflx&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_quantity</span><span class="p">]</span>
            <span class="n">xd_uu</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="p">,</span> <span class="p">[</span><span class="n">pza</span><span class="p">,</span> <span class="n">paz</span><span class="p">,</span> <span class="n">spectral_axis</span><span class="p">,</span> <span class="n">levels</span><span class="p">,</span> <span class="n">stokes</span><span class="p">],</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">qty_name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="n">uu_units</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span> <span class="o">=</span> <span class="n">xd_uu</span>
        <span class="c"># Try to process fluxline data into xray.DataArray objects</span>
        <span class="n">single_col_flux_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;edir&#39;</span><span class="p">,</span> <span class="s">&#39;edn&#39;</span><span class="p">,</span> <span class="s">&#39;eup&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdir&#39;</span><span class="p">,</span> <span class="s">&#39;uavgdn&#39;</span><span class="p">,</span> <span class="s">&#39;uavgup&#39;</span><span class="p">,</span> <span class="s">&#39;uavgglo&#39;</span><span class="p">,</span> <span class="s">&#39;down_fluxI&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;down_fluxQ&#39;</span><span class="p">,</span> <span class="s">&#39;down_fluxU&#39;</span><span class="p">,</span> <span class="s">&#39;down_fluxV&#39;</span><span class="p">,</span> <span class="s">&#39;up_fluxI&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;up_fluxQ&#39;</span><span class="p">,</span> <span class="s">&#39;up_fluxU&#39;</span><span class="p">,</span> <span class="s">&#39;up_fluxV&#39;</span><span class="p">,</span><span class="s">&#39;enet&#39;</span><span class="p">,</span> <span class="s">&#39;esum&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">flux_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span><span class="p">:</span>  <span class="c"># This could actually be output_user data as well</span>
            <span class="n">flux_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irrad_units_str</span><span class="p">()</span>  <span class="c"># Remember that &quot;flux&quot; means irradiance here</span>
            <span class="k">if</span> <span class="n">flux_field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;uavg&#39;</span><span class="p">):</span>
                <span class="n">flux_units</span> <span class="o">+=</span> <span class="s">&#39;/sr&#39;</span>
            <span class="k">if</span> <span class="n">flux_field</span> <span class="ow">in</span> <span class="n">single_col_flux_fields</span><span class="p">:</span>  <span class="c"># This are single column outputs</span>
                <span class="n">flux_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_field</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># Remove trailing singleton dimension</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_field</span><span class="p">,</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Non-singleton third dimension encountered in scalar flux data.&#39;</span><span class="p">)</span>
                <span class="n">xd_flux</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_field</span><span class="p">),</span> <span class="p">[</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">levels</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">flux_field</span><span class="p">,</span>
                                         <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;units&#39;</span><span class="p">:</span> <span class="n">flux_units</span><span class="p">,</span> <span class="s">&#39;long_name&#39;</span><span class="p">:</span> <span class="n">long_name</span><span class="p">[</span><span class="n">flux_field</span><span class="p">]})</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;xd_&#39;</span> <span class="o">+</span> <span class="n">flux_field</span><span class="p">,</span> <span class="n">xd_flux</span><span class="p">)</span>
        <span class="c"># TODO : Would be preferable to put stokes parameters all into single xray.DataArray for polradtran</span>
        <span class="c"># TODO : Processing of &#39;mystic&#39; outputs to xray.DataArray objects</span>
        <span class="c"># TODO : Mean intensity is the actinic flux divided by 4 pi, should perhaps be expressed /sr in units.</span>



</div></div>
<div class="viewcode-block" id="RadEnv"><a class="viewcode-back" href="../radpack.html#librad.RadEnv">[docs]</a><span class="k">class</span> <span class="nc">RadEnv</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; RadEnv is a class to encapsulate a large number of uvspec runs to cover a large number of sightlines over the</span>
<span class="sd">    whole sphere. A radiance map over the complete sphere is called a radiant environment map. The uvspec utility can</span>
<span class="sd">    only handle a limited number of sighlines per run, determined by the maximum number of polar and azimuthal angles</span>
<span class="sd">    specified in the file /libsrc_f/DISORT.MXD. If these values are changed, DISORT and uvspec must be recompiled. If</span>
<span class="sd">    the values are set too large, the memory requirements could easily exceed your computer&#39;s limit (there is</span>
<span class="sd">    currently no dynamic memory allocation in DISORT). The situation for the cdisort solver is less clear.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The `polradtran` radiative transfer (RT) solver does not produce direct irradiance outputs (`edir`),</span>
<span class="sd">        This presents a problem for calculation of path transmission (optical depth) between output atmospheric</span>
<span class="sd">        levels (e.g. as specified by the uvspec `zout` keyword). This solver only produces total fluxes (irradiances)</span>
<span class="sd">        for each of desired stokes parameters. Hence for calculation of polarised radiant environment maps (REMs), the only</span>
<span class="sd">        feasible option for `MORTICIA` is to use the `mystic` solver with the `mc_polarisation` option. Currently,</span>
<span class="sd">        the librad.Case uvspec output file reading functions do not cater for `mystic`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RadEnv.__init__"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_case</span><span class="p">,</span> <span class="n">n_pol</span><span class="p">,</span> <span class="n">n_azi</span><span class="p">,</span> <span class="n">mxumu</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span> <span class="n">mxphi</span><span class="o">=</span><span class="mi">19</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">n_sza</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a set of uvspec runs covering the whole sphere to calculate a full radiant environment map.</span>
<span class="sd">        Where the base_case is the uvspec case on which to base the environmental map, Name is the name to give the</span>
<span class="sd">        environmental map and n_pol and n_azi are the number of polar and azimuthal sightline angles to generate. The</span>
<span class="sd">        mxumu and mxphi are the maximum number of polar and azimuth angles to calculate in a single run of uvspec.</span>
<span class="sd">        The default values are mxumu = 48, and mxphi = 19. These values are taken from the standard libRadtran</span>
<span class="sd">        distribution (/libsrc_f/DISORT.MXD) maximum parameter file. If using the polradtran solver, the corresponding</span>
<span class="sd">        file is /libsrc_f/POLRADTRAN.MXD. Other solvers may have different restrictions. A warning will be issued if</span>
<span class="sd">        the solver is not in the DISORT/POLRADTRAN family.</span>

<span class="sd">        :param base_case: librad.Case object providing the case on which the environment map is to be based. Note</span>
<span class="sd">            that not any basecase can be used. As a general guideline, the basecase should have standard irradiance</span>
<span class="sd">            outputs (i.e. should not use the `output_user` keyword). It should also not the use `output_process` or</span>
<span class="sd">            `output_quantity` keywords, which change the units and/or format of the libRadtran/uvspec output.</span>
<span class="sd">             Minimal validation of the basecase is performed. However, use with `mol_abs_param` such as `kato` and</span>
<span class="sd">             `fu` is important for `MORTICIA` and these are supported (k-distribution or `correlated-k`</span>
<span class="sd">             parametrizations).</span>
<span class="sd">        :param n_pol: Number of polar angles (view/propagation zenith angles)</span>
<span class="sd">        :param n_azi: Number of azimuthal angles.</span>
<span class="sd">        :param mxumu: Maximum number of polar angles per case.</span>
<span class="sd">        :param mxphi: Maximum number of azimuthal angles per case.</span>
<span class="sd">        :param hemi: If set True, will generate only a single hemisphere being on one side of</span>
<span class="sd">            the solar principle plane. Default is False i.e. the environment map covers the full sphere.</span>
<span class="sd">            Note that if hemi=True, the number of REM samples in azimuth becomes n_azi :math:`\\times` 2.</span>
<span class="sd">            This is the recommended mode (hemi=True) for MORTICIA purposes, since it reduces execution time.</span>
<span class="sd">        :param n_sza: The number of solar zenith angles (SZA) at which to perform transmittance and path radiance</span>
<span class="sd">            computations. Each SZA will result in another run of the base case (no radiances)</span>

<span class="sd">        The solver cdisort may have dynamic memory allocation, so the warning is still issued because the situation</span>
<span class="sd">        is less clear.</span>

<span class="sd">        A note about radiative propagation angles and viewing angles, which are 180 deg opposite to each other.</span>
<span class="sd">        For radiance calculations define the cosine of the viewing zenith angle</span>
<span class="sd">        `umu` and the sensor azimuth `phi` and don&#39;t forget to also specify the solar azimuth</span>
<span class="sd">        `phi0`. `umu` &gt; 0 means sensor looking downward (e.g. a satellite), `umu` &lt; 0 means looking</span>
<span class="sd">        upward. `phi` = `phi0` indicates that the sensor looks into the direction of the sun,</span>
<span class="sd">        `phi` - `phi0` = 180 means that the sun is in the back of the sensor.</span>

<span class="sd">        `phi` is the propagation azimuth angle `paz`, except that `paz` is in radians and `phi` is in degrees.</span>

<span class="sd">        `pza` is the propagation zenith angle in radians.</span>

<span class="sd">        `vaz` is the view azimuth angle and is 180 :math:`^\\circ` different from `paz`. `vaz` is expressed</span>
<span class="sd">        in degrees. `vza`, the view zenith angle is 180 :math:`^\\circ` different from `paz&#39; and is expressed</span>
<span class="sd">        in degrees. In order to keep all azimuth angles in increasing order, &#39;vaz&#39; is in the range [-180, 180],</span>
<span class="sd">        while `phi` is in the range [0, 360] and `vaz` = `phi` - 180.</span>

<span class="sd">        The value of `umu` is the cosine of the propagation zenith angle. The value of `phi` is the true azimuth of</span>
<span class="sd">        the propagation direction.</span>

<span class="sd">        For all one-dimensional solvers the absolute azimuth does not matter, but only the relative azimuth</span>
<span class="sd">        `phi` - `phi0`.</span>

<span class="sd">        For `MORTICIA` work, it is strongly recommended that the `hemi` flag be set True. This will automatically</span>
<span class="sd">        set the `phi0` keyword to zero in the RadEnv cases when running uvspec. This will essentially halve the</span>
<span class="sd">        execution time for radiant environment maps of the same effective spatial resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Require that n_pol be even</span>
        <span class="c"># This is to ensure that there is no umu = 0 (horizontal direction, illegal in libRAdtran)</span>
        <span class="k">if</span> <span class="n">n_pol</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c"># check comment below about Matlab polar angles</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Input n_pol to librad.RadEnv must be even. Increased by 1.&#39;</span><span class="p">)</span>
            <span class="n">n_pol</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_azi</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Input n_azi to librad.RadEnv must be even. Increased by 1.&#39;</span><span class="p">)</span>
            <span class="n">n_azi</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">base_case</span><span class="p">)</span>  <span class="c"># Keep a copy of the uvspec base_case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">levels_out_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">n_levels_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">solver</span>  <span class="c"># Radiative transfer solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">base_case</span><span class="p">)</span>  <span class="c"># Keep a copy for transmittance computation purposes</span>
        <span class="n">view_zen_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">n_pol</span><span class="p">)</span>  <span class="c"># Viewing straight down is view zenith angle of 180 deg</span>
        <span class="n">prop_zen_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_pol</span><span class="p">)</span>  <span class="c"># Radiation travelling straight up is propagation zenith angle of 0</span>
        <span class="n">umu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">prop_zen_angles</span><span class="p">)</span>  <span class="c"># Negative umu is upward-looking, downwards propagating</span>
        <span class="k">if</span> <span class="n">hemi</span><span class="p">:</span>
            <span class="n">prop_azi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">n_azi</span><span class="p">)</span>
            <span class="n">view_azi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_azi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prop_azi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">n_azi</span><span class="p">)</span>
            <span class="n">view_azi_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span>  <span class="n">n_azi</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">prop_azi_angles</span>
        <span class="n">n_azi_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prop_azi_angles</span><span class="p">))</span><span class="o">/</span><span class="n">mxphi</span><span class="p">))</span>
        <span class="n">n_pol_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prop_zen_angles</span><span class="p">))</span><span class="o">/</span><span class="n">mxumu</span><span class="p">))</span>
        <span class="c"># Create an list of lists with all these batches of librad.Case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">base_case</span><span class="p">)</span> <span class="k">for</span> <span class="n">i_azi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_azi_batch</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j_pol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pol_batch</span><span class="p">)]</span>

        <span class="c"># TODO : Take care of phi0 input in the case of hemi=True</span>
        <span class="k">for</span> <span class="n">iazi</span><span class="p">,</span> <span class="n">iazi_start</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">mxphi</span><span class="p">)):</span>
            <span class="n">batch_azi</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">iazi_start</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">iazi_start</span><span class="o">+</span><span class="n">mxphi</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">ipol</span><span class="p">,</span> <span class="n">ipol_start</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">umu</span><span class="p">),</span> <span class="n">mxumu</span><span class="p">)):</span>
                <span class="n">batch_pol</span> <span class="o">=</span> <span class="n">umu</span><span class="p">[</span><span class="n">ipol_start</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ipol_start</span><span class="o">+</span><span class="n">mxumu</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">umu</span><span class="p">))]</span>
                <span class="c"># Set the umu and phi keyword parameters</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;phi&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">batch_azi</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;umu&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">batch_pol</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">infile</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">infile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
                                                 <span class="s">&#39;_{:04d}_{:04d}.INP&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ipol</span><span class="p">,</span> <span class="n">iazi</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">outfile</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">outfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
                                                 <span class="s">&#39;_{:04d}_{:04d}.OUT&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ipol</span><span class="p">,</span> <span class="n">iazi</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                                 <span class="s">&#39;_{:04d}_{:04d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ipol</span><span class="p">,</span> <span class="n">iazi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">hemi</span><span class="p">:</span>  <span class="c"># Doing only one hemisphere along solar principal plane</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">ipol</span><span class="p">][</span><span class="n">iazi</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;phi0&#39;</span><span class="p">,</span> <span class="s">&#39;0.0&#39;</span><span class="p">])</span>  <span class="c"># Sun shining towards North</span>
        <span class="c"># Create a flattened list view of the cases</span>
        <span class="c"># Put all the cases into a single list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">))</span>  <span class="c"># This creates a linear view of the cases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hemi</span> <span class="o">=</span> <span class="n">hemi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_azi</span> <span class="o">=</span> <span class="n">n_azi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pol</span> <span class="o">=</span> <span class="n">n_pol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span> <span class="o">=</span> <span class="n">n_azi_batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pol_batch</span> <span class="o">=</span> <span class="n">n_pol_batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">prop_azi_angles</span><span class="p">,</span> <span class="s">&#39;phi&#39;</span><span class="p">,</span> <span class="s">&#39;deg&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umu</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">umu</span><span class="p">,</span> <span class="s">&#39;umu&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pza</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">prop_zen_angles</span><span class="p">,</span> <span class="s">&#39;pza&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paz</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">prop_azi_angles</span><span class="p">),</span> <span class="s">&#39;paz&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vza</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">view_zen_angles</span><span class="p">,</span> <span class="s">&#39;vza&#39;</span><span class="p">,</span> <span class="s">&#39;deg&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vaz</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">view_azi_angles</span><span class="p">,</span> <span class="s">&#39;vaz&#39;</span><span class="p">,</span> <span class="s">&#39;deg&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_water_clouds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">has_water_clouds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_ice_clouds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">has_ice_clouds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_case</span><span class="o">.</span><span class="n">has_clouds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sza</span> <span class="o">=</span> <span class="n">n_sza</span>
        <span class="k">if</span> <span class="n">n_sza</span><span class="p">:</span>  <span class="c"># Setup the transmission run cases</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_trans_cases</span><span class="p">(</span><span class="n">n_sza</span><span class="o">=</span><span class="n">n_sza</span><span class="p">)</span>
            <span class="c"># self.trans_vza_up = []</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
</div>
<div class="viewcode-block" id="RadEnv.setup_trans_cases"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.setup_trans_cases">[docs]</a>    <span class="k">def</span> <span class="nf">setup_trans_cases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_sza</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Setup a list of cases for computing the transmission matrices between every level defined in the</span>
<span class="sd">        REM (and at every wavelength and stokes parameter combination). The computation of  transmittance between</span>
<span class="sd">        levels is accomplished in `MORTICIA` using libRadtran/uvspec by computing the direct solar irradiance</span>
<span class="sd">        transmittance for multiple zenith angles.</span>

<span class="sd">        Note that if there is an optically thick cloud layer between two levels in the REM, the transmittance</span>
<span class="sd">        will compute as zero or very small. This will also result in the incorrect/noisy computation of path</span>
<span class="sd">        radiances between the two levels. This situation is unavoidable. The recommended approach is that</span>
<span class="sd">        REMS be computed with altitude levels that all lie between cloud layers (i.e. no levels in the REM</span>
<span class="sd">        span a cloud layer). The user, or the code which uses the REMs should see to this. Essentially it must</span>
<span class="sd">        be recognised that optical surveillance is not possible through optically thick cloud layers.</span>

<span class="sd">        The REM is provided with a cloud flag that indicates if the base case incorporates clouds. The approach to</span>
<span class="sd">        computing inter-level transmittance (optical depth is the stored parameter, since this scales more</span>
<span class="sd">        closely in a linear fashion with distance) in the presence of cloud is to vary the &#39;cloudcover&#39;</span>
<span class="sd">        keyword parameter (water and ice clouds independently). This is done for solar zenith angle of zero.</span>
<span class="sd">        The optical thickness from TOA to the level in question is then computed as a function of cloud cover</span>
<span class="sd">        fraction (CCF). The optical depth between levels (i.e the optical depth of a layer between two levels)</span>
<span class="sd">        is computed as the difference in optical depth to TOA of the lower level minus the optical depth to TOA</span>
<span class="sd">        of the upper level. If there is no difference in the layer optical depth when the CCF is varied from</span>
<span class="sd">        zero to some positive value (say 0.1, but not as high as 1), then the layer is free of cloud.</span>

<span class="sd">        A flag per layer is thus obtained which indicates if the layer contains cloud. If it does, the transmittance</span>
<span class="sd">        will compute as zero between the two levels in question. This means that the cloud base is not resolved</span>
<span class="sd">        to better than the level resolution in the REM. It is probably then quite important to ensure that</span>
<span class="sd">        cloud base altitude statistics are available in the theatre climatology.</span>

<span class="sd">        An upgrade to cloud handling could be to read the cloud profile files in order to obtain the exact vertical</span>
<span class="sd">        location of the cloud layers.</span>

<span class="sd">        Another inherent and unavoidable problem with computation of path optical depths and radiances using</span>
<span class="sd">        libRadtran/uvspec is that precisely horizontal paths cannot be dealt with using one-dimensional RT</span>
<span class="sd">        solvers. Therefore in this case, the maximum range that can be dealt with depends on the height difference</span>
<span class="sd">        between the REM levels and the maximum solar zenith angle (SZA) used for computation of optical depth.</span>

<span class="sd">        A further implication of the above point is that path transmittances and path radiances cannot be interpolated</span>
<span class="sd">        between the SZA nearest the horizon and the horizon proper. Some form of logarithmic extrapolation could be</span>
<span class="sd">        performed, but could result in large errors due to failure of Beer&#39;s Law and other problems.</span>

<span class="sd">        Execution and attribution of transmittance cases will provide each level with transmittance to the level</span>
<span class="sd">        above that altitude level. Therefore the topmost level will have transmittances to TOA, but the</span>
<span class="sd">        bottom level will not have transmittances (optical depths) to BOA, unless the bottom level *is* BOA.</span>
<span class="sd">        It is recommended that all MORTICIA base cases for REM include BOA as an output level.</span>

<span class="sd">        :param n_sza: The number of solar zenith angles at which to compute path optical depth and radiances.</span>
<span class="sd">             the SZA values are computed equi-spaced in the cosine of the solar zenith angle rather that the</span>
<span class="sd">             SZA itself. This is to help with the problem that the slant range between levels increases</span>
<span class="sd">             in linear relation to the secant of the view zenith angle. The optical depths are later</span>
<span class="sd">             interpolated to the same</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Start by removing any cloud options in the transmission base_case, as well as any radiance options</span>
        <span class="c"># to reduce runtime.</span>
        <span class="n">new_option_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_tokens_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># TODO : setup up transmission case series with AND without clouds</span>
        <span class="c"># Remove radiance options to speed up transmission series computations</span>
        <span class="n">options_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;umu&#39;</span><span class="p">,</span> <span class="s">&#39;phi&#39;</span><span class="p">,</span> <span class="s">&#39;phi0&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ioption</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">option</span> <span class="o">==</span> <span class="n">removal_option</span> <span class="k">for</span> <span class="n">removal_option</span> <span class="ow">in</span> <span class="n">options_to_remove</span><span class="p">]):</span>
                <span class="k">pass</span>  <span class="c"># TODO : Look for other cloud options that may be important</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_option_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>
                <span class="n">new_tokens_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">ioption</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">new_option_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">new_tokens_list</span>
        <span class="c"># There are no radiance calculations now, so set n_phi and n_umu to zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">n_umu</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">umu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">pza</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">paz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Change the transmission base case to output_quantity reflectivity. THis seems counter-intuitive,</span>
        <span class="c"># but take a look at the libRadtran/uvspec manual to see why. Essentially, the reflectivity</span>
        <span class="c"># option computes the ratio of the horizontal irradiance to the horizontal irradiance at TOA.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;output_quantity&#39;</span><span class="p">,</span> <span class="s">&#39;reflectivity&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;sza&#39;</span><span class="p">,</span> <span class="s">&#39;0.0&#39;</span><span class="p">])</span>
        <span class="c"># Calculate the view zenith angles equi-spaced in the secant of the VZA</span>
        <span class="c"># First upward looking</span>
        <span class="n">cosine_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_sza</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Drop the last element because it is horizontal (illegal)</span>
        <span class="c"># Calculate the view-zenith angles in radians</span>
        <span class="n">vpa_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosine_up</span><span class="p">)</span>  <span class="c"># view polar angle looking upwards</span>
        <span class="c"># If less than the minimum depression angle for the REM, add a point</span>
        <span class="n">rem_pza_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="k">if</span> <span class="n">vpa_up</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rem_pza_limit</span><span class="p">:</span>
            <span class="n">vpa_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">vpa_up</span><span class="p">,</span> <span class="n">rem_pza_limit</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_vza_up</span> <span class="o">=</span> <span class="n">xd_identity</span><span class="p">(</span><span class="n">vpa_up</span><span class="p">,</span> <span class="s">&#39;vza&#39;</span><span class="p">,</span> <span class="s">&#39;rad&#39;</span><span class="p">)</span>
        <span class="c"># Now build a list of uvspec runs, based on trans_base_case</span>
        <span class="c"># The list is called trans_cases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i_case</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vpa_up</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="p">))</span>
            <span class="c"># Set the solar zenith angle</span>
            <span class="n">sza</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_vza_up</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>  <span class="c"># Solar zenith angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;sza&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">sza</span><span class="p">)])</span>
            <span class="c"># Set cloudcover to zero if the case has water or ice clouds</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">has_water_clouds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;cloudcover&#39;</span><span class="p">,</span> <span class="s">&#39;wc&#39;</span><span class="p">,</span> <span class="s">&#39;0.0&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="o">.</span><span class="n">has_ice_clouds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;cloudcover&#39;</span><span class="p">,</span> <span class="s">&#39;ic&#39;</span><span class="p">,</span> <span class="s">&#39;0.0&#39;</span><span class="p">])</span>
            <span class="c"># Set pseudospherical option above sza of 75 degrees and solver is disort or twostr</span>
            <span class="k">if</span> <span class="n">sza</span> <span class="o">&gt;</span> <span class="mf">75.0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="n">thesolver</span> <span class="k">for</span> <span class="n">thesolver</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;disort&#39;</span><span class="p">,</span> <span class="s">&#39;disort2&#39;</span><span class="p">,</span> <span class="s">&#39;sdisort&#39;</span><span class="p">,</span>
                                                           <span class="s">&#39;spsdisort&#39;</span><span class="p">,</span> <span class="s">&#39;fdisort1&#39;</span><span class="p">,</span> <span class="s">&#39;fdisort2&#39;</span><span class="p">,</span> <span class="s">&#39;twostr&#39;</span><span class="p">]]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;pseudospherical&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">])</span>
            <span class="c"># Change the name and input and output filenames, the _x_ is for transmission runs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">infile</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">infile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
                                             <span class="s">&#39;_x_{:04d}.INP&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_case</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">outfile</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">outfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
                                             <span class="s">&#39;_x_{:04d}.OUT&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_case</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">[</span><span class="n">i_case</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                             <span class="s">&#39;_x_{:04d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_case</span><span class="p">))</span>
        <span class="c"># The transmission cases should be ready to run a this point.</span>
        <span class="c"># The run_ipyparallel method will run these cases, but not in parallel with</span>
        <span class="c"># the radiance cases.</span>
        <span class="c"># Next, create the cloudcover series to detect cloud layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># If there are clouds in this case, run three cases with cloud cover fraction of 0.0, 0.5 and 1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;cloudcover&#39;</span><span class="p">,</span> <span class="s">&#39;0.0&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;cloudcover&#39;</span><span class="p">,</span> <span class="s">&#39;0.5&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_base_case</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">alter_option</span><span class="p">([</span><span class="s">&#39;cloudcover&#39;</span><span class="p">,</span> <span class="s">&#39;1.0&#39;</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="RadEnv.run_ipyparallel"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.run_ipyparallel">[docs]</a>    <span class="k">def</span> <span class="nf">run_ipyparallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ipyparallel_view</span><span class="p">,</span> <span class="n">stderr_to_file</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run a complete set of radiant environment map cases of libRadtran/uvspec using the `ipyparallel`</span>
<span class="sd">        Python package, which provides parallel computation from Jupyter notebooks and other Python launch</span>
<span class="sd">        modes.</span>
<span class="sd">        Typical code for setting up the view:</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">               from ipyparallel import Client</span>
<span class="sd">               paraclient = Client(profile=&#39;mycluster&#39;, sshserver=&#39;me@mycluster.info&#39;, password=&#39;mypassword&#39;)</span>
<span class="sd">               paraclient[:].use_dill()  # Need dill as a pickle replacement for our purposes here</span>
<span class="sd">               ipyparallel_view = paraclient.load_balanced_view()</span>
<span class="sd">               ipyparallel_view.block = True  # Must wait for completion of all tasks on the cluster</span>

<span class="sd">        Note that if new ipengines are started, use_dill() must be executed again. The use_dill() call</span>
<span class="sd">        should be a routine before every function map to the cluster.</span>


<span class="sd">        :param ipyparallel_view: an ipyparallel view of a Python engine cluster (see ipyparallel documentation.)</span>

<span class="sd">        :param stderr_to_file: If set to True, standard error output will be sent to a file. use only for debugging</span>
<span class="sd">            purposes.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The following does work, but the list casechain is completely reassigned</span>
        <span class="c"># instead of being assigned element for element</span>
        <span class="c"># TODO : Consider passing in the client instead, to set blocking and use_dill() EVERY time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span> <span class="o">=</span> <span class="n">ipyparallel_view</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Case</span><span class="o">.</span><span class="n">run</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">)</span>
        <span class="c"># Now recreate the list of lists view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">[</span><span class="n">i_pol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span> <span class="o">+</span> <span class="n">i_azi</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_azi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span><span class="p">)]</span>
                                                                        <span class="k">for</span> <span class="n">i_pol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pol_batch</span><span class="p">)]</span>
        <span class="c"># Compile the radiance results into one large array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">i_pol</span><span class="p">][</span><span class="n">i_azi</span><span class="p">]</span><span class="o">.</span><span class="n">uu</span> <span class="k">for</span> <span class="n">i_pol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pol_batch</span><span class="p">)])</span>
                                                                    <span class="k">for</span> <span class="n">i_azi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span><span class="p">)])</span>
        <span class="c"># if self.hemi:  # Double up in the azimuth direction, but flip as well</span>
        <span class="c">#     self.uu = np.hstack([self.uu, self.uu[:,::-1,...]])</span>
        <span class="c">#     # Perform doubling up in all azimuth variables</span>
        <span class="c">#     self.pza = xray.concat((self.pza, self.pza + np.pi), dim=&#39;pza&#39;)</span>
        <span class="c">#     self.phi = xray.concat((self.phi, self.phi + 180), dim=&#39;phi&#39;)</span>
        <span class="c">#     self.vaz = xray.concat((self.vaz, self.vaz + 180), dim=&#39;vaz&#39;)  # view azimuth angle</span>
        <span class="c"># Delete the individual results in an attempt to save memory</span>
        <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">case</span><span class="o">.</span><span class="n">uu</span>
        <span class="c"># Concatenate the cases in umu and phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">xray</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">case_uu</span><span class="o">.</span><span class="n">xd_uu</span> <span class="k">for</span> <span class="n">case_uu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">jj</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span>
                                                 <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">))],</span> <span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span>
        <span class="c">#self.xd_uu = xray.DataArray(self.uu, [self.pza, self.paz, self.spectral, self.levels, self.stokes])</span>
        <span class="c"># Replace the values in the xray.DataArray with the exact original values in the zenith and azimuth</span>
        <span class="c"># directions. Not doing this gave rise to a very subtle bug in spherical harmonic fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">[</span><span class="s">&#39;pza&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pza</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">[</span><span class="s">&#39;paz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span>
        <span class="c"># Also need to obtain the irradiances from one of the cases - they should actually all be the same</span>
        <span class="c"># TODO : Obtain self.fluxdata from one of the self.cases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fluxdata</span>  <span class="c"># Would really want this as a xray.DataArray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fluxline</span>
        <span class="c"># Run the transmittance sequences if there are any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sza</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span> <span class="o">=</span> <span class="n">ipyparallel_view</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Case</span><span class="o">.</span><span class="n">run</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">)</span>
            <span class="c"># If there are clouds in the radiant environment, run the could OD detection cases</span>
            <span class="c"># These cases reveal if there are layers in the REM that include clouds</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span> <span class="o">=</span> <span class="n">ipyparallel_view</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Case</span><span class="o">.</span><span class="n">run</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="p">)</span>
            <span class="c"># Compile the transmittance data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_path_transmittance</span><span class="p">()</span>
            <span class="c"># Compile the path radiance data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_path_radiance</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RadEnv.run_parallel"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.run_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">run_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run the RadEnv in multiprocessing mode on the local host.</span>

<span class="sd">        This is not yet tested, but should work with the multiprocessing package on the local host to use all</span>
<span class="sd">        the available cores. Will only work if libRadtran is installed on the local host.</span>

<span class="sd">        In order to use dill instead of pickle, it is necessary to use the pathos multiprocessing module</span>
<span class="sd">        instead of the standard multiprocessing module</span>

<span class="sd">        :param n_nodes: Number of compute nodes to use. Default is 4. Preferably set to number of cores you have</span>
<span class="sd">            available on the local host.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessingPool</span>
        <span class="n">worker_pool</span> <span class="o">=</span> <span class="n">ProcessingPool</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">n_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span> <span class="o">=</span> <span class="n">worker_pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Case</span><span class="o">.</span><span class="n">run</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">)</span>
        <span class="c"># Now recreate the list of lists view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">[</span><span class="n">i_pol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span> <span class="o">+</span> <span class="n">i_azi</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_azi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span><span class="p">)]</span>
                                                                        <span class="k">for</span> <span class="n">i_pol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pol_batch</span><span class="p">)]</span>
        <span class="c"># Compile the radiance results into one large array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">i_pol</span><span class="p">][</span><span class="n">i_azi</span><span class="p">]</span><span class="o">.</span><span class="n">uu</span> <span class="k">for</span> <span class="n">i_pol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pol_batch</span><span class="p">)])</span>
                                                                    <span class="k">for</span> <span class="n">i_azi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_azi_batch</span><span class="p">)])</span>
        <span class="c"># Delete the individual results in an attempt to save memory</span>
        <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">casechain</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">case</span><span class="o">.</span><span class="n">uu</span>
</div>
<div class="viewcode-block" id="RadEnv.sph_harm_fit"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.sph_harm_fit">[docs]</a>    <span class="k">def</span> <span class="nf">sph_harm_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;trapz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fit spherical harmonics to the radiant environment map (REM).</span>
<span class="sd">        One set of coefficients per wavelength or spectral channel will be fitted. The coefficients for each spectral</span>
<span class="sd">        bin/channel comprise one coefficient for order :math:`-m` to :math:`+m` for :math:`m = 0, 1, 2, ..., n`.</span>
<span class="sd">        The total number of coefficients is :math:`(n+1)^2`.</span>

<span class="sd">        The convention used for the spherical harmonics is that of Sloan with the Ramamoorthi and Hanrahan</span>
<span class="sd">        normalization. This is a real-valued basis defined as follows:</span>

<span class="sd">        .. math::</span>
<span class="sd">            y_{n}^{m}=\\begin{cases}</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\Re(Y_{n}^{m}) &amp; m&gt;0\\\\</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\Im(Y_{n}^{m}) &amp; m&lt;0\\\\</span>
<span class="sd">            Y_{n}^{0} &amp; m=0</span>
<span class="sd">            \\end{cases}=\\begin{cases}</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\cos m\\phi\\,P_{n}^{m}(\\cos\\theta) &amp; m&gt;0\\\\</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\sin|m|\\phi\\,P_{n}^{|m|}(\\cos\\theta) &amp; m&lt;0\\\\</span>
<span class="sd">            K_{n}^{0}P_{n}^{0}(\\cos\\theta) &amp; m=0</span>
<span class="sd">            \\end{cases},</span>

<span class="sd">        where the complex basis functions :math:`Y^{m}_{n}` are defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            Y_{n}^{m}(\\theta,\\phi)=K_{n}^{m}e^{im\\phi}P_{n}^{|m|}(\\cos\\theta),\\,n\\in\\mathbf{N},\\,-n\\leq m\\leq n,</span>

<span class="sd">        having the normalisation factor of:</span>

<span class="sd">        .. math::</span>
<span class="sd">            K_{n}^{m}=\\sqrt{\\frac{(2n+1)(n-|m|)!}{4\\pi(n+|m|)!}}.</span>

<span class="sd">        The definition of the complex basis functions is consistent with the</span>
<span class="sd">        `scipy.special &lt;http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.special.sph_harm.html&gt;`_</span>
<span class="sd">        definition of the spherical harmonics. Therefore, for fitting of the Sloan/Ramamoorthi/Hanrahan basis, the</span>
<span class="sd">        first definition is used above, that is :math:`y_{n}^{m}` can be calculated from the `scipy.special` function</span>
<span class="sd">        :math:`Y_{n}^{m}` as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            y_{n}^{m}=\\begin{cases}</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\Re(Y_{n}^{m}) &amp; m&gt;0\\\\</span>
<span class="sd">            (-1)^{m}\\sqrt{2}\\Im(Y_{n}^{m}) &amp; m&lt;0\\\\</span>
<span class="sd">            Y_{n}^{0} &amp; m=0</span>
<span class="sd">            \\end{cases}.</span>

<span class="sd">        The fitted coefficients of the spherical harmonics are computed by multiplying the REM by each of the</span>
<span class="sd">        harmonics and performing double numerical integration over zenith and azimuth angle as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            L_{n}^{m}=\\int_{\\theta=0}^{\\pi}\\int_{\\phi=0}^{2\\pi}L(\\theta,\\phi)y_{n}^{m}(\\theta,\\phi)\\sin\\theta d\\theta d\\phi,</span>

<span class="sd">        where :math:`L_{n}^{m}` are the coefficients and :math:`L(\\theta,\\phi)` is the REM.</span>

<span class="sd">        :param degree: Spherical harmonics up to this degree :math:`n`, for all orders :math:`m` will be fitted.</span>
<span class="sd">        :param method: Integration method by which the coefficients are computed. &#39;trapz&#39; for trapezoidal integration,</span>
<span class="sd">            &#39;sum&#39; for simple summation and &#39;simpson&#39; for Simpson&#39;s Rule. The &#39;trapz&#39; method seems to be</span>
<span class="sd">            considerably more accurate than &#39;sum&#39; or &#39;simpson&#39;. Therefore &#39;trapz&#39; is the default.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">sph_harm</span>
        <span class="n">azi_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="o">.</span><span class="n">data</span>  <span class="c"># Propagation zenith angles in radians</span>
        <span class="n">pol_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="o">.</span><span class="n">data</span>   <span class="c"># Propagation polar (zenith) angles in radians</span>
        <span class="n">azi_ang_delta</span> <span class="o">=</span> <span class="n">azi_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">azi_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pol_ang_delta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pol_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pol_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c"># print azi_ang_delta, pol_ang_delta</span>
        <span class="c"># Angles to be meshgridded - is this really necessary</span>
        <span class="c"># TODO : Check if meshgridding is really necessary</span>
        <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>
        <span class="n">sin_pol_angles</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pol_angles</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="p">])</span>
        <span class="c"># TODO : Symmetry checking still required</span>
        <span class="c"># if self.hemi:  # Sun-symmetric REM</span>
        <span class="n">sph_harm_coeff</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># If calculating over one hemisphere of a symmetrical REM with sun in the north-south line,</span>
        <span class="c"># The sine (imaginary) coefficients are zero and the cos (real components) are doubled</span>
        <span class="c"># SO should just run m = 0 to n, take twice the real part if hemi, otherwise full complex calc</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sph_harm_coeff</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>  <span class="c"># Add another list of coefficients for order m = 0 to n</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sph_harm_coeff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c"># Add another coefficient for order m</span>
                <span class="n">condon_short</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="c"># Compute the complex spherical harmonic basis</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">sph_harm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">condon_short</span> <span class="o">*</span> <span class="n">sph_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>  <span class="c"># Ramamoorthi normalisation</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hemi</span><span class="p">:</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">y_mn</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="mf">2.0</span>
                <span class="c"># Create xray.DataArray</span>
                <span class="n">y_mn</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">y_mn</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="p">])</span>
                <span class="c"># Compute the integrand</span>
                <span class="n">inner_integrand</span> <span class="o">=</span> <span class="n">y_mn</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span> <span class="o">*</span> <span class="n">sin_pol_angles</span>
                <span class="c"># Compute the coefficients by integration by various methods</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;sum&#39;</span><span class="p">:</span>  <span class="c"># Integrate by simple summation</span>
                    <span class="c"># First integrate over the propagation zenith angle using summation</span>
                    <span class="n">outer_integrand</span> <span class="o">=</span> <span class="n">inner_integrand</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pol_ang_delta</span>
                    <span class="c"># Then integrate over propagation azimuth</span>
                    <span class="n">sph_harm_coeff</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">outer_integrand</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">azi_ang_delta</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;trapz&#39;</span><span class="p">:</span>  <span class="c"># Integrate using the trapezoidal rule (seems best)</span>
                    <span class="n">outer_integrand</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="mf">2.0</span> <span class="o">*</span> <span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">pol_ang_delta</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="c"># Then integrate over the propagation azimuth angle</span>
                    <span class="n">sph_harm_coeff</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
                                              <span class="mf">2.0</span> <span class="o">*</span> <span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">azi_ang_delta</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;simpson&#39;</span><span class="p">:</span>  <span class="c"># The following is integration by Simpsons rule</span>
                    <span class="n">outer_integrand</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="mf">4.0</span> <span class="o">*</span> <span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="mf">2.0</span> <span class="o">*</span> <span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="n">inner_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">pza</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">pol_ang_delta</span> <span class="o">/</span> <span class="mf">3.0</span>
                    <span class="c"># Then integrate over the propagation azimuth angle</span>
                    <span class="n">sph_harm_coeff</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
                                              <span class="mf">4.0</span> <span class="o">*</span> <span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">+</span>
                                              <span class="mf">2.0</span> <span class="o">*</span> <span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="n">outer_integrand</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">paz</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">azi_ang_delta</span> <span class="o">/</span> <span class="mf">3.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown integration method &#39;</span> <span class="o">+</span> <span class="n">method</span> <span class="o">+</span> <span class="s">&#39; encountered in sph_harm_fit.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sph_harm_coeff</span> <span class="o">=</span> <span class="n">sph_harm_coeff</span>
        <span class="k">return</span> <span class="n">sph_harm_coeff</span>
</div>
<div class="viewcode-block" id="RadEnv.sph_harm_fat"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.sph_harm_fat">[docs]</a>    <span class="k">def</span> <span class="nf">sph_harm_fat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This code was used for debugging purposes - ignore</span>
<span class="sd">        :param degree:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">sph_harm</span>
        <span class="n">azi_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="o">.</span><span class="n">data</span>  <span class="c"># Propagation zenith angles in radians</span>
        <span class="n">pol_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="o">.</span><span class="n">data</span>   <span class="c"># Propagation polar (zenith) angles in radians</span>
        <span class="n">azi_ang_delta</span> <span class="o">=</span> <span class="n">azi_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">azi_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pol_ang_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pol_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pol_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c"># print azi_ang_delta, pol_ang_delta</span>
        <span class="c"># Angles to be meshgridded - is this really necessary</span>
        <span class="c"># TODO : Check if meshgridding is really necessary</span>
        <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>
        <span class="n">sin_pol_angles</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pol_angles</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="p">])</span>
        <span class="c"># TODO : Symmetry checking still required</span>
        <span class="c"># if self.hemi:  # Sun-symmetric REM</span>
        <span class="n">sph_harm_coeff_cos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sph_harm_coeff_sin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># If calculating over one hemisphere of a symmetrical REM with sun in the north-south line,</span>
        <span class="c"># The sine (imaginary) coefficients are zero and the cos (real components) are doubled</span>
        <span class="c"># SO should just run m = 0 to n, take twice the real part if hemi, otherwise full complex calc</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sph_harm_coeff_cos</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">sph_harm_coeff_sin</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span><span class="c"># Add another list of coefficients for order m = 0 to n</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sph_harm_coeff_cos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="c"># Add another coefficient for order m</span>
                <span class="n">sph_harm_coeff_sin</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="c"># Compute the complex spherical harmonic basis</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">sph_harm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>  <span class="c"># Small imaginary components may arise - drop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">sph_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">azi_angles</span><span class="p">,</span> <span class="n">pol_angles</span><span class="p">)</span>  <span class="c"># Ramamoorthi normalisation</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hemi</span><span class="p">:</span>  <span class="c"># integrate over hemisphere, therefore need a factor of 2</span>
                    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">y_mn</span> <span class="o">*</span> <span class="mf">2.0</span>  <span class="c"># equivalent of taking only the cosine components times 2</span>
                <span class="c"># Create xray.DataArray</span>
                <span class="n">y_mn_cos</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">y_mn</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="p">])</span>
                <span class="n">y_mn_sin</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">y_mn</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paz</span><span class="p">])</span>
                <span class="c"># Compute the integrand</span>
                <span class="n">inner_integrand_cos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span> <span class="o">*</span> <span class="n">y_mn_cos</span> <span class="o">*</span> <span class="n">sin_pol_angles</span>
                <span class="c"># Compute the coefficients</span>
                <span class="c"># First integrate over the propagation zenith angle using summation (very slight overestimate)</span>
                <span class="n">outer_integrand_cos</span> <span class="o">=</span> <span class="n">inner_integrand_cos</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pol_ang_delta</span>
                <span class="c"># Then integrate over the propagation azimuth angle</span>
                <span class="n">sph_harm_coeff_cos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">outer_integrand_cos</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">azi_ang_delta</span>

                <span class="c"># Compute the sin integrand</span>
                <span class="n">inner_integrand_sin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span> <span class="o">*</span> <span class="n">y_mn_sin</span> <span class="o">*</span> <span class="n">sin_pol_angles</span>
                <span class="c"># Compute the coefficients</span>
                <span class="c"># First integrate over the propagation zenith angle using summation (very slight overestimate)</span>
                <span class="n">outer_integrand_sin</span> <span class="o">=</span> <span class="n">inner_integrand_sin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">pol_ang_delta</span>
                <span class="c"># Then integrate over the propagation azimuth angle</span>
                <span class="n">sph_harm_coeff_sin</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">outer_integrand_sin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s">&#39;paz&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">azi_ang_delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sph_harm_coeff_cos</span> <span class="o">=</span> <span class="n">sph_harm_coeff_cos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sph_harm_coeff_cos</span> <span class="o">=</span> <span class="n">sph_harm_coeff_cos</span>
        <span class="k">return</span> <span class="n">sph_harm_coeff_cos</span><span class="p">,</span> <span class="n">sph_harm_coeff_sin</span>
</div>
<div class="viewcode-block" id="RadEnv.compute_path_transmittance"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.compute_path_transmittance">[docs]</a>    <span class="k">def</span> <span class="nf">compute_path_transmittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute path transmittances from the set of libRadtran/uvspec runs executed for solar zenith angles</span>
<span class="sd">        of 0 to near 90 degrees.</span>

<span class="sd">        This method computes optical depth (-log(transmittance)) of all paths from a particular level, both</span>
<span class="sd">        upward and downward. Paths that lie in the horizontal &quot;blind zone&quot; are assigned OD of 0.0. These should</span>
<span class="sd">        actually be assigned OD of np.nan or perhaps np.inf.</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            RadEnv.setup_trans_cases()</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Run through all the cases in the self.trans_cases and compile the direct solar irradiance data</span>
        <span class="c"># This is actually transmittance data (edir is not a flux/irradiance with output_quantity reflectivity)</span>
        <span class="k">for</span> <span class="n">trans_case</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">:</span>
            <span class="c"># Add a propagation zenith angle for each sza. The pza is pi - sza (in radians)</span>
            <span class="c"># trans_case.xd_edir = trans_case.xd_edir.assign_coords(pza=np.pi - np.deg2rad(trans_case.sza))</span>
            <span class="n">trans_case</span><span class="o">.</span><span class="n">xd_edir</span> <span class="o">=</span> <span class="n">trans_case</span><span class="o">.</span><span class="n">xd_edir</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">pza</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">trans_case</span><span class="o">.</span><span class="n">sza</span><span class="p">))</span>
        <span class="c"># Concatenate results from all transmission runs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_edir</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">this_case</span><span class="o">.</span><span class="n">xd_edir</span> <span class="k">for</span> <span class="n">this_case</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_cases</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">)</span>
        <span class="c"># Interpolate transmission results onto the pza grid for the RadEnv</span>
        <span class="c"># This is not a &quot;harmonisation&quot; interpolation. The transmission grid is being interpolated</span>
        <span class="c"># onto another grid in pza (propagation zenith angle)</span>
        <span class="c"># TODO : Check out reliability of using quadratic/cubic interpolation for transmittance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_trans_toa</span> <span class="o">=</span> <span class="n">xd_interp_axis_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_edir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s">&#39;pza&#39;</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span>
                                              <span class="n">fill_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_trans_toa</span><span class="p">)</span>  <span class="c"># Compute the optical depths from a level to TOA</span>
        <span class="c"># Subtract the optical depth of the level above it.</span>
        <span class="c"># This provides the optical depth from any level to the level above it</span>
        <span class="n">xd_opt_depth</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">)</span>
        <span class="c">#  TODO : Set long_name and units of optical depth</span>
        <span class="c"># xd_opt_depth.attrs[&#39;long_name&#39;] = long_name[&#39;od&#39;]</span>
        <span class="c"># Implicitly, the optical depth from the top level is known to TOA so concat those values</span>
        <span class="n">levels_axis_num</span> <span class="o">=</span> <span class="n">xd_opt_depth</span><span class="o">.</span><span class="n">get_axis_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">)</span>
        <span class="n">levels_out_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span>  <span class="c"># just to shorten it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">xd_opt_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span><span class="p">[{</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}]),</span>
                                        <span class="n">dim</span><span class="o">=</span><span class="n">levels_out_type</span><span class="p">)</span>
        <span class="c"># Now confront the problem of computing optical depths to the level below</span>
        <span class="c"># For the lowest level, the optical depths to the level below are undefined, perhaps an appropriate</span>
        <span class="c"># value is np.nan. Otherwise, the optical depth looking to the next lower level is found by</span>
        <span class="c"># flipping the OD data from the lower level along the pza axis and summing to upper level</span>
        <span class="k">for</span> <span class="n">ilevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c"># Start at the top and work down</span>
            <span class="c"># Create a copy of the optical depths from the level beneath ilevel</span>
            <span class="n">opt_depth_from_beneath</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span><span class="p">[{</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span><span class="o">-</span><span class="mi">1</span><span class="p">}])</span>
            <span class="c"># Flip optical depth along the pza axis</span>
            <span class="n">opt_depth_from_beneath</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">opt_depth_from_beneath</span><span class="p">[{</span><span class="s">&#39;pza&#39;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)}]</span><span class="o">.</span><span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span><span class="p">[{</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span><span class="p">}]</span> <span class="o">+=</span> <span class="n">opt_depth_from_beneath</span>
            <span class="c"># Replace optical depths of zero with nan</span>
            <span class="c"># self.xd_opt_depth[{levels_out_type: ilevel}]</span>
        <span class="c"># Now compute the transmittance between levels as np.exp(optical_depth)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_opt_depth</span><span class="p">)</span>
        <span class="c"># TODO : Put in correct long_name and and units (unitless actually)</span>
        <span class="c"># Now run through the cases in the cloud detection sequence to find layers affected by clouds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_clouds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">librad_case</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_detect_cases</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c">#  TODO : Cloud detection</span>

</div>
<div class="viewcode-block" id="RadEnv.compute_path_radiance"><a class="viewcode-back" href="../radpack.html#librad.RadEnv.compute_path_radiance">[docs]</a>    <span class="k">def</span> <span class="nf">compute_path_radiance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute path radiances for path segments between all altitudes in the REM.</span>
<span class="sd">        The path transmittances (optical depth) as well as the total radiances at each altitude are required to</span>
<span class="sd">        calculate path radiances. If :math:`L_{pi}^{\\downarrow}` is the downwelling path radiance at level :math:`i`</span>
<span class="sd">        originating between level :math:`i` and level :math:`i+1` and :math:`L_{pi}^{\\uparrow}` is the upwelling</span>
<span class="sd">        path radiance at level :math:`i` originating between level :math:`i` and level :math:`i-1`, then</span>

<span class="sd">        .. math::</span>

<span class="sd">            L_{pi}^{\\downarrow}=L_{i}^{\\downarrow}-L_{i+1}^{\\downarrow}\\tau_{i+1}^{\\downarrow},</span>

<span class="sd">        and</span>

<span class="sd">        .. math::</span>

<span class="sd">            L_{pi}^{\\uparrow}=L_{i}^{\\uparrow}-L_{i-1}^{\\uparrow}\\tau_{i-1}^{\\uparrow}.</span>

<span class="sd">        :math:`L_{i}^{\\uparrow}` is the lower hemisphere (upwelling hemisphere) of the REM and</span>
<span class="sd">        :math:`\\tau_{i}^{\\uparrow}` is the transmission between level :math:`i` and level :math:`i+1`.</span>


<span class="sd">        .. seealso:: RadEnv.compute_path_transmittance()</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First compute the product of radiance and transmittance at every level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu_times_tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_trans</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span>
        <span class="c"># The upper and lower hemispheres of the path radiance REMs have to be computed separately as shown in</span>
        <span class="c"># the docstring equations. Typical up/downwelling indexing is xd_uu[xd_uu[&#39;pza&#39;] &lt; np.pi/2].</span>
        <span class="c"># Run through the levels first from bottom level to top, computing the downwelling path radiance</span>
        <span class="c"># to the level above.</span>
        <span class="c"># Initialise path radiance to something having same units etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">)</span>  <span class="c"># Initialise to total radiance</span>
        <span class="k">for</span> <span class="n">ilevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># Set up hemispherical indexing for this level</span>
            <span class="n">hemi_index_level</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span><span class="p">,</span> <span class="s">&#39;pza&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="s">&#39;pza&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
            <span class="c"># Setup hemisperhical indexing for next level up</span>
            <span class="n">hemi_index_above</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;pza&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="s">&#39;pza&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="n">hemi_index_level</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">[</span><span class="n">hemi_index_level</span><span class="p">]</span> <span class="o">-</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu_times_tau</span><span class="p">[</span><span class="n">hemi_index_above</span><span class="p">])</span>
        <span class="c"># Now run from top level down to bottom, computing upwelling path radiance</span>
        <span class="k">for</span> <span class="n">ilevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_levels_out</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c"># Set up hemispherical indexing for this level</span>
            <span class="n">hemi_index_level</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span><span class="p">,</span> <span class="s">&#39;pza&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="s">&#39;pza&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
            <span class="c"># Setup hemisperhical indexing for next level down</span>
            <span class="n">hemi_index_below</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_out_type</span><span class="p">:</span> <span class="n">ilevel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;pza&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="s">&#39;pza&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xd_path_radiance</span><span class="p">[</span><span class="n">hemi_index_level</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xd_uu</span><span class="p">[</span><span class="n">hemi_index_level</span><span class="p">]</span> <span class="o">-</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">xd_uu_times_tau</span><span class="p">[</span><span class="n">hemi_index_below</span><span class="p">])</span>
</pre></div></div></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, D Griffith, A Ramkilowan.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>